#! C:/Program Files/Nuke9.0v4/nuke-9.0.1.dll -nx
version 9.0 v1
Gizmo {
 name LUE
 selected true
 xpos 130
 ypos 63
 addUserKnob {20 Primaries}
 addUserKnob {26 Credits l "" +STARTLINE T "<img src=C:/Users/Mads/.nuke/LUE/lue.png>"}
 addUserKnob {22 Init_logo l INVISIBLE +INVISIBLE T "DotNuke = nukescripts.getNukeUserFolder() \nif os.path.isfile(DotNuke+\"/LUE/lue.png\"):\n\tnuke.thisNode().knob(\"Credits\").setValue(\"<img src=\"+DotNuke+\"/LUE/lue.png>\")" +STARTLINE}
 addUserKnob {52 Init_Init_logo T "nuke.thisNode().knob(\"Init_logo\").execute()" +STARTLINE}
 addUserKnob {52 init_init_colorwheel l "" +STARTLINE T "nuke.thisNode().knob(\"init_colorwheel\").execute()" +STARTLINE}
 addUserKnob {22 init_colorwheel l INVISIBLE +INVISIBLE T "import sys, math\nimport nuke\nimport PySide.QtGui as QtGui\nimport PySide.QtCore as QtCore\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\nfrom PySide.QtWebKit import *\nfrom nukescripts import panels\nimport datetime\n#Projekt Variabler\n\n#FasteVariabler\ntry:\n\tif defined == 1:\n\t    pass\n\t    #print \"allready launched\"\nexcept: \n\tclass ColorWheelWidget(QtGui.QWidget):\n\t    def __init__(self, parent=None, mainDiameter=138, outerRingWidth=10,my_Knob=\"None\"):\n\t        QtGui.QWidget.__init__(self, parent)\n\t        # this is the pixel diameter of the actual color wheel, without the extra decorations drawn as part of this widget\n\t        self.dim = mainDiameter\n\t        self.offset = outerRingWidth\n\t        self.ColorKnob = my_Knob\n\t        self.colorWheelSensitivity = 0.1\n\t        self.setstate = 0\n\t        self.bMouseDown = False\n\t        self.shiftDown = False\n\t        self.ctrlDown = False\n\t        self.altDown = False\n\t        self.guiSelection = 0\n\t        self.middleMouse = 0\n\t        self.initialPoint = (0,0)    \n\t        self.master_radius = (self.dim/2)+self.offset+1\n\t        self.huepoint = (self.master_radius, self.master_radius)\n\t        self.value_angle = 360\n\t        self.value_angleSat = 0\t   \n\t        color = QtGui.QColor(0,0,0,0).rgba()\n\t        self.myTimer = QtCore.QTime()\n\t \n\t        self.center = (self.master_radius, self.master_radius)\n\t        # this is the color value that this widget represents\n\t        self.color = QtGui.QColor()\n\n\n\n\t        # the color wheel image, only needs to be generated once\n\t        self.image = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        # this is the image for the current color selection\n\t        self.current_image = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        self.current_image.fill(QtGui.QColor(self.color).rgba())\n\t        self.current_imageB = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        self.current_imageB.fill(QtGui.QColor(self.color).rgba())       \n\t        # these are used for the current color selection image\n\t        self.lastPoint = (self.master_radius, self.master_radius)\n\t        self.currentPoint = (self.master_radius, self.master_radius)\n\t        self.points = self.getRadialLinePoints((self.dim / 2), self.master_radius, 45)\n\t        self.points2 = self.getRadialLinePoints((self.dim / 2), self.master_radius, 135)\t        \n\t        self.image.fill(color)\n\n\n\t        self.color.setRgbF(min(1,max(0,my_Knob.value()\[0])),min(1,max(0,my_Knob.value()\[1])),min(1,max(0,my_Knob.value()\[2])))\n\n\n\t        self.luma = (my_Knob.value()\[3]/2.0)*255.0\n\t        self.hue = self.color.hueF()*255.0\n\t        self.sat = self.color.saturationF()*255.0\n\t   \n\n\t        self.setUIColor(self.hue,self.sat,self.luma) \n\n\t        for y in range(int(self.master_radius*2)):\n\t            for x in range(int(self.master_radius*2)):\n\t                d = 2 * self.getDist((x,y),self.center) / self.dim\n\t                if d <= 1: #Hue Wheel\n\t                    color = QtGui.QColor()\n\t                    hue = self.getHue(x, y)\n\t                    percent = max(0,min(1,(d - 0.90)*30))\n\t                    color.setHsv(hue,(d*255),90+(165*percent),90+(165*percent)) #The dark part in the center\n\n\t                    self.image.setPixel(x,y, color.rgba())\n\t                else:\n\t                    d2 = self.getDist((x,y),self.center) / (self.master_radius-1)\n\t                    if d2 > 1: #MainBG                       \n\t                        color = QtGui.QColor()\n\t                        color.setAlpha(0)\n\t                        self.image.setPixel(x,y, color.rgba())\n\t                    else:\n\t                    \tpass\n\n\t        self.setUIColor(self.hue,self.sat,self.luma) \n\t        self.setColor(self.hue, self.sat, self.luma)\n\n\n\t    def getRadialLinePoints(self, r_inner, r_outer, angle,distance=1.0):\n\t        rad = math.radians(angle)\n\t        sr = math.sin(rad)\n\t        cr = math.cos(rad)\n\t        x1 = r_outer - (r_outer * (sr*distance))\n\t        y1 = r_outer - (r_outer * (cr*distance)) \n\t        x2 = r_outer - (r_inner * (sr*distance))\n\t        y2 = r_outer - (r_inner * (cr*distance))\n\t        return (x1, y1, x2, y2)\n\t  \n\t    def getRot(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2*(x - self.master_radius),2*(y - self.master_radius)))) % 360\n\t    def getLum(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2.0*(x - self.master_radius),2.0*(y - self.master_radius)))) % 360\n\n\t    def getHue(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2*(x - self.master_radius),2*(y - self.master_radius))) + 165 ) % 360\n\t    \n\t    def setColor(self, h, s, v):\n\n\t        self.color.setHsvF(0.0,0.0,min(1,v/255.0))\n\t        alpha = self.current_image.alphaChannel()\n\t        self.current_image.fill(self.color.rgb())\n\t        self.current_image.setAlphaChannel(alpha)\n\t        self.color.setHsvF(min(1,h/255.0),1.0,min(1,v/255.0)) #Should be 255 and not 254.5 but it causes a unknown error!\n\t        alpha = self.current_imageB.alphaChannel()\n\t        self.current_imageB.fill(self.color.rgb())\n\t        self.current_imageB.setAlphaChannel(alpha)\n\t        self.update()      \n\n\t    def reset(self,x):\n\t        self.middleMouse = 1\n\t        self.bMouseDown = True\n\t        self.guiSelection = 0\n\t        self.initialPoint = (self.center\[0], self.center\[1])\n\t        self.lastPoint = (self.center\[0], self.center\[1]) \n\t        self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t        self.guiSelection = 1\n\t        self.initialPoint = (self.center\[0], self.center\[1])\n\t        self.lastPoint = (self.center\[0], self.center\[1]) \n\t        self.alterColor(self.lastPoint\[0], self.lastPoint\[1]-10)\n\t        self.lastPoint = self.currentPoint\n\t        self.setColor(self.hue, self.sat, self.luma)\n\t        self.setUIColor(self.hue,self.sat,self.luma)\n\t        self.bMouseDown = False\n\t        if not self.ColorKnob == \"None\":\n\t\t\t\ttry:\n\t\t\t\t\tself.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),1.0)\n\t\t\t\t\tself.ColorKnob.setValue(\[float(self.color.redF()),float(self.color.greenF()),float(self.color.blueF()),float(self.luma*2)/255])\n\t\t\t\texcept: \n\t\t\t\t\tprint \"Error trying to send values to color control. Make sure all layouts are set to 4 Colors and not 1\"\n\n\t        \n\t    def getDist(self, (x1, y1), (x2, y2)):\n\t        return math.sqrt((x2-x1)**2 + (y2-y1)**2)\n\t        \n\t    def paintEvent(self, evt):\n\t        painter = QtGui.QPainter(self)\n\t        painter.setRenderHint(QtGui.QPainter.Antialiasing)\n\t        pen = QtGui.QPen()\n\t        if not self.ColorKnob == \"None\":\n\t\t\t\ttry:\n\t\t\t\t\tif self.setstate > 0:\n\t\t\t\t\t\tself.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),1.0)\n\t\t\t\t\t\tself.ColorKnob.setValue(\[float(self.color.redF()),float(self.color.greenF()),float(self.color.blueF()),float(self.luma*2)/255])\n\t\t\t\t\tif self.setstate > 1:\n\t\t\t\t\t\tself.setstate = 0\n\n\t\t\t\texcept: \n\t\t\t\t\tprint \"Error trying to send values to color control. Make sure all layouts are set to 4 Colors and not 1\"\n\t        self.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),min((self.luma/255.0)*2.0,1.0))\n\t        brush = QtGui.QBrush(QtGui.QColor(self.color.rgb())) #Color of the elipse\n\t        pen.setColor(QtGui.QColor(20,20,20)) #Outline Color\n\t        pen.setWidth(2) #Outline Width\n\t        painter.setPen(pen)\n\t        \n\t        painter.drawImage(0,0,self.image)\n\t        #painter.drawImage(0,0,self.current_image)\n\t        #painter.drawImage(0,0,self.current_imageB)\n\t        r = self.dim/2 \n\t        r2 = r + self.offset\n\t        center = QtCore.QPoint(r2+2,r2+2) \n\t        center = QtCore.QPointF(self.center\[0],self.center\[1] )\n\t        \n\t        painter.drawEllipse(center, r, r ) #DRAW THE OUTER BLACK CIRCLE\n\n\n\t   \n\t        #LUMINANCE ARC\n\t        pen.setWidth(3) #Outline Width\n\t        pen.setColor(QtGui.QColor(150,150,150)) #Outline Color\n\t        gradient = QtGui.QConicalGradient()\n\t        gradient.setCenter(center)\n\t        gradient.setAngle(-90)\n\t        gradient.setColorAt(1, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.497, QtGui.QColor(170, 170, 170))\n\t        gradient.setColorAt(0.498, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.5, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.502, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.503, QtGui.QColor(170, 170, 170))\n\t        gradient.setColorAt(0, QtGui.QColor(70, 70, 70))\n\t        pen.setBrush(gradient)\n\n\t        painter.setPen(pen)    \n\t        rectangle = QtCore.QRectF(self.center\[0]-((self.dim*1.1)/2), self.center\[1]-((self.dim*1.1)/2), self.dim*1.1, self.dim*1.1)     \n\t        startAngle = -90*16\n\n\t        spanAngle = (self.value_angle)*16\n\t        painter.drawArc(rectangle, startAngle, spanAngle)\n\n\n\t        pen.setWidth(1) #Outline Width\n\t        pen.setColor(QtGui.QColor(20,20,20)) #Outline Color\n\t        painter.setPen(pen)\n\t        #painter.drawEllipse(center, r-8, r-8) #DRAW THE INNER BLACK CIRCLE\n\n\t        pen.setColor(QtGui.QColor(200,200,200)) #Outline Color\n\t        painter.setPen(pen)\n\t        #Middle Crosshair\n\t        painter.drawLine((self.master_radius)+4,(self.master_radius),(self.master_radius)-4,(self.master_radius))\n\t        painter.drawLine((self.master_radius),(self.master_radius)+4,(self.master_radius),(self.master_radius)-4)\n\n\t        pen.setWidth(6) #Outline Width\n\t        painter.setPen(pen)\n\t        (x1,y1,x2,y2) = self.points\n\t        (x1,y1,x2,y2) = self.points2\n\n\n\t        #Draw the GuideLines\n\t        pen.setWidth(1.99)\n\t        pen.setColor(QtGui.QColor(220,220,220))\n\t        pen.setStyle(QtCore.Qt.PenStyle.DashLine)\n\t        painter.setPen(pen)\n\t        (hpx, hpy) =  self.huepoint\n\t        d = self.getDist((hpx,hpy),self.center)\n\t        if self.bMouseDown == False: #Hide the guidelines when the mouse is not clicked\n\t            pass\n\t        else:\n\t            (x1,y1,x2,y2) = self.getRadialLinePoints(0, self.master_radius, ((self.hue/255)*360)+15,0.80) \n\t            painter.drawLine(x1,y1,x2,y2)\n\t            if d > 46: #If the radial is in the bright area, then display a dark version\n\t                pen.setColor(QtGui.QColor(20,20,20))  \n\t                painter.setPen(pen)\n\t            if d != 0:\n\t                painter.drawEllipse(QtCore.QPointF(self.master_radius, self.master_radius), d, d)\n\n\n\t        #Draw Hue Dot\n\t        pen.setWidth(1)\n\t        pen.setStyle(QtCore.Qt.PenStyle.SolidLine)\n\t        if self.luma > 90:\n\t            pen.setColor(QtGui.QColor(0,0,0))\n\t        else:\n\t            pen.setColor(QtGui.QColor(220,220,220))\n\t        painter.setPen(pen)\n\t        painter.setBrush(brush)\n\t        painter.drawEllipse(QtCore.QPointF(hpx, hpy), 5, 5)\n\n\n\n\t    def setUIColor(self,h,s,v):\n\t        (x1,y1,x2,y2) = self.getRadialLinePoints((self.dim / 2.0), self.master_radius,  ((self.hue/255)*360)+15,(s/255.0))\n\t        self.huepoint = (x2,y2)\n\t        self.lastPoint = (x2,y2)\n\t        self.currentPoint = (x2,y2)\n\t        #Saturation\n\t        self.value_angleSat = (1.0-((s/255.0) * 90.0)) + 135.0       \n\n\t        #Luminance\n\t        self.value_angle = ((v/255.0) * 360.0) \n\n\n\t        \n\t    def alterColor(self, x, y):\t\n\t        d = 2.0 * self.getDist((x,y),self.center) / self.dim\n\t        if self.guiSelection == 0:\n\t            if self.getDist((x,y),self.center) >= (self.dim/2.0):\n\t                Percent = self.getDist((x,y),self.center) / (self.dim/2.0)\n\t                prex = (((x-self.center\[0]) / Percent) * 1)+self.center\[0]\n\t                prey = (((y-self.center\[1]) / Percent) * 1)+self.center\[1]\n\t                self.initialPoint = (self.initialPoint\[0]-(prex-x), self.initialPoint\[1]-(prey-y))\n\t                x = prex\n\t                y = prey\n\t            hue = self.getHue(x, y)\n\n\t            self.value_angleSat = (1.0-((self.getDist((x,y),self.center) / (self.dim/2.0)) * 90.0)) + 135.0  \n\t            self.hue = (hue/360)*255\n\t            self.sat = min(d*255.0,255.0)\n\t            self.huepoint = (x,y)\n\t            self.setColor(hue,min(d*255.0,255.0),self.luma)\n\t        \n\t        elif self.guiSelection == 1:\n\t            self.value_angle = self.getRot(x, y)\n\t            lum = self.getLum(x, y)\n\t            v = (lum/360.0)*255.0\n\t            self.setColor(self.color.hueF(), self.color.saturationF(), v)\n\t            self.luma = v\n\n\n\t        else:\n\t            pass\n\n\n\t    def mousePressEvent(self, evt):\n\t    \tself.setstate = 1\n\t        self.myTimer.start()\n\t\t\t\n\t        d = 2 * self.getDist((evt.x(), evt.y()),self.center) / self.dim\n\t        if evt.button() == QtCore.Qt.MouseButton.MiddleButton:\n\t            self.middleMouse = 1\n\t        else:\n\t            self.middleMouse = 0\n\t        if d <= 1: \n\t            self.guiSelection = 0\n\t            if self.middleMouse == 1:\n\t                self.initialPoint = (self.center\[0], self.center\[1])\n\t                self.lastPoint = (self.center\[0], self.center\[1]) \n\t                self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t            else:\n\t                self.initialPoint = (evt.x(), evt.y())\n\t                self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t        else:\n\t            d = self.getDist((evt.x(), evt.y()),self.center) / self.master_radius\n\t            if d <= 1:\n\t                self.guiSelection = 1\n\t                if self.middleMouse == 1:\n\t                    self.initialPoint = (self.center\[0], self.center\[1])\n\t                    self.lastPoint = (self.center\[0], self.center\[1]) \n\t                    self.alterColor(self.lastPoint\[0], self.lastPoint\[1]-10)\n\t                else:\n\t                    self.alterColor(evt.x(), evt.y())\n\t            else:\n\t                self.guiSelection = 3\n\t        self.bMouseDown = True\n\n\n\n\n\t    def mouseMoveEvent(self, evt):\n\t    \tself.setstate = 1\n\t    \tnMilliseconds = self.myTimer.elapsed()\n\t    \tif nMilliseconds < 1:\n\t    \t\tpass\n\t    \telse:\n\n\t\t        modifiers = QtGui.QApplication.keyboardModifiers()\n\t\t        self.shiftDown = False\n\t\t        self.ctrlDown = False\n\t\t        self.altDown = False\n\t\t        self.colorWheelSensitivity = 0.1\n\n\t\t        if modifiers == QtCore.Qt.ShiftModifier:\n\t\t            self.shiftDown = True\n\t\t        if modifiers == QtCore.Qt.ControlModifier:\n\t\t            self.ctrlDown = True\n\t\t        if modifiers == QtCore.Qt.AltModifier:\n\t\t            self.altDown = True\n\t\t            self.colorWheelSensitivity = 1\n\t\t        if modifiers == (QtCore.Qt.ControlModifier | QtCore.Qt.ShiftModifier):\n\t\t            self.ctrlDown = True\n\t\t            self.shiftDown = True\n\n\t\t        if self.bMouseDown and self.middleMouse == 0:\n\t\t            if self.guiSelection == 1 or self.guiSelection == 2:\n\t\t                self.alterColor(evt.x(), evt.y())\n\t\t            else:\n\n\t\t                x = (((evt.x()-self.initialPoint\[0]) * self.colorWheelSensitivity))+self.lastPoint\[0]\n\t\t                y = (((evt.y()-self.initialPoint\[1]) * self.colorWheelSensitivity))+self.lastPoint\[1]\n\t\t                self.alterColor(x, y)\n\t\t                self.currentPoint = (x, y) \n\t\t        self.myTimer.restart()\n\t        \n\n\t    def mouseReleaseEvent(self, evt):\n\t    \tself.setstate = 2\n\t        self.lastPoint = self.currentPoint\n\t        self.setColor(self.hue, self.sat, self.luma)\n\t        self.setUIColor(self.hue,self.sat,self.luma)\n\t        self.bMouseDown = False\n\nclass Example(QtGui.QWidget):\n\tdef __init__(self, parent=None,myNode=\"none\"):\n\t\tQtGui.QWidget.__init__(self, None)\n\t\t#self.setGeometry(900, 900, 800, 600)\n\t\t#self.setWindowTitle('ColorBars')\n\t\tself.baseNode = myNode\n\t\tself.palette = QtGui.QPalette()\n\t\tself.LiftLabel = QtGui.QLabel(\"<b>Lift</b>\")\n\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\tself.LiftLabel.setPalette(self.palette)\n\t\tself.LiftLabel.mouseReleaseEvent = self.showText1\n\t\tself.Lift = ColorWheelWidget(None, 138, 10,myNode.knob(\"Lift\"))\n\n\n\t\tself.GammaLabel = QtGui.QLabel(\"<b>Gamma</b>\")\n\t\tself.GammaLabel.setPalette(self.palette)\n\t\tself.GammaLabel.mouseReleaseEvent = self.showText2\n\t\tself.Gamma = ColorWheelWidget(None, 138, 10,myNode.knob(\"Gamma\"))\n\n\t\tself.GainLabel = QtGui.QLabel(\"<b>Gain</b>\")\n\t\tself.GainLabel.setPalette(self.palette)\n\t\tself.GainLabel.mouseReleaseEvent = self.showText3\n\t\tself.Gain = ColorWheelWidget(None, 138, 10,myNode.knob(\"Gain\"))\n\n\t\tlayout = QtGui.QGridLayout()\n\t\tlayout.addWidget(self.LiftLabel,0,0)\n\t\tlayout.addWidget(self.GammaLabel,0,1)\n\t\tlayout.addWidget(self.GainLabel,0,2)\n\t\tlayout.addWidget(self.Lift,1,0)\n\t\tlayout.addWidget(self.Gamma,1,1)\n\t\tlayout.addWidget(self.Gain,1,2)\n\t\tlayout.setRowStretch(1,1)\n\t\tself.setLayout(layout)\n\t\t#self.show()\n\tdef showText1(self, event):\n\t\tmyNode = self.baseNode.knob(\"LiftEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.LiftLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.LiftLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\tdef showText2(self, event):\n\t\tmyNode = self.baseNode.knob(\"GammaEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.GammaLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.GammaLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\tdef showText3(self, event):\n\t\tmyNode = self.baseNode.knob(\"GainEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.GainLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.GainLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\nclass ColorWheelKnob_LGG:\n\tdef __init__( self ):\n\t\tself.instance = 0\n\t\treturn None\n\n\tdef makeUI( self ):\n\t\tself.instance = Example(None,nuke.thisNode())\n\t\treturn self.instance\n\ndefined = 1" +STARTLINE}
 addUserKnob {26 Info_Basics l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {41 blackpoint T Grade1.blackpoint}
 addUserKnob {41 whitepoint T Grade1.whitepoint}
 addUserKnob {41 add l offset T Grade1.add}
 addUserKnob {41 saturation T OCIOCDLTransform1.saturation}
 addUserKnob {26 info_liftgammagain l "<b><font color=#70EE70>3-Way LGG</font><b>"}
 addUserKnob {52 LiftGammaGain l "" t "Hotkeys:\nClick MiddleMouse = Reset\nALT+Drag = Absolute Offset" +STARTLINE T ColorWheelKnob_LGG() +STARTLINE}
 addUserKnob {41 out_colorspace l GradingSpace T OCIOColorSpace1.out_colorspace}
 addUserKnob {22 reset l Reset -STARTLINE T "nuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Lift.reset(1)\nnuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Gamma.reset(1)\nnuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Gain.reset(1)"}
 addUserKnob {20 out l "" +STARTLINE n 1}
 out 0
 addUserKnob {19 Lift R 0 2}
 Lift {1 1 1 1}
 addUserKnob {6 Lift_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 LiftEnabled l "" -STARTLINE}
 LiftEnabled true
 addUserKnob {19 Gamma R 0 2}
 Gamma {1 1 1 1}
 addUserKnob {6 Gamma_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 GammaEnabled l "" -STARTLINE}
 GammaEnabled true
 addUserKnob {19 Gain R 0 2}
 Gain {1 1 1 1}
 addUserKnob {6 Gain_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 GainEnabled l "" -STARTLINE}
 GainEnabled true
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 HTR l "" t "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFixed" +STARTLINE}
 addUserKnob {26 Infort l "" +STARTLINE T "Thanks for using LUE.\nI am sorry for this tab but nuke does not support UI scaling for custom python UI elements.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBut this fixes it."}
}
 Input {
  inputs 0
  name Input
  xpos 509
  ypos -2122
 }
 Grade {
  name Grade2
  xpos 509
  ypos -1840
 }
 OCIOCDLTransform {
  working_space linear
  name OCIOCDLTransform1
  xpos 509
  ypos -1806
 }
 OCIOColorSpace {
  in_colorspace linear
  out_colorspace Gamma2.2
  name OCIOColorSpace1
  xpos 509
  ypos -1758
 }
 Grade {
  black {{parent.LiftEnabled?((parent.Lift.r-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} {parent.LiftEnabled?((parent.Lift.g-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} {parent.LiftEnabled?((parent.Lift.b-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} 1}
  white {{parent.GainEnabled?((parent.Gain.r-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {parent.GainEnabled?((parent.Gain.g-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {parent.GainEnabled?((parent.Gain.b-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {curve}}
  gamma {{parent.GammaEnabled?((parent.Gamma.r-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {parent.GammaEnabled?((parent.Gamma.g-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {parent.GammaEnabled?((parent.Gamma.b-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {curve}}
  black_clamp false
  name Grade1
  xpos 509
  ypos -1685
 }
 OCIOColorSpace {
  in_colorspace {{parent.OCIOColorSpace1.out_colorspace}}
  out_colorspace linear
  name OCIOColorSpace2
  selected true
  xpos 510
  ypos -1610
 }
 Output {
  name Output1
  xpos 509
  ypos 437
 }
end_group