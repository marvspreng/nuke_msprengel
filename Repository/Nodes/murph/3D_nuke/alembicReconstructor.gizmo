#! C:/Program Files/Nuke8.0v6/nuke-8.0.v6.dll -nx
version 8.0 v6
Gizmo {
 tile_color 0xe89900ff
 note_font Verdana
 addUserKnob {20 User l "alembic reconstructor"}
 addUserKnob {22 reconstructionA l "reconstruction with matrix expression" T "def dupFunc():\n\n    rootNode = nuke.thisNode().input(0)\n    nuke.thisNode().setInput(0, None)\n    nuke.thisNode()\['selected'].setValue( False )\n    contents = rootNode.writeKnobs()\n    sceneView = rootNode\['scene_view']\n    allItems = sceneView.getImportedItems()\n    num = len(allItems)\n    rootPosX = rootNode\['xpos'].getValue()\n    rootPosY = rootNode\['ypos'].getValue()\n    gridX = nuke.toNode('preferences')\['GridWidth'].value()\n    gridY = nuke.toNode('preferences')\['GridHeight'].value()\n    \n    if num >= 2:\n        for i in range(num - 1):\n            nuke.root().begin()\n\n            dup = nuke.createNode(rootNode.Class())\n            dup.hideControlPanel()\n            dup\['selected'].setValue( False )\n            dup\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            dup\['ypos'].setValue(rootPosY)\n            dup.readKnobs(contents)\n            abcCont = \[]\n            abcCont.append(allItems\[i+1])\n            dup\['scene_view'].setImportedItems(abcCont)\n            dup\['label'].setValue(abcCont\[0].split(\"/\")\[-3])\n\n            axsUpper = nuke.createNode(\"Axis\")\n            axsUpper.hideControlPanel()\n            axsUpper\['selected'].setValue( False )\n            axsUpper\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2) + gridX)\n            axsUpper\['ypos'].setValue(rootPosY)\n            axsUpper\['label'].setValue(dup.name() + \" Transform Cancel\")\n            axsUpper\['useMatrix'].setValue( True )\n            for j in range(0,16):\n                axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (dup.name(), j),j)\n\n            axsLower = nuke.createNode(\"Axis\")\n            axsLower.hideControlPanel()\n            axsLower\['selected'].setValue( False )\n            axsLower\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2) + gridX)\n            axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n            axsLower\['label'].setValue(dup.name() + \" Transform\")\n            axsLower\['useMatrix'].setValue( True )\n            for k in range(0,16):\n                axsLower\['matrix'].setExpression(\"\[python \{matGetter(nuke.frame(), '%s')\[%d]\}]\" % (dup.name(), k),k)\n\n\n            traGUpper = nuke.createNode(\"TransformGeo\")\n            traGUpper.hideControlPanel()\n            traGUpper\['selected'].setValue( False )\n            traGUpper\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n            traGUpper.setInput(0, dup)\n            traGUpper.setInput(1, axsUpper)\n\n            traGLower = nuke.createNode(\"TransformGeo\")\n            traGLower.hideControlPanel()\n            traGLower\['selected'].setValue( False )\n            traGLower\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n            traGLower.setInput(0, traGUpper)\n            traGLower.setInput(1, axsLower)\n\n        abcCont = \[]\n        abcCont.append(allItems\[0])\n        rootNode\['scene_view'].setImportedItems(abcCont)\n        rootNode\['label'].setValue(abcCont\[0].split(\"/\")\[-3])\n\n        axsUpper = nuke.createNode(\"Axis\")\n        axsUpper.hideControlPanel()\n        axsUpper\['selected'].setValue( False )\n        axsUpper\['xpos'].setValue(rootPosX + gridX)\n        axsUpper\['ypos'].setValue(rootPosY)\n        axsUpper\['label'].setValue(rootNode.name() + \" Transform Cancel\")\n        axsUpper\['useMatrix'].setValue( True )\n        for l in range(0,16):\n            axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), l),l)\n\n        axsLower = nuke.createNode(\"Axis\")\n        axsLower.hideControlPanel()\n        axsLower\['selected'].setValue( False )\n        axsLower\['xpos'].setValue(rootPosX + gridX)\n        axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n        axsLower\['label'].setValue(rootNode.name() + \" Transform\")\n        axsLower\['useMatrix'].setValue( True )\n        for m in range(0,16):\n            axsLower\['matrix'].setExpression(\"\[python \{matGetter(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), m),m)\n        \n        traGUpper = nuke.createNode(\"TransformGeo\")\n        traGUpper.hideControlPanel()\n        traGUpper\['selected'].setValue( False )\n        traGUpper\['xpos'].setValue(rootPosX)\n        traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n        traGUpper.setInput(0, rootNode)\n        traGUpper.setInput(1, axsUpper)\n\n        traGLower = nuke.createNode(\"TransformGeo\")\n        traGLower.hideControlPanel()\n        traGLower\['selected'].setValue( False )\n        traGLower\['xpos'].setValue(rootPosX)\n        traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n        traGLower.setInput(0, traGUpper)\n        traGLower.setInput(1, axsLower)\n\n\n    else:\n        nuke.root().begin()\n        axsUpper = nuke.createNode(\"Axis\")\n        axsUpper.hideControlPanel()\n        axsUpper\['selected'].setValue( False )\n        axsUpper\['xpos'].setValue(rootPosX + gridX)\n        axsUpper\['ypos'].setValue(rootPosY)\n        axsUpper\['label'].setValue(rootNode.name() + \" Transform Cancel\")\n        axsUpper\['useMatrix'].setValue( True )\n        for n in range(0,16):\n            axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), n),n)\n\n        axsLower = nuke.createNode(\"Axis\")\n        axsLower.hideControlPanel()\n        axsLower\['selected'].setValue( False )\n        axsLower\['xpos'].setValue(rootPosX + gridX)\n        axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n        axsLower\['label'].setValue(rootNode.name() + \" Transform\")\n        axsLower\['useMatrix'].setValue( True )\n        for o in range(0,16):\n            axsLower\['matrix'].setExpression(\"\[python \{matGetter(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), o),o)\n        \n        traGUpper = nuke.createNode(\"TransformGeo\")\n        traGUpper.hideControlPanel()\n        traGUpper\['selected'].setValue( False )\n        traGUpper\['xpos'].setValue(rootPosX)\n        traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n        traGUpper.setInput(0, rootNode)\n        traGUpper.setInput(1, axsUpper)\n\n        traGLower = nuke.createNode(\"TransformGeo\")\n        traGLower.hideControlPanel()\n        traGLower\['selected'].setValue( False )\n        traGLower\['xpos'].setValue(rootPosX)\n        traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n        traGLower.setInput(0, traGUpper)\n        traGLower.setInput(1, axsLower)\n\ndef checkSomething():\n    rootNode = nuke.thisNode().input(0)\n    if rootNode.Class() != \"ReadGeo2\":\n        nuke.message('This is not ReadGeo! \\n Please connect ReadGeo with alembic.')\n    elif rootNode\['file'].value().split(\".\")\[-1] != \"abc\":\n        nuke.message('This is not Alembic file!')\n    else:\n        pass\n\n    try:\n        import alembic\n    except:\n        nuke.message('pyAlembic does not work!')\n\ncheckSomething()\ndupFunc()\n\n" +STARTLINE}
 addUserKnob {22 reconstructionB l "reconstruction with SRT expression " -STARTLINE T "def dupFuncB():\n\n    rootNode = nuke.thisNode().input(0)\n    nuke.thisNode().setInput(0, None)\n    nuke.thisNode()\['selected'].setValue( False )\n    contents = rootNode.writeKnobs()\n    sceneView = rootNode\['scene_view']\n    allItems = sceneView.getImportedItems()\n    num = len(allItems)\n    rootPosX = rootNode\['xpos'].getValue()\n    rootPosY = rootNode\['ypos'].getValue()\n    gridX = nuke.toNode('preferences')\['GridWidth'].value()\n    gridY = nuke.toNode('preferences')\['GridHeight'].value()\n    \n    if num >= 2:\n        for i in range(num - 1):\n            nuke.root().begin()\n\n            dup = nuke.createNode(rootNode.Class())\n            dup.hideControlPanel()\n            dup\['selected'].setValue( False )\n            dup\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            dup\['ypos'].setValue(rootPosY)\n            dup.readKnobs(contents)\n            abcCont = \[]\n            abcCont.append(allItems\[i+1])\n            dup\['scene_view'].setImportedItems(abcCont)\n            dup\['label'].setValue(abcCont\[0].split(\"/\")\[-3])\n\n            axsUpper = nuke.createNode(\"Axis\")\n            axsUpper.hideControlPanel()\n            axsUpper\['selected'].setValue( False )\n            axsUpper\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2) + gridX)\n            axsUpper\['ypos'].setValue(rootPosY)\n            axsUpper\['label'].setValue(dup.name() + \" Transform Cancel\")\n            axsUpper\['useMatrix'].setValue( True )\n            for j in range(0,16):\n                axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (dup.name(), j),j)\n\n            axsLower = nuke.createNode(\"Axis\")\n            axsLower.hideControlPanel()\n            axsLower\['selected'].setValue( False )\n            axsLower\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2) + gridX)\n            axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n            axsLower\['label'].setValue(dup.name() + \" Transform\")\n            axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[0]\}]\" % (dup.name()),0)\n            axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[1]\}]\" % (dup.name()),1)\n            axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[2]\}]\" % (dup.name()),2)\n            axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[3]\}]\" % (dup.name()),0)\n            axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[4]\}]\" % (dup.name()),1)\n            axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[5]\}]\" % (dup.name()),2)\n            axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[6]\}]\" % (dup.name()),0)\n            axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[7]\}]\" % (dup.name()),1)\n            axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[8]\}]\" % (dup.name()),2)\n\n\n            traGUpper = nuke.createNode(\"TransformGeo\")\n            traGUpper.hideControlPanel()\n            traGUpper\['selected'].setValue( False )\n            traGUpper\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n            traGUpper.setInput(0, dup)\n            traGUpper.setInput(1, axsUpper)\n\n            traGLower = nuke.createNode(\"TransformGeo\")\n            traGLower.hideControlPanel()\n            traGLower\['selected'].setValue( False )\n            traGLower\['xpos'].setValue(rootPosX + ((i+1) * gridX * 2))\n            traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n            traGLower.setInput(0, traGUpper)\n            traGLower.setInput(1, axsLower)\n\n        abcCont = \[]\n        abcCont.append(allItems\[0])\n        rootNode\['scene_view'].setImportedItems(abcCont)\n        rootNode\['label'].setValue(abcCont\[0].split(\"/\")\[-3])\n\n        axsUpper = nuke.createNode(\"Axis\")\n        axsUpper.hideControlPanel()\n        axsUpper\['selected'].setValue( False )\n        axsUpper\['xpos'].setValue(rootPosX + gridX)\n        axsUpper\['ypos'].setValue(rootPosY)\n        axsUpper\['label'].setValue(rootNode.name() + \" Transform Cancel\")\n        axsUpper\['useMatrix'].setValue( True )\n        for l in range(0,16):\n            axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), l),l)\n\n        axsLower = nuke.createNode(\"Axis\")\n        axsLower.hideControlPanel()\n        axsLower\['selected'].setValue( False )\n        axsLower\['xpos'].setValue(rootPosX + gridX)\n        axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n        axsLower\['label'].setValue(rootNode.name() + \" Transform\")\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[0]\}]\" % (rootNode.name()),0)\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[1]\}]\" % (rootNode.name()),1)\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[2]\}]\" % (rootNode.name()),2)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[3]\}]\" % (rootNode.name()),0)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[4]\}]\" % (rootNode.name()),1)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[5]\}]\" % (rootNode.name()),2)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[6]\}]\" % (rootNode.name()),0)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[7]\}]\" % (rootNode.name()),1)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[8]\}]\" % (rootNode.name()),2)\n        \n        traGUpper = nuke.createNode(\"TransformGeo\")\n        traGUpper.hideControlPanel()\n        traGUpper\['selected'].setValue( False )\n        traGUpper\['xpos'].setValue(rootPosX)\n        traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n        traGUpper.setInput(0, rootNode)\n        traGUpper.setInput(1, axsUpper)\n\n        traGLower = nuke.createNode(\"TransformGeo\")\n        traGLower.hideControlPanel()\n        traGLower\['selected'].setValue( False )\n        traGLower\['xpos'].setValue(rootPosX)\n        traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n        traGLower.setInput(0, traGUpper)\n        traGLower.setInput(1, axsLower)\n\n\n    elif num == 1:\n\n        nuke.root().begin()\n        axsUpper = nuke.createNode(\"Axis\")\n        axsUpper.hideControlPanel()\n        axsUpper\['selected'].setValue( False )\n        axsUpper\['xpos'].setValue(rootPosX + gridX)\n        axsUpper\['ypos'].setValue(rootPosY)\n        axsUpper\['label'].setValue(rootNode.name() + \" Transform Cancel\")\n        axsUpper\['useMatrix'].setValue( True )\n        for n in range(0,16):\n            axsUpper\['matrix'].setExpression(\"\[python \{inV(nuke.frame(), '%s')\[%d]\}]\" % (rootNode.name(), n),n)\n\n        axsLower = nuke.createNode(\"Axis\")\n        axsLower.hideControlPanel()\n        axsLower\['selected'].setValue( False )\n        axsLower\['xpos'].setValue(rootPosX + gridX)\n        axsLower\['ypos'].setValue(rootPosY + (gridY * 4))\n        axsLower\['label'].setValue(rootNode.name() + \" Transform\")\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[0]\}]\" % (rootNode.name()),0)\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[1]\}]\" % (rootNode.name()),1)\n        axsLower\['translate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[2]\}]\" % (rootNode.name()),2)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[3]\}]\" % (rootNode.name()),0)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[4]\}]\" % (rootNode.name()),1)\n        axsLower\['rotate'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[5]\}]\" % (rootNode.name()),2)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[6]\}]\" % (rootNode.name()),0)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[7]\}]\" % (rootNode.name()),1)\n        axsLower\['scaling'].setExpression(\"\[python \{convT(nuke.frame(), '%s')\[8]\}]\" % (rootNode.name()),2)\n        \n        traGUpper = nuke.createNode(\"TransformGeo\")\n        traGUpper.hideControlPanel()\n        traGUpper\['selected'].setValue( False )\n        traGUpper\['xpos'].setValue(rootPosX)\n        traGUpper\['ypos'].setValue(rootPosY + (gridY * 4))\n        traGUpper.setInput(0, rootNode)\n        traGUpper.setInput(1, axsUpper)\n\n        traGLower = nuke.createNode(\"TransformGeo\")\n        traGLower.hideControlPanel()\n        traGLower\['selected'].setValue( False )\n        traGLower\['xpos'].setValue(rootPosX)\n        traGLower\['ypos'].setValue(rootPosY + (gridY * 8))\n        traGLower.setInput(0, traGUpper)\n        traGLower.setInput(1, axsLower)\n\n    else:\n        print \"this is not alembic!\"\n\n\ndef checkSomething():\n    rootNode = nuke.thisNode().input(0)\n    if rootNode.Class() != \"ReadGeo2\":\n        nuke.message('This is not ReadGeo! \\n Please connect ReadGeo with alembic.')\n    elif rootNode\['file'].value().split(\".\")\[-1] != \"abc\":\n        nuke.message('This is not Alembic file!')\n    else:\n        pass\n\n    try:\n        import alembic\n    except:\n        nuke.message('pyAlembic does not work!')\n\ncheckSomething()\ndupFuncB()\n\n"}
 addUserKnob {26 blank l "" +STARTLINE}
 addUserKnob {26 note l "" +STARTLINE T "After setting expression, I highly recommend  baking keyframes.\n"}
 addUserKnob {20 help_abcRecon l help}
 addUserKnob {26 ""}
 addUserKnob {26 coment_abcRecon l "" +STARTLINE T "HOW TO USE\n 1.Please connect this input to ReadGeo which has the file path for alembic. \n 2.Please press either of the buttons in \"alembic reconstructor\" tab.\n\n\nNOTICE:\n Because alembic can have so many nodes in itself, \n it might takes a long time to execute this in case it has so many nodes.\n\n If you open \"Curve Editor\", you feel it's slow when you press button.\n\n After setting expression, I highly recommend  baking keyframes.\n Especially before you submit to kinds of network rendering,\n you have to bake them, otherwise you will get some error.  \n\n This gizmo needs pyAlembic. Please install it in your Environment.\n http://docs.alembic.io/python/index.html\n\nAlembic -- Â© Copyright, Sony Pictures Imageworks Inc. and Industrial Light & Magic, a division of Lucasfilm Entertainment Company Ltd..\n"}
 addUserKnob {26 ""}
 addUserKnob {26 me_abcRecon l "" +STARTLINE T "by masahiro teraoka, 2014"}
 addUserKnob {20 funcTab l INVISIBLE +INVISIBLE}
 addUserKnob {3 function l INVISIBLE +INVISIBLE}
 function {{"\[python -execlocal global\\ matGetter\\nglobal\\ inV\\nglobal\\ convT\\n\\n\\n\\ndef\\ matGetter(f,\\ RGeoName):\\n\\ \\ \\ \\ import\\ imath\\n\\ \\ \\ \\ import\\ alembic\\n\\ \\ \\ \\ import\\ math\\n\\n\\ \\ \\ \\ def\\ tagetter(obj,\\ name):\\n\\n\\ \\ \\ \\ \\ \\ \\ \\ def\\ visitObject(obj,\\ name):\\ \\ \\ \\ \\ \\ \\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ if\\ obj.getFullName()\\ ==\\ search:\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ target.append(obj)\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ for\\ childObject\\ in\\ obj.children:\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ visitObject(childObject,\\ name)\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ return\\ target\\n\\n\\ \\ \\ \\ \\ \\ \\ \\ target\\ =\\ \\\[\\]\\n\\ \\ \\ \\ \\ \\ \\ \\ visitObject(obj,\\ name)\\n\\ \\ \\ \\ \\ \\ \\ \\ obj\\ =\\ target\\n\\ \\ \\ \\ \\ \\ \\ \\ return\\ obj\\n\\n\\ \\ \\ \\ \\n\\ \\ \\ \\ RGeo\\ =\\ nuke.toNode(RGeoName)\\n\\ \\ \\ \\ arch\\ =\\ alembic.Abc.IArchive(RGeo\\\['file'\\].value())\\n\\ \\ \\ \\ search\\ \\ =\\ \\\"\\\"\\n\\ \\ \\ \\ for\\ i\\ in\\ range(len(RGeo\\\['scene_view'\\].getImportedItems()\\\[0\\].split(\\\"/\\\"))\\ -2):\\n\\ \\ \\ \\ \\ \\ \\ \\ search\\ =\\ \\ search\\ \\ +\\ \\\"/\\\"\\ +\\ RGeo\\\['scene_view'\\].getImportedItems()\\\[0\\].split(\\\"/\\\")\\\[i+2\\]\\n\\ \\ \\ \\ \\n\\ \\ \\ \\ obj\\ =\\ tagetter(arch.getTop(),\\ search)\\\[0\\]\\n\\n\\ \\ \\ \\ kWrapExisting\\ =\\ alembic.Abc.WrapExistingFlag.kWrapExisting\\n\\n\\ \\ \\ \\ def\\ accumXform(xf,\\ obj,\\ f):\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ imath\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ alembic\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ math\\n\\ \\ \\ \\ \\ \\ \\ \\ if\\ alembic.AbcGeom.IXform.matches(obj.getHeader()):\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ x\\ =\\ alembic.AbcGeom.IXform(obj,\\ kWrapExisting)\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ xs\\ =\\ x.getSchema().getValue(\\ alembic.Abc.ISampleSelector(f)\\ )\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ xf\\ *=\\ xs.getMatrix()\\n\\n\\ \\ \\ \\ def\\ getFinalMatrix(obj,\\ f):\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ imath\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ alembic\\n\\ \\ \\ \\ \\ \\ \\ \\ import\\ math\\n\\n\\ \\ \\ \\ \\ \\ \\ \\ xf\\ =\\ imath.M44d()\\n\\ \\ \\ \\ \\ \\ \\ \\ xf.makeIdentity()\\n\\ \\ \\ \\ \\ \\ \\ \\ f\\ =\\ f/24\\n\\ \\ \\ \\ \\ \\ \\ \\ parent\\ =\\ obj.getParent()\\n\\ \\ \\ \\ \\ \\ \\ \\ while\\ parent:\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ accumXform(xf,\\ parent,\\ f)\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ parent\\ =\\ parent.getParent()\\n\\ \\ \\ \\ \\ \\ \\ \\ return\\ xf\\n\\n\\ \\ \\ \\ xf\\ =\\ getFinalMatrix(obj,\\ f)\\n\\ \\ \\ \\ mN\\ =\\ nuke.math.Matrix4()\\n\\n\\ \\ \\ \\ for\\ i\\ in\\ range(4):\\n\\ \\ \\ \\ \\ \\ \\ \\ for\\ k\\ in\\ range(4):\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ mN\\\[k\\ +\\ (4\\ *\\ i)\\]\\ =\\ xf\\\[k\\]\\\[i\\]\\n\\ \\ \\ \\ return\\ mN\\n\\ndef\\ inV(f,\\ RGeoName):\\n\\ \\ \\ \\ import\\ math\\n\\ \\ \\ \\ mN\\ =\\ matGetter(f,\\ RGeoName)\\n\\ \\ \\ \\ invmN\\ =\\ \\ mN.inverse()\\n\\ \\ \\ \\ return\\ invmN\\n\\n\\ndef\\ convT(f,\\ RGeoName):\\n\\ \\ \\ \\ import\\ math\\n\\ \\ \\ \\ SRT\\ =\\ \\\[\\]\\n\\ \\ \\ \\ mN\\ =\\ matGetter(f,\\ RGeoName)\\n\\ \\ \\ \\ mN.transpose()\\n\\n\\ \\ \\ \\ mTranslate\\ =\\ nuke.math.Matrix4(mN)\\n\\ \\ \\ \\ mTranslate.translationOnly()\\n\\ \\ \\ \\ mRotate\\ =\\ nuke.math.Matrix4(mN)\\n\\ \\ \\ \\ mRotate.rotationOnly()\\n\\ \\ \\ \\ mScale\\ =\\ nuke.math.Matrix4(mN)\\n\\ \\ \\ \\ mScale.scaleOnly()\\n\\n\\ \\ \\ \\ translate\\ =\\ (mTranslate\\\[12\\],\\ mTranslate\\\[13\\],\\ mTranslate\\\[14\\])\\n\\ \\ \\ \\ rotateRad\\ =\\ mRotate.rotationsZXY()\\n\\ \\ \\ \\ rotate\\ =\\ (math.degrees(rotateRad\\\[0\\]),\\ math.degrees(rotateRad\\\[1\\]),\\ math.degrees(rotateRad\\\[2\\]))\\n\\ \\ \\ \\ scale\\ =\\ (mScale.xAxis().x,\\ mScale.yAxis().y,\\ mScale.zAxis().z)\\n\\ \\ \\ \\ SRT\\ =\\\[mTranslate\\\[12\\],\\ mTranslate\\\[13\\],\\ mTranslate\\\[14\\],\\ math.degrees(rotateRad\\\[0\\]),\\ math.degrees(rotateRad\\\[1\\]),math.degrees(rotateRad\\\[2\\]),\\ mScale.xAxis().x,\\ mScale.yAxis().y,\\ mScale.zAxis().z\\]\\n\\ \\ \\ \\ return\\ SRT\\n\\ \\ \\n\\ \\ \\nret\\ =\\ 0]" x93 0}}
}
 Input {
  inputs 0
  name Input1
  xpos -260
  ypos -9
 }
 Output {
  name Output1
  xpos -260
  ypos 279
 }
end_group
