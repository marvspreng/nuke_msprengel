#! /Applications/Nuke12.0v3/Nuke12.0v3.app/Contents/MacOS/libnuke-12.0.3.dylib -nx
version 12.0 v3
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="23" w="1920" h="1035" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1257" stretch="1"/>
            <splitter orientation="2">
                <split size="593"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="417"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/madshagbarth/Github/Nuke-Private/Tools/PointRender/ExampleScenes/Packaged/1.1/GnomeExploded.nk
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement OCIO
 OCIO_config aces_1.0.3
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT scene_linear
 monitorLut ACES/sRGB
 int8Lut matte_paint
 int16Lut texture_paint
 logLut compositing_log
 floatLut scene_linear
}
BackdropNode {
 inputs 0
 name BackdropNode17
 tile_color 0x8e8e3800
 label "Point Render Setup"
 note_font_size 42
 xpos -1440
 ypos -1702
 bdwidth 2367
 bdheight 2020
 z_order -1
}
BackdropNode {
 inputs 0
 name BackdropNode18
 tile_color 0x8e8e3800
 label "Post FX"
 note_font_size 42
 xpos -1462
 ypos 1033
 bdwidth 2389
 bdheight 2780
 z_order -1
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x8e388e00
 label Simulation
 note_font_size 42
 xpos -239
 ypos -1130
 bdwidth 454
 bdheight 172
}
BackdropNode {
 inputs 0
 name BackdropNode10
 tile_color 0x388e8e00
 label Reflection
 note_font_size 42
 xpos -1430
 ypos -91
 bdwidth 818
 bdheight 299
}
BackdropNode {
 inputs 0
 name BackdropNode11
 tile_color 0x388e8e00
 label "Main Render"
 note_font_size 42
 xpos -174
 ypos -90
 bdwidth 421
 bdheight 297
}
BackdropNode {
 inputs 0
 name BackdropNode12
 tile_color 0x388e8e00
 label BlastWave
 note_font_size 42
 xpos -976
 ypos 2278
 bdwidth 556
 bdheight 1016
}
BackdropNode {
 inputs 0
 name BackdropNode13
 tile_color 0x388e8eff
 label Flare
 note_font_size 42
 xpos -276
 ypos 2486
 bdwidth 474
 bdheight 178
}
BackdropNode {
 inputs 0
 name BackdropNode14
 tile_color 0x388e8e00
 label Distortion
 note_font_size 42
 xpos -276
 ypos 2928
 bdwidth 476
 bdheight 220
}
BackdropNode {
 inputs 0
 name BackdropNode15
 tile_color 0x388e8eff
 label "Extra contact light"
 note_font_size 42
 xpos -275
 ypos 2705
 bdwidth 475
 bdheight 183
}
BackdropNode {
 inputs 0
 name BackdropNode16
 tile_color 0x388e8e00
 label "Distortion Soften"
 note_font_size 42
 xpos -283
 ypos 3169
 bdwidth 479
 bdheight 128
}
BackdropNode {
 inputs 0
 name BackdropNode2
 tile_color 0xaaaaaa00
 label Background
 note_font_size 42
 xpos 610
 ypos 1380
 bdwidth 221
 bdheight 469
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x7171c600
 label "Faux Reflection"
 note_font_size 42
 xpos -916
 ypos 1643
 bdwidth 358
 bdheight 406
}
BackdropNode {
 inputs 0
 name BackdropNode4
 tile_color 0x8e388e00
 label Pre-Post
 note_font_size 42
 xpos -124
 ypos 1304
 bdwidth 205
 bdheight 182
}
BackdropNode {
 inputs 0
 name BackdropNode5
 tile_color 0x388e8e00
 label Post-Post
 note_font_size 42
 xpos -119
 ypos 3582
 bdwidth 212
 bdheight 172
}
BackdropNode {
 inputs 0
 name BackdropNode6
 tile_color 0x8e388e00
 label "Geo to Points"
 note_font_size 42
 xpos -239
 ypos -1314
 bdwidth 454
 bdheight 172
}
BackdropNode {
 inputs 0
 name BackdropNode7
 tile_color 0x8e388e00
 label Shading
 note_font_size 42
 xpos -313
 ypos -942
 bdwidth 534
 bdheight 305
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0x8e388e00
 label "Source Geo"
 note_font_size 42
 xpos -230
 ypos -1622
 bdwidth 454
 bdheight 172
}
BackdropNode {
 inputs 0
 name BackdropNode9
 tile_color 0x348e2eff
 note_font_size 42
 xpos 430
 ypos -92
 bdwidth 251
 bdheight 224
}
StickyNote {
 inputs 0
 name StickyNote2
 label "Motion Based Shading"
 xpos 39
 ypos -748
}
StickyNote {
 inputs 0
 name StickyNote3
 label "Color & Final Magnitude"
 xpos 39
 ypos -714
}
StickyNote {
 inputs 0
 name StickyNote1
 label Speckles
 xpos 37
 ypos -790
}
StickyNote {
 inputs 0
 name StickyNote4
 label "Base Luminance"
 xpos 38
 ypos -829
}
Axis2 {
 inputs 0
 translate {0.5199999809 1.519999981 0.2660000026}
 name Axis1
 xpos 516
 ypos -6
}
Camera2 {
 inputs 0
 translate {{parent.Camera8.translate.x} {parent.Camera8.translate.y} {parent.Camera8.translate.z}}
 rotate {{parent.Camera8.rotate} {parent.Camera8.rotate} {parent.Camera8.rotate}}
 focal 37.4
 name Camera7
 label "Normal Cam"
 xpos -149
 ypos -380
}
set N10574c00 [stack 0]
push $N10574c00
Dot {
 name Dot12
 xpos -125
 ypos 77
}
Constant {
 inputs 0
 channels rgb
 color 1
 name Constant3
 xpos -54
 ypos -1560
}
ReadGeo {
 file "\[python \{nuke.script_directory()\}]/armadillo.obj"
 translate {0 1 0}
 rotate {0 -125 0}
 name ReadGeo1
 xpos -54
 ypos -1488
}
Group {
 name Point_GeoSource
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -54
 ypos -1215
 addUserKnob {20 User}
 addUserKnob {26 info_1 l "" +STARTLINE T "GeoSource v1.1\n"}
 addUserKnob {26 divider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 method l Method t "<b>ParticleToGeo</b> - This will use the Nuke particle system to convert the geo into image data. If you don't have even UV's this is the recommended method.\n\n<b>UV</b> - This will use the nuke scanline render to render out the point position map in UV space. If your UV's are even and don't overlap this is the recommended method." M {ParticleToGeo UV "" "" "" "" ""}}
 addUserKnob {26 divider_transform l "<b><font color=#7DADF9>Transform</font><b>"}
 addUserKnob {41 translate l Translate T Axis1.translate}
 addUserKnob {41 rotate l Rotate T Axis1.rotate}
 addUserKnob {41 scaling l Scale T Axis1.scaling}
 addUserKnob {41 uniform_scale l "Uniform scale" T Axis1.uniform_scale}
 addUserKnob {41 skew l Skew T Axis1.skew}
 addUserKnob {26 divider_particle l "<b><font color=#7DADF9>ParticleToGeo</font><b>"}
 addUserKnob {4 PointPlacement l "Point Placement" M {points edges faces}}
 PointPlacement faces
 addUserKnob {6 Static l "Static Input" t "By default this node freezes vertex and texture animation at frame 1.\nThis is to reduce the overhead of the particle node.\nIf you need animated geo or textures, turn this option off." +STARTLINE}
 Static true
 addUserKnob {26 divider_uv l "<b><font color=#7DADF9>UV</font><b>"}
 addUserKnob {14 PointDensity l "Point Density" R 0 100}
 PointDensity 1100
 addUserKnob {20 Help}
 addUserKnob {26 info l "" +STARTLINE T ""}
}
 Input {
  inputs 0
  name InputGeo
  xpos 389
  ypos -279
 }
set N685d6c00 [stack 0]
 Crop {
  inputs 0
  box {0 0 {parent.PointDensity.w} {parent.PointDensity.h}}
  reformat true
  crop false
  name Crop1
  xpos 158
  ypos -197
 }
add_layer {pos pos.red pos.green pos.blue pos.alpha}
 ScanlineRender {
  inputs 2
  conservative_shader_sampling false
  projection_mode uv
  motion_vectors_type distance
  output_shader_vectors true
  P_channel pos
  name ScanlineRender1
  xpos 268
  ypos -197
 }
 Shuffle {
  in2 pos
  red red2
  green green2
  blue blue2
  out pos
  name Shuffle1
  xpos 268
  ypos -135
 }
 Dot {
  name Dot1
  xpos 302
  ypos -27
 }
push $N685d6c00
 Group {
  name Group1
  xpos 389
  ypos -194
  disable {{parent.Switch1.which}}
 }
  Input {
   inputs 0
   name Input1
   xpos 448
   ypos -243
  }
push 0
  ParticleEmitter {
   inputs 2
   emit_from {{parent.PointPlacement}}
   emit_order uniformly
   lifetime 1
   velocity 0
   color_from_texture true
   name ParticleEmitter3
   xpos 448
   ypos -164
  }
  Output {
   name Output1
   xpos 448
   ypos -74
  }
 end_group
 ParticleToImage {
  pos {pos.red pos.green pos.blue -pos.alpha}
  active pos.alpha
  name ParticleToImage1
  xpos 389
  ypos -133
 }
 FrameHold {
  first_frame 1
  name FrameHold1
  xpos 389
  ypos -82
  disable {{!parent.Static}}
 }
 Switch {
  inputs 2
  which {{parent.method}}
  name Switch1
  xpos 389
  ypos -30
 }
 ColorMatrix {
  channels pos
  matrix {
      {{parent.Axis1.world_matrix.0} {parent.Axis1.world_matrix.1} {parent.Axis1.world_matrix.2}}
      {{parent.Axis1.world_matrix.4} {parent.Axis1.world_matrix.5} {parent.Axis1.world_matrix.6}}
      {{parent.Axis1.world_matrix.8} {parent.Axis1.world_matrix.9} {parent.Axis1.world_matrix.10}}
    }
  name ColorMatrix1
  xpos 389
  ypos 31
 }
 Grade {
  channels pos
  add {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate} 0}
  black_clamp false
  name Grade1
  xpos 389
  ypos 63
 }
 Output {
  name Output1
  xpos 389
  ypos 97
 }
 Axis2 {
  inputs 0
  name Axis1
  xpos 533
  ypos 12
 }
end_group
Group {
 name Point_Fractal_Evolve
 knobChanged "\nif nuke.thisKnob() == nuke.thisNode()\[\"GravityType\"]:\n    if nuke.thisKnob().value() == \"Spherical\":\n        nuke.thisNode()\[\"Gravity\"].setVisible(False)\n        nuke.thisNode()\[\"gravity_spherical\"].setVisible(True)\n        nuke.thisNode()\[\"gravity_center\"].setVisible(True)\n    else:\n        nuke.thisNode()\[\"Gravity\"].setVisible(True)\n        nuke.thisNode()\[\"gravity_spherical\"].setVisible(False)\n        nuke.thisNode()\[\"gravity_center\"].setVisible(False)\nelif nuke.thisKnob() == nuke.thisNode()\[\"enable_floor\"]:\n    if nuke.thisNode()\[\"enable_floor\"].value():\n        nuke.thisNode()\[\"floor_height\"].setEnabled(True)\n        nuke.thisNode()\[\"floor_drag\"].setEnabled(True)     \n    else:   \n        nuke.thisNode()\[\"floor_height\"].setEnabled(False)\n        nuke.thisNode()\[\"floor_drag\"].setEnabled(False)    \nelif nuke.thisKnob() == nuke.thisNode()\[\"NoiseType\"]:\n    if nuke.thisNode()\[\"NoiseType\"].value() == \"Regular\":\n        nuke.thisNode()\[\"Noise_Octaves\"].setEnabled(True)    \n        nuke.thisNode()\[\"Noise_Gain\"].setEnabled(True)    \n        nuke.thisNode()\[\"Noise_Lacunarity\"].setEnabled(True)    \n    else:\n        nuke.thisNode()\[\"Noise_Octaves\"].setEnabled(False)    \n        nuke.thisNode()\[\"Noise_Gain\"].setEnabled(False)    \n        nuke.thisNode()\[\"Noise_Lacunarity\"].setEnabled(False)    \n"
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -54
 ypos -1029
 addUserKnob {20 User}
 addUserKnob {26 info_header l "" +STARTLINE T "Point FractalEvolve v1.2"}
 addUserKnob {7 Resolution l INVISIBLE +INVISIBLE R 1e-05 1}
 Resolution 1
 addUserKnob {41 filter l INVISIBLE +INVISIBLE T Reformat2.filter}
 addUserKnob {26 info_evolution l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {3 start_frame l "Start Frame"}
 addUserKnob {3 FadeIn l "Fade In" -STARTLINE}
 addUserKnob {3 FadeOut l Out -STARTLINE}
 FadeOut 9
 addUserKnob {7 Speed}
 Speed 0.5
 addUserKnob {7 Evolution R 0 50}
 Evolution {{max(0,(frame-start_frame)*Speed)}}
 addUserKnob {26 divider_simulation l "<b><font color=#7DADF9>Simulation</font><b>"}
 addUserKnob {7 Drag}
 Drag 0.069
 addUserKnob {13 InitialVelocity l "Initial Velocity"}
 addUserKnob {6 InputMask l "Enable Velocity Multiplier Map" t "This will enable the VelMultMap input on the node.\nThe Red Green and Blue channal will act as a custom initial velocity. So rather than the initial velocity knob that sets the overall velocity, this input will let you define a \"per point\" velocity.\n\nThe Alpha channel of the input will act as a general magnitude. So if the alpha is 0, no velocity is applied." -STARTLINE}
 addUserKnob {13 Flow}
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Collision</font><b>"}
 addUserKnob {6 enable_floor l "Enable Collision Floor" t "This will add a collision object to the scene.\nIf the gravity type is \"Regular\" it will add a horizontal floor where the \"Floor Height\" defines the \"Y Axis\" of the floor.\n\nIf the gravity type is \"Spherical\" it will add a spherical floor where the \"Floor Height\" defines the distance from the sphere center.\nRemember that the floor height must be a positive value if you want to use it in spherical mode." +STARTLINE}
 enable_floor true
 addUserKnob {7 floor_height l "Floor Height"}
 addUserKnob {7 floor_drag l "Floor Drag"}
 floor_drag 0.62
 addUserKnob {26 divier_gravity l "<b><font color=#7DADF9>Gravity</font><b>"}
 addUserKnob {4 GravityType l "Gravity Type" M {Regular Spherical "" ""}}
 addUserKnob {13 Gravity}
 Gravity {0 -0.7 0}
 addUserKnob {7 gravity_spherical l Gravity +HIDDEN}
 gravity_spherical 5
 addUserKnob {13 gravity_center l "Gravity Center" +HIDDEN}
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Fractal Settings</font><b>"}
 addUserKnob {4 NoiseType M {Regular Curl}}
 addUserKnob {6 Noise_Absolute l Absolute +INVISIBLE +STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.429
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 2.205
 addUserKnob {7 Noise_Amplitude l Amplitude}
 Noise_Amplitude 1
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Frequency Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" R 0 10}
 Freq_Offset {1 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_Offset_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale"}
 Freq_GeneralScale 0.305
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_GeneralScale_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" R 0 10}
 Freq_EvolveLow {0 0 0 0}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High"}
 Freq_EvolveHigh {0 0 0 0}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_EvolveHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low"}
 Freq_ScaleLow 1
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High"}
 Freq_ScaleHigh 1
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleHigh_panelDropped_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 ""}
 addUserKnob {20 Extra}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "Curve Noise"}
 addUserKnob {6 CurveNoise_Enable l Enable +STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 1
 addUserKnob {7 CurveOffset R -2 2}
 addUserKnob {6 CurveNoise_Invert l Invert -STARTLINE}
}
 Input {
  inputs 0
  name InputVelMultMap
  xpos -205
  ypos 1
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat3
  xpos -205
  ypos 48
 }
 Expression {
  expr3 1
  name Expression3
  selected true
  xpos -205
  ypos 115
  disable {{parent.InputMask}}
 }
 Dot {
  name Dot3
  xpos -171
  ypos 171
 }
 Input {
  inputs 0
  name Input1
  xpos -582
  ypos 8
 }
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -582
  ypos 50
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N105f6000 [stack 0]
 Reformat {
  type scale
  scale {{parent.Resolution}}
  center false
  filter Impulse
  pbb true
  name Reformat1
  xpos -459
  ypos 111
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -317
  ypos 110
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/EvolveNoise_v06.cpp
  recompileCount 190
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise 968e415f62cc51c8987469bcb742eb636bd543d8e55c8466db668b20a4a53bc6 3 \"src\" Read Point \"vel_mult\" Read Point \"dst\" Write Point 32 \"evolution\" Float 1 AACAPw== \"particleDrag\" Float 1 AAAAAA== \"absNoise\" Bool 1 AA== \"curlNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 1 AAAAPw== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"gravity\" Float 3 AAAAAJqZmb4AAAAAAAAAAA== \"initialVelocity\" Float 3 AAAAAJqZmb4AAAAAAAAAAA== \"flow\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"entryAmplitude\" Float 1 AACAPw== \"exitAmplitude\" Float 1 AACAPw== \"ampEntryFrame\" Int 1 AAAAAA== \"ampExitFrame\" Int 1 CAAAAA== \"enableFloor\" Bool 1 AA== \"floorHeight\" Float 1 AAAAvw== \"floorDragMultiplier\" Float 1 AAAAAA== \"floorBounce\" Float 1 AAAAAA== \"grav_center\" Float 3 AAAAAJqZmb4AAAAAAAAAAA== \"sphericalGravity\" Bool 1 AA== 32 \"evolution\" 1 1 \"particleDrag\" 1 1 \"absNoise\" 1 1 \"curlNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 \"gravity\" 3 1 \"initialVelocity\" 3 1 \"flow\" 3 1 \"entryAmplitude\" 1 1 \"exitAmplitude\" 1 1 \"ampEntryFrame\" 1 1 \"ampExitFrame\" 1 1 \"enableFloor\" 1 1 \"floorHeight\" 1 1 \"floorDragMultiplier\" 1 1 \"floorBounce\" 1 1 \"grav_center\" 3 1 \"sphericalGravity\" 1 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\n/*\nYou can think of the EvolveNoise/FractalEvolve as a way to apply the point fractal over x number of itterations \nand then let standard physics drive the simulation to a hold.\nThe way this works is that you define and in and out point for the simulation\nthe fractal displacement is then driven from the first frame to the last slowly \"fading out\" it's impact.\n\nAt this point the simulation is driven by gravity and drag.\nGravity is a contious force that is applied on each frame and drag counters any force applied.\n\nBy default the points start with no internal velocity but this can be controled with the initial velocity knob.\nOriginally this was the only way to control this, but i figured that due to the fact that an equal initial force is applied\nthe look is quite static. That is why you can now control the initial velocity using a custom map.\nThis gives a much more fine grained control and let you create more \"eexplotion like effects\"\n\n\n\nFor a bit of extra effect a \"floor\" have been added to make sure that the points does not just continue to fall when gravity is applied.\n*/\n\n\n//=========================\n//fastfloor\n//=========================\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\n\n//=========================\n//Frac\n//=========================\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\n//-------------------------------------\n// Smoothstep\n//-------------------------------------\ninline float smoothstep(float edge0, float edge1, float x)\n\{\n    float t;  /* Or genDType t; */\n    t = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return t * t * (3.0f - 2.0f * t);\n\}\n\n//-------------------------------------\n// basic mix function\n//-------------------------------------\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\n\n//=========================\n//hash\n//=========================\nfloat hash( float n ) \{ return Frac(sin(n)*753.5453123f); \}\n\n\n//=========================\n//cheap_noise\n//=========================\ninline float cheap_noise( float x ,float y, float z )\n\{\n    float3 p = floor(float3(x,y,z));\n    float3 f = float3(Frac(x),Frac(y),Frac(z));\n    f = f*f*(3.0f-2.0f*f);\n    \n    float n = p.x + p.y*157.0f + 113.0f*p.z;\n    return _fc_lerp(_fc_lerp(_fc_lerp( hash(n+  0.0f), hash(n+  1.0f),f.x),\n                   _fc_lerp( hash(n+157.0f), hash(n+158.0f),f.x),f.y),\n               _fc_lerp(_fc_lerp( hash(n+113.0f), hash(n+114.0f),f.x),\n                   _fc_lerp( hash(n+270.0f), hash(n+271.0f),f.x),f.y),f.z);\n\}\n\n//=========================\n//raw_noise_4d\n//=========================\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eRead, eAccessPoint, eEdgeClamped> vel_mult;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    float evolution;\n    float particleDrag;\n    bool absNoise;\n    bool curlNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float amplitude;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n    float3 gravity;\n    float3 initialVelocity;\n    float3 flow;\n    float entryAmplitude;\n    float exitAmplitude;\n    int ampEntryFrame;\n    int ampExitFrame;\n    bool enableFloor;\n    float floorHeight,floorDragMultiplier,floorBounce;\n    float3 grav_center;\n    bool sphericalGravity;\n\n\n  void define() \{\n        defineParam (evolution, \"evolution\", 1.0f);  \n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curlNoise, \"curlNoise\", false);  \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", 0.5f);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));   \n        defineParam (gravity, \"gravity\", float3(0.0f, -0.3f, 0.0f));\n        defineParam (initialVelocity, \"initialVelocity\", float3(0.0f, -0.3f, 0.0f));\n        defineParam (flow, \"flow\", float3(0.0f, 0.0f, 0.0f));\n        defineParam (ampEntryFrame, \"ampEntryFrame\", 0);\n        defineParam (ampExitFrame, \"ampExitFrame\", 8);\n        defineParam (entryAmplitude, \"entryAmplitude\", 1.0f);\n        defineParam (exitAmplitude, \"exitAmplitude\", 1.0f);          \n        defineParam (enableFloor, \"enableFloor\", false);\n        defineParam (floorHeight, \"floorHeight\", -0.5f);   \n        defineParam (floorDragMultiplier, \"floorDragMultiplier\", 0.0f);   \n        defineParam (floorBounce, \"floorBounce\", 0.0f); \n        defineParam (grav_center, \"grav_center\", float3(0.0f, -0.3f, 0.0f));         \n        defineParam (sphericalGravity, \"sphericalGravity\", false);    \n  \}\n\n\n\n//=========================\n//Normal Noise\n//=========================\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n//=========================\n//CurlNoiseFull\n//=========================\nfloat3 CurlNoiseFull( const float octaves, const float persistence, const float scale, const float x, const float y, const float z) \n\{\n    float3 total = float3(0.0f);\n    float3 current;\n    float3 last = float3(1.0f);\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = ComputeCurlFast(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return total / maxAmplitude;\n\}\n\n//=========================\n//ComputeCurlFast\n//=========================\nfloat3 ComputeCurlFast(float   x,  float   y,  float   z)  \n\{   \n                float   eps =   1.0f;    \n                float   n1, n2, a,  b;  \n                float3 curl;   \n                n1  =   cheap_noise(x,    y   +   eps,    z); \n                n2  =   cheap_noise(x,    y   -   eps,    z); \n                a   =   (n1 -   n2)/(2.0f   *   eps);   \n                    \n                n1  =   cheap_noise(x,    y,  z   +   eps);   \n                n2  =   cheap_noise(x,    y,  z   -   eps);   \n                b   =   (n1 -   n2)/(2.0f   *   eps);   \n                    \n                curl.x  =   a   -   b;  \n                    \n                n1  =   cheap_noise(x,    y,  z   +   eps);   \n                n2  =   cheap_noise(x,    y,  z   -   eps);   \n                a   =   (n1 -   n2)/(2.0f   *   eps);   \n                    \n                n1  =   cheap_noise(x +   eps,    y,  z); \n                n2  =   cheap_noise(x +   eps,    y,  z); \n                b   =   (n1 -   n2)/(2.0f   *   eps);   \n                    \n                curl.y  =   a   -   b;  \n                n1  =   cheap_noise(x +   eps,    y,  z); \n                n2  =   cheap_noise(x -   eps,    y,  z); \n                a   =   (n1 -   n2)/(2.0f   *   eps);   \n        \n                n1  =   cheap_noise(x,    y   +   eps,    z); \n                n2  =   cheap_noise(x,    y   -   eps,    z); \n                b   =   (n1 -   n2)/(2.0f  *   eps);   \n                    \n                curl.z  =   a   -   b;    \n                return  curl;   \n\}    \n\n\n//=========================\n//noise\n//=========================\n//Noise Only Code\nfloat noise( float3 x )\n\{\n    float3 p = floor(x);\n    float3 f = float3(Frac(x.x),Frac(x.y),Frac(x.z));\n    f = f*f*(3.0f-2.0f*f);\n    \n    float n = p.x + p.y*157.0f + 113.0f*p.z;\n    return _fc_lerp(_fc_lerp(_fc_lerp( hash(n+  0.0f), hash(n+  1.0f),f.x),\n                   _fc_lerp( hash(n+157.0f), hash(n+158.0f),f.x),f.y),\n               _fc_lerp(_fc_lerp( hash(n+113.0f), hash(n+114.0f),f.x),\n                   _fc_lerp( hash(n+270.0f), hash(n+271.0f),f.x),f.y),f.z);\n\}\n//=========================\n//complexNoise\n//=========================\nfloat complexNoise(float3 x)\n\{\n    //Noise Only Code\n    float3 q = 8.0f*x;\n    float f = 0.5000f*noise( q ); \n    q = q*2.01f;\n    f += 0.2500f*noise( q ); \n    q = q*2.02f;\n    f += 0.1250f*noise( q ); \n    q = q*2.03f;\n    f = f + 0.0625f*noise( q ); \n    q = q*2.01f;        \n    return f;       \n    //End Of Noise Only Code\n\}\n\n\n//This function is used to calculate the screenspace coordinates.\nvoid applyForceb( float3 &p_position, float3 &p_velocity, const float3 _force,const float3 _lastforce, const float spawntime) \{\n\n    float3 l_gravity;\n    \n    if (sphericalGravity)\{ //For spherical gravity we apply a gravity towards the grav center\n        l_gravity = (grav_center-p_position)*gravity.x;\n        //l_gravity = gravity;\n    \}\n    else\{\n        l_gravity = gravity;\n\n    \}\n\n    p_velocity += mix(_lastforce,_force,spawntime);\n    p_velocity += l_gravity;\n    p_velocity *= (1.0f-(particleDrag));\n    //p_velocity *= spawntime;\n    if (enableFloor)\{ //If we have a ground floor, make sure that the points don't go below\n\n        if (sphericalGravity)\{\n            if (length((p_position + (p_velocity*spawntime)) - grav_center) <=floorHeight)\{\n                p_velocity = p_velocity*(1.0f-(floorDragMultiplier));\n                p_velocity += float3(0.0f,-p_velocity.y,0.0f)*floorBounce;     \n                p_position += (p_velocity*spawntime);\n                p_position = (normalize(p_position-grav_center)*floorHeight)+grav_center;\n            \}\n            else \{\n                p_position += (p_velocity*spawntime);\n            \}\n        \}\n        else \{\n            if (p_position.y + p_velocity.y<=floorHeight)\{\n                p_velocity = p_velocity*(1.0f-(floorDragMultiplier));\n                p_velocity += float3(0.0f,-p_velocity.y,0.0f)*floorBounce;\n            \}\n            p_position += (p_velocity*spawntime);\n            p_position.y = max(p_position.y,floorHeight);\n        \}\n    \}\n    else\n    \{\n        p_position += (p_velocity*spawntime);\n    \}\n    \n\}\n\n//This function is used to calculate the screenspace coordinates.\nvoid applyForce( float3 &p_position,float3 &p_oldPosition,  float3 &p_velocity, const float3 _force,const float3 _lastforce, const float spawntime) \{\n\n    p_velocity = mix(_lastforce,_force,spawntime);\n    p_velocity += gravity;\n    //p_velocity *= (1.0f-(particleDrag));\n    float3 _temp = p_position;\n    p_position += (p_position-p_oldPosition)*(1.0f-particleDrag)+(p_velocity*spawntime);\n    p_oldPosition = _temp;\n\}\n\n//This function is used to calculate the screenspace coordinates.\nvoid applyForcec( float3 &p_position,float3 &p_oldPosition,  float3 &p_velocity, const float3 _force,const float3 _lastforce, const float spawntime) \{\n    p_velocity = _force;\n    p_velocity += gravity;\n    //p_velocity *= (1.0f-(particleDrag));\n    float3 _temp = p_position;\n    p_position += ((p_position-p_oldPosition)*(1.0f-particleDrag))+p_velocity*spawntime;\n    p_oldPosition = _temp;\n\}\n\n\n\n  void process() \{\n    float4 input = src();\n    float3 p_position = float3(input.x,input.y,input.z);\n    float3 p_oldPosition = p_position;\n\n    float3 output;\n    float3 lastSmaple = float3(0.0f);\n\n    float3 p_velocity = float3(vel_mult(0),vel_mult(1),vel_mult(2))+initialVelocity;\n    p_position += p_velocity;\n    float3 _force;\n    float3 _lastforce = float3(0.0f);\n    float step; //used to find the substep for amplitude multiplication\n    float ceiling;\n\n\n\n\n    for( int i=0; i < int(floor(evolution)); i++ ) \{\n\n        //Here we calculate how far we are between the ampEntry and ampExit frame.\n        //This is going to be used to add a smooth fadeout \n        step = (max((float)i,(float)ampEntryFrame)-(float)ampEntryFrame)/((float)ampExitFrame-(float)ampEntryFrame);\n        step = max(min(step,1.0f),0.0f);\n        if (i<ampExitFrame)\n        \{\n\n            if (curlNoise)\{\n                _force.x = complexNoise(float3(( p_position.x * scale.x ) + (offset.x+(i*flow.x)),( p_position.y * scale.y ) + (offset.y+(i*flow.y)),( p_position.z * scale.z ) + (offset.z+(i*flow.z)) ))-0.48f;\n                _force.y = complexNoise(float3(( p_position.x * scale.x ) + (offset.x+(i*flow.x)),( p_position.y * scale.y ) + (offset.y+(i*flow.y)),( p_position.z * scale.z ) + (offset.z+(i*flow.z))+100.0f ))-0.48f;\n                _force.z = complexNoise(float3(( p_position.x * scale.x ) + (offset.x+(i*flow.x)),( p_position.y * scale.y ) + (offset.y+(i*flow.y)),( p_position.z * scale.z ) + (offset.z+(i*flow.z))+200.0f ))-0.48f;\n                _force *= amplitude;\n                //_force = CurlNoiseFull(float(octaves), gain, lacunarity, ( p_position.x * scale.x ) + offset.x, ( p_position.y  * scale.y ) + offset.y,  ( p_position.z * scale.z ) + offset.z) * amplitude;\n            \}\n            else \{\n                _force.x = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( p_position.x * scale.x ) + (offset.x+(i*flow.x)), ( p_position.y * scale.y ) + (offset.y+(i*flow.y)),  ( p_position.z * scale.z ) + (offset.z+(i*flow.z)), ( input.w * scale.w ) + (offset.w)) * amplitude;\n                _force.y = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( p_position.x * scale.x ) + (offset.x+(i*flow.x)), ( p_position.y  * scale.y ) + (offset.y+(i*flow.y)),  ( p_position.z * scale.z ) + (offset.z+(i*flow.z)), ( input.w * scale.w ) + (offset.w) + 10000.0f) * amplitude;\n                _force.z = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( p_position.x * scale.x ) + (offset.x+(i*flow.x)), ( p_position.y  * scale.y ) + (offset.y+(i*flow.y)),  ( p_position.z * scale.z ) + (offset.z+(i*flow.z)), ( input.w * scale.w ) + (offset.w) + 20000.0f) * amplitude;\n            \}\n            _force *= 1.0f-step;\n        \}\n        else\n        \{\n            _force *= 0.0f;\n            /* code */\n        \}\n        if (float(i+2)>evolution)\{\n            ceiling = (evolution)-floor(evolution);\n        \}\n        else \{\n            ceiling = 1.0f;\n        \}\n        _force = _force * vel_mult(3);\n        //applyForcec(p_position,p_oldPosition,p_velocity,_force,_lastforce,ceiling); \n        applyForceb(p_position,p_velocity,_force,_lastforce,ceiling); \n\n        _lastforce = _force;\n        \n    \}\n\n    dst() = float4(p_position.x,p_position.y,p_position.z,input.w);\n\}\n\};"
  rebuild ""
  Noise4D_evolution {{parent.Evolution}}
  Noise4D_particleDrag {{parent.Drag}}
  Noise4D_curlNoise {{parent.NoiseType}}
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain x-2 0.684}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0
  Noise4D_amplitude {{parent.Noise_Amplitude}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  Noise4D_gravity {{parent.GravityType==1?parent.gravity_spherical/100:parent.Gravity/100} {parent.Gravity/100} {parent.Gravity/100}}
  Noise4D_initialVelocity {{parent.InitialVelocity} {parent.InitialVelocity} {parent.InitialVelocity}}
  Noise4D_flow {{parent.Flow/100} {parent.Flow/100} {parent.Flow/100}}
  Noise4D_ampEntryFrame {{parent.FadeIn}}
  Noise4D_ampExitFrame {{parent.FadeOut}}
  Noise4D_enableFloor {{parent.enable_floor}}
  Noise4D_floorHeight {{parent.floor_height}}
  Noise4D_floorDragMultiplier {{parent.floor_drag}}
  Noise4D_grav_center {{parent.gravity_center.x} {parent.gravity_center.y} {parent.gravity_center.z}}
  Noise4D_sphericalGravity {{parent.GravityType}}
  rebuild_finalise ""
  name Noise4D3
  xpos -317
  ypos 164
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -317
  ypos 228
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -317
  ypos 330
 }
 Reformat {
  type scale
  scale {{1/parent.Reformat1.scale}}
  center false
  pbb true
  name Reformat2
  xpos -456
  ypos 331
 }
push $N105f6000
 Merge2 {
  inputs 2
  operation copy
  bbox B
  Achannels pos
  Bchannels pos
  output pos
  name Merge1
  xpos -582
  ypos 326
 }
 Output {
  name Output1
  xpos -582
  ypos 497
 }
end_group
Dot {
 name Dot1
 xpos -20
 ypos -864
}
set N10649400 [stack 0]
Dot {
 name Dot4
 xpos -226
 ypos -864
}
Group {
 name Point_MotionShader2
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -260
 ypos -788
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Motion Shader v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 Output M {"Motion Velocity" "Motion Vector"}}
 addUserKnob {7 Multiplier R 0 1000}
 Multiplier 10
}
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label Motion
  note_font_size 42
  xpos -566
  ypos 152
  bdwidth 376
  bdheight 209
 }
 Input {
  inputs 0
  name Input1
  xpos -444
  ypos 86
 }
 Shuffle {
  in pos
  name Shuffle1
  xpos -444
  ypos 142
 }
 Dot {
  name Dot1
  xpos -410
  ypos 179
 }
set N10648000 [stack 0]
 TimeOffset {
  time_offset 1
  time ""
  name TimeOffset1
  xpos -444
  ypos 210
 }
set N1053fb80 [stack 0]
push $N10648000
 Dot {
  name Dot2
  xpos -264
  ypos 179
 }
 Dot {
  name Dot10
  xpos -264
  ypos 246
 }
set N1066f800 [stack 0]
 Merge2 {
  inputs 2
  operation minus
  name Vector
  xpos -546
  ypos 318
 }
push $N1053fb80
push $N1066f800
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Magnitude
  xpos -444
  ypos 319
 }
 Switch {
  inputs 2
  which {{parent.Output}}
  name Switch1
  xpos -444
  ypos 426
 }
 Grade {
  white {{parent.Multiplier}}
  black_clamp false
  name Grade11
  selected true
  xpos -444
  ypos 450
 }
 Output {
  name Output1
  xpos -444
  ypos 479
 }
end_group
set N1053e580 [stack 0]
TimeEcho {
 mode Average
 framesbehind 8
 name TimeEcho3
 xpos -260
 ypos -747
}
push $N1053e580
Grade {
 white 0.16
 name Grade12
 xpos -164
 ypos -788
}
push $N10649400
Grade {
 channels rgba
 white 0.063
 name Grade25
 xpos -54
 ypos -828
}
Noise {
 inputs 1+1
 cliptype none
 maskChannelMask rgba.red
 size 32
 gain 1.1
 gamma 0.08
 center {960 540}
 color {1 1 1 1}
 color_panelDropped true
 name Noise6
 xpos -54
 ypos -788
}
Merge2 {
 inputs 2
 operation plus
 mix 0.139
 name Merge10
 xpos -54
 ypos -747
}
Grade {
 white {0.135993 0.586457 1 1}
 white_panelDropped true
 multiply 1.28
 name Grade26
 xpos -54
 ypos -711
}
Dot {
 name Dot7
 xpos -20
 ypos -216
}
set N5a0ecc00 [stack 0]
Group {
 inputs 2
 name Point_Render5
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -55
 ypos 74
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 37.4
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 29.6
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 53
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent {{parent.Point_Render6.FogExponent}}
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 23.7
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 20
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 2
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 mb_enable true
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 9
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N5a142000 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N5a159000 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N5a159000
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N5a159000
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N5a189000 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N5a189000
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N5a1b2c00 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N5a1d7c00 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N5a1b2c00
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N5a189000
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N5a218c00 [stack 0]
push $N5a1d7c00
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N5a253c00 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N5a253c00
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N5a218c00
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N5a142000
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N5a189000
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
set N1053f600 [stack 0]
Reconcile3D {
 inputs 3
 output {{curve x1 1303.615234} {curve x1 333.4135132}}
 outputxyz {{curve x1 0.5199999809} {curve x1 1.519999981} {curve x1 0.2660000026}}
 name Reconcile3D1
 xpos 506
 ypos 70
}
StickyNote {
 inputs 0
 name StickyNote5
 label "This is the point where the blast should appear in 2D space.  \nGood to do it this way incase we want to change the camera etc."
 xpos 621
 ypos 71
}
StickyNote {
 inputs 0
 name StickyNote6
 label "The distance from the ground plane.\nUsed to make the points darker depending on the distance from the surface"
 xpos -1220
 ypos 28
}
StickyNote {
 inputs 0
 name StickyNote7
 label "Calculate distance from center"
 xpos -757
 ypos 2457
}
StickyNote {
 inputs 0
 name StickyNote8
 label "Contract at ground level to add some perspective"
 xpos -751
 ypos 2549
}
StickyNote {
 inputs 0
 name StickyNote9
 label "Animation of the wave"
 xpos -751
 ypos 2609
}
StickyNote {
 inputs 0
 name StickyNote10
 label "Use a sine curve for the wave "
 xpos -752
 ypos 2656
}
StickyNote {
 inputs 0
 name StickyNote11
 label "Remove unwanted deep blacks"
 xpos -754
 ypos 2686
}
StickyNote {
 inputs 0
 name StickyNote12
 label "Slight Randomization"
 xpos -761
 ypos 2750
}
StickyNote {
 inputs 0
 name StickyNote13
 label "Smooth the curve so that the distortion don't get any sharp edges"
 xpos -762
 ypos 2785
}
StickyNote {
 inputs 0
 name StickyNote14
 label "Convert luminance to direction"
 xpos -756
 ypos 2972
}
StickyNote {
 inputs 0
 name StickyNote15
 label "Soften the distortions"
 xpos 49
 ypos 3227
}
StickyNote {
 inputs 0
 name StickyNote16
 label "Distortions split into R,G and B"
 xpos 53
 ypos 3082
}
Noise {
 inputs 0
 size 840
 center {1024 778}
 name Noise4
 xpos -966
 ypos 2748
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup Rectangle1 512 bezier
     {{cc
       {f 8192}
       {p
        {0 x429d5554}
        {xc4248000 xc3560000}
        {x44740000}
        {xc4740000}
        {x450de000 xc3560000}
        {0 x429d5554}
        {0 xc29d5555}
        {x450de000 x41b00000}
        {xc4740000}
        {x44740000}
        {xc4248000 x41b00000}
        {0 xc29d5555}}}
      {cc
       {f 8192}
       {p
        {0 x429d5554}
        {}
        {x44740000}
        {xc4740000}
        {}
        {0 x429d5554}
        {0 xc29d5555}
        {x41833380 x432eccd0}
        {xc4740000}
        {x44740000}
        {x42893320 x4337cccd}
        {0 xc29d5555}}}}
     {tx x41000000 x44498000 xc2c00000}
     {a ft 1 osw x41200000 osf 0 str 1 spx x44800000 spy x44428000 sb 1 ltn x41000000 ltm x41000000 tt x41000000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 tt 8 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {1024 778}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 8
 lifetime_end 8
 motionblur_shutter_offset_type centred
 feather_type smooth0
 source_black_outside true
 name Roto3
 xpos -966
 ypos 2546
}
Constant {
 inputs 0
 channels rgb
 color {{parent.Reconcile3D1.output.x} {parent.Reconcile3D1.output.y} 0 0}
 color_panelDropped true
 name Constant1
 xpos -900
 ypos 2358
}
Expression {
 inputs 0
 expr0 x
 expr1 y
 name Expression2
 xpos -801
 ypos 2364
}
Noise {
 opacity 0.08
 size 220
 octaves 2
 gain 1
 gamma 0.505
 center {1024 778}
 name Noise5
 xpos -801
 ypos 2388
}
Group {
 inputs 2
 name Vector_Math_Ops1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -856
 ypos 2458
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "Vector Math Ops v1.0\n"}
 addUserKnob {26 devidergeneral l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 Operation M {"Dot Product 3D" "Dot Product 2D" "Vector Length 3D (Input 1)" "Vector Length 2D (Input 1)" "Reflect Vector" "Normalize (Input 1)" "Cross Product" Substract Add Distance "" "" ""}}
 Operation Distance
 addUserKnob {6 Normalise_Output l "Normalize Output" t "If this is checked, all outputs will be normalised." +STARTLINE}
 addUserKnob {6 Saturate_Output l "Saturate Output" t "This will move vectors from -1:1 space to 0:1 space" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {41 in l "Input 1 Channal" T Shuffle1.in}
 addUserKnob {41 in_1 l "Input 2 Channal" T Shuffle2.in}
 addUserKnob {4 AlphaChanal l "Keep Alpha From" M {1 2 "" ""}}
 addUserKnob {26 ""}
 addUserKnob {26 Info l "" +STARTLINE T "For Reflect Vector A=Normal, B=Velocity"}
 addUserKnob {20 Help}
 addUserKnob {26 HelpText l "" +STARTLINE T "This node will let you do common vector math operations on One or Two input streams.\n\nThe input will be the channals that you select in the User section and the output will be in the RGBA channal."}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x8e388e00
  label DotProduct2D
  note_font_size 25
  xpos 652
  ypos -4
  bdwidth 178
  bdheight 166
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x7171c600
  label "Vector Length 3D"
  note_font_size 25
  xpos 861
  ypos 2
  bdwidth 213
  bdheight 159
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x7171c600
  label "Vector Length 2D"
  note_font_size 25
  xpos 1106
  ypos 2
  bdwidth 213
  bdheight 159
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label Normalize
  note_font_size 25
  xpos 1570
  ypos 1
  bdwidth 183
  bdheight 159
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x7171c600
  label "Cross Product"
  note_font_size 25
  xpos 1816
  ypos -3
  bdwidth 203
  bdheight 168
 }
 BackdropNode {
  inputs 0
  name DotProduct3D
  tile_color 0x8e8e3800
  label DotProduct3D
  note_font_size 25
  xpos 423
  ypos -6
  bdwidth 158
  bdheight 164
 }
 BackdropNode {
  inputs 0
  name Reflect_Vecor
  tile_color 0x8e388e00
  label "Reflect Vector 3D\nA=normal\nB = Velocity"
  note_font_size 25
  xpos 1339
  ypos -1
  bdwidth 197
  bdheight 163
 }
 BackdropNode {
  inputs 0
  name Substract
  tile_color 0x7171c600
  label Substract
  note_font_size 25
  xpos 2102
  ypos -3
  bdwidth 203
  bdheight 168
 }
 BackdropNode {
  inputs 0
  name Substract1
  tile_color 0x7171c600
  label Add
  note_font_size 25
  xpos 2350
  ypos -3
  bdwidth 203
  bdheight 168
 }
 BackdropNode {
  inputs 0
  name Substract2
  tile_color 0x7171c600
  label Dist
  note_font_size 25
  xpos 2607
  ypos -3
  bdwidth 203
  bdheight 168
 }
 Input {
  inputs 0
  name Input2
  xpos 1000
  ypos -246
  number 1
 }
 Dot {
  name B
  label B
  xpos 1034
  ypos -206
 }
 Shuffle {
  in rgb
  in2 rgba
  alpha alpha2
  name Shuffle2
  xpos 1000
  ypos -165
 }
 Dot {
  name Dot13
  xpos 1034
  ypos -38
 }
set N5a356400 [stack 0]
 Dot {
  name Dot21
  xpos 778
  ypos -38
 }
set N5a356000 [stack 0]
 Dot {
  name Dot19
  xpos 525
  ypos -38
 }
set N5a371c00 [stack 0]
 Dot {
  name Dot30
  xpos 271
  ypos -38
 }
 Dot {
  name Dot32
  xpos 271
  ypos 706
 }
 Input {
  inputs 0
  name Input1
  xpos 905
  ypos -244
 }
 Dot {
  name A
  label A
  xpos 939
  ypos -204
 }
 Shuffle {
  in rgb
  in2 rgba
  alpha alpha2
  name Shuffle1
  xpos 905
  ypos -164
 }
 Dot {
  name Dot12
  xpos 939
  ypos -89
 }
set N5a370400 [stack 0]
 Dot {
  name Dot15
  xpos 662
  ypos -89
 }
set N5a370000 [stack 0]
 Dot {
  name Dot14
  xpos 433
  ypos -89
 }
set N5a387c00 [stack 0]
 Dot {
  name Dot31
  xpos 336
  ypos -89
 }
 Dot {
  name Dot33
  xpos 336
  ypos 584
 }
 Switch {
  inputs 2
  which {{parent.AlphaChanal}}
  name Switch2
  xpos 872
  ypos 703
 }
push $N5a356400
 Dot {
  name Dot4
  xpos 1374
  ypos -38
 }
set N5a387000 [stack 0]
 Dot {
  name Dot1
  xpos 1867
  ypos -38
 }
set N5a386c00 [stack 0]
 Dot {
  name Dot28
  xpos 2153
  ypos -38
 }
set N5a386800 [stack 0]
 Dot {
  name Dot35
  xpos 2401
  ypos -38
 }
set N5a386400 [stack 0]
 Dot {
  name Dot42
  xpos 2658
  ypos -38
 }
 Dot {
  name Dot43
  xpos 2658
  ypos 137
 }
push $N5a370400
 Dot {
  name Dot17
  xpos 1215
  ypos -89
 }
set N5a3a1800 [stack 0]
 Dot {
  name Dot16
  xpos 1452
  ypos -89
 }
set N5a3a1400 [stack 0]
 Dot {
  name Dot18
  xpos 1665
  ypos -89
 }
set N5a3a1000 [stack 0]
 Dot {
  name Dot2
  xpos 1924
  ypos -89
 }
set N5a3a0c00 [stack 0]
 Dot {
  name Dot29
  xpos 2210
  ypos -89
 }
set N5a3a0800 [stack 0]
 Dot {
  name Dot37
  xpos 2458
  ypos -89
 }
set N5a3a0400 [stack 0]
 Dot {
  name Dot44
  xpos 2715
  ypos -89
 }
 MergeExpression {
  inputs 2
  temp_name0 xd
  temp_expr0 A.red-B.red
  temp_name1 yd
  temp_expr1 A.green-B.green
  temp_name2 zd
  temp_expr2 A.blue-B.blue
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  name Distance
  xpos 2681
  ypos 134
 }
 Dot {
  name Dot45
  xpos 2715
  ypos 264
 }
push $N5a386400
 Dot {
  name Dot36
  xpos 2401
  ypos 137
 }
push $N5a3a0400
 MergeExpression {
  inputs 2
  expr0 A.red+B.red
  expr1 A.green+B.green
  expr2 A.blue+B.blue
  name Cross_Product2
  xpos 2424
  ypos 134
 }
 Dot {
  name Dot38
  xpos 2458
  ypos 264
 }
push $N5a386800
 Dot {
  name Dot27
  xpos 2153
  ypos 137
 }
push $N5a3a0800
 MergeExpression {
  inputs 2
  expr0 A.red-B.red
  expr1 A.green-B.green
  expr2 A.blue-B.blue
  name Cross_Product1
  xpos 2176
  ypos 134
 }
 Dot {
  name Dot34
  xpos 2210
  ypos 236
 }
push $N5a386c00
 Dot {
  name Dot25
  xpos 1867
  ypos 137
 }
push $N5a3a0c00
 MergeExpression {
  inputs 2
  expr0 "A.green*B.blue - A.blue*B.green"
  expr1 "A.blue*B.red - A.red*B.blue"
  expr2 "A.red*B.green - A.green*B.red"
  name Cross_Product
  xpos 1890
  ypos 134
 }
 Dot {
  name Dot26
  xpos 1924
  ypos 225
 }
push $N5a3a1000
 Expression {
  temp_name3 Length
  temp_expr3 sqrt(Red*Red+Green*Green+Blue*Blue)+0.000000001
  expr0 Red/Length
  expr1 Green/Length
  expr2 Blue/Length
  name Normalize_Vector
  xpos 1631
  ypos 125
 }
 Dot {
  name Dot11
  xpos 1665
  ypos 214
 }
push $N5a3a1400
push $N5a387000
 Dot {
  name Dot5
  xpos 1374
  ypos 129
 }
 MergeExpression {
  inputs 2
  temp_expr0 "A = Normal, B = Velocity Vector!"
  temp_name3 dot
  temp_expr3 (A.red*B.red+A.green*B.green+A.blue*B.blue)
  expr0 "-2*(dot)*A.red + B.red"
  expr1 "-2*(dot)*A.green + B.green"
  expr2 "-2*(dot)*A.blue + B.blue"
  name Reflect3D
  xpos 1418
  ypos 126
 }
 Dot {
  name Dot20
  xpos 1452
  ypos 201
 }
push $N5a3a1800
 Expression {
  temp_name3 VectorLength_2D
  temp_expr3 sqrt(Red*Red+Green*Green)
  expr0 VectorLength_2D
  expr1 VectorLength_2D
  expr2 VectorLength_2D
  name Vector_Length2D
  xpos 1181
  ypos 124
 }
 Dot {
  name Dot22
  xpos 1215
  ypos 175
 }
push $N5a370400
 Expression {
  temp_name3 VectorLength_3D
  temp_expr3 sqrt(Red*Red+Green*Green+Blue*Blue)
  expr0 VectorLength_3D
  expr1 VectorLength_3D
  expr2 VectorLength_3D
  name Vector_Length3D
  selected true
  xpos 905
  ypos 128
 }
 Dot {
  name Dot23
  xpos 939
  ypos 186
 }
push $N5a370000
 Dot {
  name Dot6
  xpos 662
  ypos 130
 }
push $N5a356000
 MergeExpression {
  inputs 2
  temp_name3 dot_product_2d
  temp_expr3 (A.red*B.red+A.green*B.green)
  expr0 dot_product_2d
  expr1 dot_product_2d
  expr2 dot_product_2d
  name Dot_Product2D
  xpos 744
  ypos 127
 }
 Dot {
  name Dot10
  xpos 778
  ypos 204
 }
push $N5a387c00
 Dot {
  name Dot3
  xpos 433
  ypos 133
 }
push $N5a371c00
 MergeExpression {
  inputs 2
  temp_name3 dot_product_3d
  temp_expr3 (A.red*B.red+A.green*B.green+A.blue*B.blue)
  expr0 dot_product_3d
  expr1 dot_product_3d
  expr2 dot_product_3d
  name Dot_Product3D
  xpos 491
  ypos 130
 }
 Dot {
  name Dot9
  xpos 525
  ypos 250
 }
 Switch {
  inputs 10
  which {{parent.Operation}}
  name Switch1
  xpos 1023
  ypos 291
 }
 Dot {
  name Dot7
  xpos 1057
  ypos 332
 }
set N5a425400 [stack 0]
 Dot {
  name Dot8
  xpos 1192
  ypos 332
 }
 Expression {
  temp_name3 Length
  temp_expr3 "sqrt((Red*Red) + (Green*Green) + (Blue*Blue))+0.00000001"
  expr0 Red/Length
  expr1 Green/Length
  expr2 Blue/Length
  expr3 Length
  name Normalize_Vector_out
  xpos 1158
  ypos 373
 }
 Dot {
  name Dot24
  xpos 1192
  ypos 444
 }
push $N5a425400
 Switch {
  inputs 2
  which {{parent.Normalise_Output}}
  name Normalise
  xpos 1023
  ypos 441
 }
 Dot {
  name Dot39
  xpos 1057
  ypos 550
 }
set N5a424400 [stack 0]
 Dot {
  name Dot40
  xpos 1192
  ypos 550
 }
 Expression {
  expr0 r/2+0.5
  expr1 g/2+0.5
  expr2 b/2+0.5
  name Saturate_Vector_out
  xpos 1158
  ypos 597
 }
 Dot {
  name Dot41
  xpos 1192
  ypos 662
 }
push $N5a424400
 Switch {
  inputs 2
  which {{parent.Saturate_Output}}
  name Saturate
  xpos 1023
  ypos 659
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy1
  xpos 1023
  ypos 703
 }
 Dot {
  name Out
  label Out
  xpos 1057
  ypos 744
 }
 Output {
  name Output1
  xpos 1023
  ypos 770
 }
end_group
Grade {
 inputs 1+1
 white 1.88
 black_clamp false
 name Grade10
 xpos -856
 ypos 2550
}
Grade {
 white 0.006
 add {{curve x4 2 l x12 -2 x18 -2.5}}
 name Grade9
 xpos -856
 ypos 2609
}
Expression {
 channel0 rgb
 expr0 sin(r)*clamp(pi*2-r,0,1)
 name Expression3
 xpos -856
 ypos 2654
}
Clamp {
 maximum_enable false
 name Clamp1
 xpos -856
 ypos 2684
}
Merge2 {
 inputs 2
 operation multiply
 mix 0.295
 name Merge4
 xpos -856
 ypos 2748
}
Expression {
 channel0 rgb
 expr0 smoothstep(0,1,r)
 name Expression4
 xpos -856
 ypos 2785
}
Dot {
 name Dot16
 xpos -822
 ypos 2828
}
set N5a483000 [stack 0]
Matrix {
 channels {-rgba.red rgba.green -rgba.blue none}
 matrix {
     {-1 -2 -1}
     {0 0 0}
     {1 2 1}
   }
 name Matrix5
 xpos -856
 ypos 2963
}
Matrix {
 channels {rgba.red -rgba.green -rgba.blue none}
 matrix {
     {1 0 -1}
     {2 0 -2}
     {1 0 -1}
   }
 name Matrix6
 xpos -856
 ypos 2987
}
set N5a482800 [stack 0]
Blur {
 size 100
 name Blur4
 xpos -856
 ypos 3223
}
push $N5a482800
Grade {
 white {{curve x3 0 200}}
 black_clamp false
 name Grade11
 xpos -856
 ypos 3011
}
Noise {
 inputs 0
 size 840
 center {1024 778}
 name Noise2
 xpos -159
 ypos 2767
}
push $N5a483000
Blur {
 size 400
 name Blur6
 xpos -269
 ypos 2821
}
Merge2 {
 inputs 2
 operation multiply
 mix 0.735
 name Merge5
 xpos -159
 ypos 2825
}
Grade {
 white {0.342034 0.743418 1 0.342034}
 name Grade13
 xpos -159
 ypos 2849
}
Noise {
 inputs 0
 type turbulence
 size 16.5
 center {1024 778}
 name Noise1
 xpos -895
 ypos 1825
}
Blur {
 size 2.5
 name Blur7
 xpos -895
 ypos 1849
}
Matrix {
 channels {-rgba.red rgba.green -rgba.blue none}
 matrix {
     {-1 -2 -1}
     {0 0 0}
     {1 2 1}
   }
 name Matrix1
 xpos -895
 ypos 1881
}
Matrix {
 channels {rgba.red -rgba.green -rgba.blue none}
 matrix {
     {1 0 -1}
     {2 0 -2}
     {1 0 -1}
   }
 name Matrix2
 xpos -895
 ypos 1900
}
Grade {
 multiply 0.33
 black_clamp false
 name Grade5
 xpos -895
 ypos 1924
}
Axis2 {
 inputs 0
 scaling {1 -1 1}
 name Axis3
 label "Flip in ground plane"
 xpos -281
 ypos -471
}
Camera2 {
 translate {12.06725407 3.19890618 20.68225861}
 rotate {-0.07799379 36.19999002 0}
 name Camera8
 label "Reflection Cam"
 xpos -281
 ypos -380
}
Dot {
 name Dot10
 xpos -849
 ypos -356
}
Dot {
 name Dot11
 xpos -849
 ypos 75
}
set N5a504800 [stack 0]
push $N5a0ecc00
Dot {
 name Dot9
 xpos -727
 ypos -216
}
Dot {
 name Dot5
 xpos -727
 ypos -6
}
set N5a504000 [stack 0]
Dot {
 name Dot13
 xpos -1289
 ypos -6
}
Expression {
 expr0 pos.green
 expr1 pos.green
 expr2 pos.green
 name Expression1
 xpos -1323
 ypos 35
}
Group {
 inputs 2
 name Point_Render2
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -1323
 ypos 72
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 37.4
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 facet_depth true
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 29.6
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 53
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent {{parent.Point_Render6.FogExponent}}
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 23.7
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 20
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 2
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 6
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N5a616c00 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N5a63bc00 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N5a63bc00
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N5a63bc00
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N5a669c00 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N5a669c00
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N5a689800 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N5a688800 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N5a689800
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N5a669c00
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N5a6e3800 [stack 0]
push $N5a688800
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N5a6e2800 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N5a6e2800
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N5a6e3800
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N5a616c00
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N5a669c00
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
Dot {
 name Dot8
 xpos -1289
 ypos 145
}
push $N5a504800
push $N5a504000
Group {
 inputs 2
 name Point_Render1
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos -761
 ypos 72
 addUserKnob {20 User l "Point Render" t dd}
 addUserKnob {26 info_header l "" +STARTLINE T "Point Render v1.0"}
 addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
 addUserKnob {4 RenderMode l "Render Mode" t "Some generators support multiple render modes other than just point rendering. This should be considered a experimental feature, but can be used to great effect.\n\nIn the Render Settings tab you can find more controls relating to Wire and Facet rendering modes.\n\nNote that Facet Render can be slow when really close to a object. " M {"Point Render" "Wire Render" "Facet Render (experimental)" "" "" ""}}
 addUserKnob {7 FocalLength l "Focal Length" t "The point render does not take the focal length from the input camera, so if you want to match it to a camera you should link the focal length from the camera to this." R 0 200}
 FocalLength 37.4
 addUserKnob {7 horizontalApeture l "Horiz Apeture" R 0 100}
 horizontalApeture 24.576
 addUserKnob {7 AlphaMultiplier l Exposure t "This is a general exposure modifier that lets you adjust the overall brightness of the render." R 0 2}
 AlphaMultiplier 1
 addUserKnob {6 UseOcclusionMap l "Use Occlusion Map" t "Enable the Occlusion map input. This lets you use a depth map as a holdout.\n\nNote:\nThe Red channal should contain the depth (absolute distance, not 1/depth)\nThe Alpha channal must be 1 for the areas that you want to holdout." +STARTLINE}
 addUserKnob {26 devider_cc l "<b><font color=#7DADF9>Preview</font><b>"}
 addUserKnob {6 FastPreview l "Fast Preview" t "Reduce the number of points for a quick preview of the final render." +STARTLINE}
 addUserKnob {6 HighlightCompression l "Hilight Compression" t "Compresses the highlights to make it easier to see bright details." +STARTLINE}
 addUserKnob {7 HighlightCeiling l "Highlight Ceiling" t "Adjust the cealing for the highlight compression." R 1 10}
 HighlightCeiling 1.15
 addUserKnob {7 Compression t "The compression amount." -STARTLINE R 0 5}
 Compression 1
 addUserKnob {26 devider_format l "<b><font color=#7DADF9>Format</font><b>"}
 addUserKnob {41 format l "output format" T Settings_Format.format}
 addUserKnob {20 WireRender l "Render Settings"}
 addUserKnob {26 devider_wirerender l "<b><font color=#7DADF9>Wire Rendering</font><b>"}
 addUserKnob {4 wire_type l "Connection Mode" t "*Normal\nConnect lines between the local neigbours of the 2d position map\n\n*Nearest\nConnect lines to the nearest points (in 3D space). This mode is limited to 100x100 points for performence reasons!" M {Normal Nearest "" "" "" "" "" "" "" ""}}
 addUserKnob {26 text l "Normal Mode Wires" T " "}
 addUserKnob {6 connect_x l x t "Connect wires in the (uv) X axis." -STARTLINE}
 connect_x true
 addUserKnob {6 connect_xy l xy t "Connect wires in the (uv) XY axis." -STARTLINE}
 connect_xy true
 addUserKnob {6 connect_y l y t "Connect wires in the (uv) Y axis." -STARTLINE}
 connect_y true
 addUserKnob {6 connect_aux l aux t "If you input a vector map into the Aux input for this node, and enable this option, you will get a wire from each point along that vector." -STARTLINE}
 addUserKnob {7 wire_maxdistance l "Max Distance" t "The maximum distance that the wires connect." R 0 10}
 wire_maxdistance 6
 addUserKnob {7 wire_Threshold l "Distance Threshold" t "Control the max distance threshold" R 0 2}
 wire_Threshold 0.5
 addUserKnob {3 wire_connections l "Max Connections" t "The maximum number of connections (Not Yet Implemented)"}
 wire_connections 4
 addUserKnob {7 maxSamples l "Max Line Samples" t "The maximum length of a line. Once a line is longer than this, it will start break up. \nThis can also be used as a creative effect if you set it low, try setting it to 10 in wire mode to get dotted lines" R 0 10000}
 maxSamples 10000
 addUserKnob {7 lineoffset l "Line Offset" t "Expand or contract the lines."}
 lineoffset 1
 addUserKnob {7 inGain l "In Gain" t "Gain the brightness of the in-point of the lines"}
 inGain 1
 addUserKnob {7 outGain l "Out Gain" t "Gain the brightness of the out-point of the lines" -STARTLINE}
 outGain 1
 addUserKnob {26 devider_facet l "<b><font color=#7DADF9>Facet Rendering</font><b>"}
 addUserKnob {4 renderMode l "Render Mode" t "Pick the desidered render mode." M {Diffuse "Local ST" Normal "Facing Ratio" UV ST "View Normal" "World Position" "" ""}}
 addUserKnob {6 facet_flatShading l "Flat Shading" t "Flat shading" +STARTLINE}
 addUserKnob {6 facet_depth l "Depth Buffer" t "Enable depth sorting to avoid additive surfaces." -STARTLINE}
 addUserKnob {6 facet_front l "Front Face" t "Render front facing facets" +STARTLINE}
 facet_front true
 addUserKnob {6 facet_backface l "Back Face" t "Render backfacing faces" -STARTLINE}
 facet_backface true
 addUserKnob {26 _1 l "<b><font color=#7DADF9>Other</font><b>"}
 addUserKnob {6 CloseX l "Close X" t "On spheres or round objects this closes the loop" +STARTLINE}
 addUserKnob {6 CloseY l "Close Y" t "On spheres or round objects this closes the loop" -STARTLINE}
 addUserKnob {20 Fog_1 l Fog}
 addUserKnob {26 Devider_Fog l "<b><font color=#7DADF9>Fog</font><b>"}
 addUserKnob {6 Fog t "Fog reduces the brightness of poins far from the camera." +STARTLINE}
 addUserKnob {7 FogNear l "Fog Near" R 0 200}
 FogNear 29.6
 addUserKnob {7 FogFar l "Fog Far" R 0 200}
 FogFar 53
 addUserKnob {7 FogExponent l "Fog Exponent" R 0 8}
 FogExponent {{parent.Point_Render6.FogExponent}}
 addUserKnob {20 DepthOfField l "Depth of Field"}
 addUserKnob {26 devider_dof l "<b><font color=#7DADF9>Depth Of Field</font><b>"}
 addUserKnob {6 dof_enable l Enable +STARTLINE}
 addUserKnob {7 dof_focaldepth l "Focal Depth" R 0 40}
 dof_focaldepth 23.7
 addUserKnob {7 dof_dof l "Depth of Field" R 0 10}
 dof_dof 20
 addUserKnob {7 dof_maxSize l "Max Size"}
 dof_maxSize 2
 addUserKnob {7 dof_Aspect l "Aspect Ratio"}
 dof_Aspect 1
 addUserKnob {7 dof_bias l Bias R -3 3}
 dof_bias -0.2
 addUserKnob {4 Dof_Quality l Quality M {Low Medium High Extreme}}
 addUserKnob {20 MotionBlur}
 addUserKnob {26 devider_MotionBlur l "<b><font color=#7DADF9>Motion Blur</font><b>"}
 addUserKnob {6 mb_enable l Enable +STARTLINE}
 addUserKnob {6 Fast l "Fast (Interpolated)" -STARTLINE}
 Fast true
 addUserKnob {3 Samples}
 Samples 6
 addUserKnob {7 Shutter R 0 2}
 Shutter 0.5
 addUserKnob {4 pulldown l "Shutter Offset" M {Centered Start End ""}}
 addUserKnob {20 preview_3d l "3D Preview"}
 addUserKnob {6 Enable3DPreview l "Enable 3D Preview" t "Display a preview of the points in the Nuke 3D view." +STARTLINE}
 Enable3DPreview true
 addUserKnob {41 pointSize l "point size" T PreviewNode.pointSize}
 addUserKnob {41 detail l "point detail" T PreviewNode.detail}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x388e8e00
  label "Output Format Manager"
  note_font_size 22
  xpos -1491
  ypos 149
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x388e8e00
  label "AUX Input"
  note_font_size 22
  xpos -385
  ypos 178
  bdwidth 207
  bdheight 178
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x388e8e00
  label "Point Render"
  note_font_size 22
  xpos -96
  ypos 99
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x388e8e00
  label "Normal Generator\nFor Vertex Normals"
  note_font_size 22
  xpos -616
  ypos 243
  bdwidth 191
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x388e8e00
  label "Ensure output format"
  note_font_size 22
  xpos -622
  ypos -41
  bdwidth 198
  bdheight 135
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x388e8e00
  label "Motion Blur"
  note_font_size 22
  xpos -85
  ypos 526
  bdwidth 193
  bdheight 91
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x388e8e00
  label "Soft Preview"
  note_font_size 22
  xpos -83
  ypos 414
  bdwidth 191
  bdheight 94
 }
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x388e8e00
  label "Final format"
  note_font_size 22
  xpos -84
  ypos 295
  bdwidth 192
  bdheight 95
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0x388e8e00
  label "No Clue =)"
  note_font_size 22
  xpos -385
  ypos -41
  bdwidth 160
  bdheight 87
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Motionblur
  note_font_size 22
  xpos -672
  ypos -781
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x388e8e00
  label "Fast Preview"
  note_font_size 22
  xpos -669
  ypos -971
  bdwidth 254
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0x388e8e00
  label "Nearest Wire Mode Clamp"
  note_font_size 22
  xpos -666
  ypos -1184
  bdwidth 253
  bdheight 111
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label Occlusion
  note_font_size 22
  xpos 208
  ypos 27
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0x388e8e00
  label "Input Camera Container"
  note_font_size 22
  xpos -1215
  ypos 148
  bdwidth 260
  bdheight 198
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0x388e8e00
  label "3D Preview"
  note_font_size 22
  xpos -88
  ypos -45
  bdwidth 207
  bdheight 102
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0x388e8e00
  label "Input Format Manager"
  note_font_size 22
  xpos -526
  ypos -459
  bdwidth 208
  bdheight 97
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x388e8e00
  label FOG
  note_font_size 22
  xpos -602
  ypos -253
  bdwidth 370
  bdheight 152
 }
 Input {
  inputs 0
  name InputPointData
  xpos -584
  ypos -1321
 }
 Dot {
  name Dot4
  xpos -550
  ypos -1234
 }
set N5a784000 [stack 0]
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize fill
  filter Impulse
  black_outside true
  name Reformat5
  xpos -584
  ypos -906
  disable {{!parent.FastPreview==1}}
 }
 Grade {
  white 10
  name Grade2
  xpos -584
  ypos -874
  disable {{!parent.FastPreview}}
 }
 Dot {
  name Dot2
  xpos -550
  ypos -712
 }
set N5a79d000 [stack 0]
 Group {
  name FrameHold3
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -501
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame+1}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot6
  xpos -467
  ypos -659
 }
push $N5a79d000
 Group {
  name FrameHold2
  tile_color 0xb0a45dff
  label "(frame \[value first_frames])"
  xpos -660
  ypos -719
  disable {{1-parent.mb_enable}}
  addUserKnob {20 User}
  addUserKnob {3 first_frames l "first frame"}
  first_frames {{frame}}
  addUserKnob {41 increment T FrameHold2.increment}
  addUserKnob {22 SetCurrentFrame l "Set This Frame" T "nuke.thisNode()\[\"first_frames\"].setValue(nuke.frame())" +STARTLINE}
 }
  Input {
   inputs 0
   name Input1
   xpos -7
   ypos -154
  }
  FrameHold {
   first_frame {{parent.knob.first_frames}}
   name FrameHold2
   xpos -7
   ypos -114
  }
  Output {
   name Output1
   xpos -7
   ypos -14
  }
 end_group
 Dot {
  name Dot5
  xpos -626
  ypos -659
 }
 Dissolve {
  inputs 2
  which {{frame-floor(frame)}}
  name Dissolve1
  xpos -582
  ypos -666
  disable {{1-parent.mb_enable}}
 }
push $N5a79d000
 Switch {
  inputs 2
  which {{parent.Fast}}
  name Switch2
  xpos -582
  ypos -619
 }
 Dot {
  name DataFetch
  label "data fetch\t"
  note_font_color 0xff21ff
  xpos -550
  ypos -513
  addUserKnob {20 User}
  addUserKnob {3 n_particles l "Number of Particles"}
  n_particles {{"\[metadata pointrender/n_points]"}}
  addUserKnob {3 gentype l "Type Of Generator"}
  gentype {{"\[metadata pointrender/gen_type]"}}
  addUserKnob {26 info l "" -STARTLINE T "0 = unknown, 1 = Card, 2 = Sphere, 3 = Grid"}
 }
set N5a7cf000 [stack 0]
 Dot {
  name Dot3
  xpos -635
  ypos -513
 }
 Dot {
  name Dot1
  xpos -635
  ypos 676
 }
 Input {
  inputs 0
  name InputOcclusion
  xpos 238
  ypos 75
  number 2
 }
 Constant {
  inputs 0
  channels rgb
  color 1
  name Empty
  xpos 371
  ypos 139
 }
 Switch {
  inputs 2
  which {{parent.UseOcclusionMap}}
  name Switch1
  xpos 238
  ypos 163
 }
 Input {
  inputs 0
  name Aux
  xpos -324
  ypos 214
  number 3
 }
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat2
  xpos -324
  ypos 238
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop1
  xpos -324
  ypos 275
 }
push $N5a7cf000
 Shuffle {
  in pos
  name Shuffle1
  xpos -584
  ypos -192
 }
set N5a7f8c00 [stack 0]
 Reformat {
  type "to box"
  format "1280 720 0 0 1280 720 1 HD_720"
  box_width {{input.width>Settings_Format.format.width?input.width:Settings_Format.format.width}}
  box_height {{input.height>Settings_Format.format.height?input.height:Settings_Format.format.height}}
  box_fixed true
  resize none
  center false
  filter Impulse
  black_outside true
  name Reformat4
  xpos -584
  ypos 18
 }
 Crop {
  box {0 0 {input.width} {input.height}}
  name Crop2
  xpos -584
  ypos 48
 }
 Dot {
  name Dot8
  xpos -550
  ypos 166
 }
set N5a81dc00 [stack 0]
 Group {
  name Point_Normal2
  tile_color 0x434343ff
  note_font_color 0x55ffffff
  xpos -584
  ypos 311
  disable {{!(renderMode==2&&RenderMode==2)}}
  addUserKnob {20 User}
  addUserKnob {26 info l "" +STARTLINE T "Point Normal v1.0"}
  addUserKnob {26 devider_general l "<b><font color=#7DADF9>General</font><b>"}
  addUserKnob {26 info_1 l "" +STARTLINE T "well, not much to do here =)"}
 }
  Input {
   inputs 0
   name Input1
   xpos 389
   ypos 207
  }
  Shuffle {
   in pos
   name Shuffle1
   xpos 389
   ypos 294
  }
  BlinkScript {
   kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/BasicLight.cpp
   recompileCount 69
   ProgramGroup 1
   KernelDescription "2 \"PointRender3D\" iterate pixelWise d5452fe7b684561fcfa5182d0c789025a037cc4fe4474c24e065e3fa53fcd8ce 2 \"ppos\" Read Random \"dst\" Write Point 9 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"Zoom\" Float 1 AACAPw== \"half Lambert\" Bool 1 AQ== \"light Mode\" Int 1 AAAAAA== \"light_position\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"light_color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== 9 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"zoom\" 1 1 \"halfLambert\" 1 1 \"lightMode\" 1 1 \"lightPos\" 3 1 \"lightcolor\" 3 1 10 \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"namount\" Float 1 1 AAAAAA=="
   kernelSource "inline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}\n\ninline float saturate(float _in)\n\{\n    return max(0.0f,min(1.0f,_in));\n\}\n\ninline float3 reflect(float3 incidence,float3 normal)\n\{\n  return incidence - 2.f * dot(incidence, normal) * normal;\n\}\n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n    \n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    if (fabs(pScreen.x) > canvasWidth || fabs(pScreen.y) > canvasHeight) \n         return false; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eWrite> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    bool halfLambert;\n    int lightMode;\n    float3 lightPos;\n    float3 lightcolor;\n\n\n  local: //Local variables\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n    float namount; //dither amount\n\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(halfLambert, \"half Lambert\", true);\n    defineParam(lightMode, \"light Mode\", 0);\n    defineParam(lightPos,      \"light_position\", float3(0,0,0));  \n    defineParam(lightcolor,      \"light_color\", float3(1.0,1.0,1.0)); \n  \}\n\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n    namount = 0.0001; //dither amount\n  \}\n\n\n\nfloat3 Reconsile3D(float3 _PointPos)\{\n    vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n    int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    return tRaster;\n\}\n\n\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nfloat3 facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos;\n    float4 V0_Sample,V1_Sample,V2_Sample;\n    float3 normal0,normal1,normal2;\n\n    //for area calculation\n    float area;\n    float3 V0,V1,V2;\n    float3 output = float3(0.0f);\n  if (insideX) \{\n    V2_Sample = ppos(pos.x+1,pos.y);\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(pos.x+1,pos.y-1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n            float3 Normal = CalculateVertexNormals(_vWorld,V2_wPos,V1_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          //write output\n          output +=  float3(Normal.x,Normal.y,Normal.z);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,pos.y+1);\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (V1_Sample.w != 0.0f) \{ \n          float3 Normal = CalculateVertexNormals(_vWorld,V1_wPos,V2_wPos);\n\n            //Calculate Area for density:\n            V0 = screen_pos;\n            V1 = V1_Pos;\n            V2 = V2_Pos;\n            V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n            area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n          output += float3(Normal.x,Normal.y,Normal.z);\n\n        \}\n      \}\n    \}\n  \}\n  return output;\n\}\n\n\n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 hitNormal = cross((V1 - V0),(V2 - V0)); \n        return hitNormal;\n\}\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float3 output = float3(0.0f);\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float3 point_pos = float3(_sample.x,_sample.y,_sample.z);\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n      dst() = float4(0.0f);\n      output+=facet_render(pos,float3(_sample.x,_sample.y,_sample.z))*2.0f;\n      _sample = ppos(pos.x-1,pos.y); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x-1,pos.y+1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x-1,pos.y+1),float3(_sample.x,_sample.y,_sample.z));\n\n      _sample = ppos(pos.x,pos.y-1); //Get the XYZ Coordinates\n      output+=facet_render(int2(pos.x,pos.y-1),float3(_sample.x,_sample.y,_sample.z));\n\n      output = normalize(output);\n      float3 normal = -output;\n\n      \n\n\n      dst() = float4(normal.x,normal.y,normal.z,1.0f);\n    \}\n  \} //----> process\n\};\n"
   rebuild ""
   "PointRender3D_half Lambert" false
   "PointRender3D_light Mode" {{parent.LightFalloff}}
   PointRender3D_light_position {{parent.Axis1.translate} {parent.Axis1.translate} {parent.Axis1.translate}}
   PointRender3D_light_color {{parent.LightColor} {parent.LightColor} {parent.LightColor}}
   rebuild_finalise ""
   name BlinkScript1
   xpos 389
   ypos 344
  }
  Grade {
   multiply 0.5
   add 0.5
   black_clamp false
   name Grade1
   xpos 389
   ypos 376
   disable true
  }
  Output {
   name Output1
   xpos 389
   ypos 459
  }
  Axis2 {
   inputs 0
   translate {0.5 0.5 0.5}
   name Axis1
   xpos 661
   ypos 318
  }
 end_group
 Switch {
  inputs 2
  which {{parent.connect_aux}}
  name Switch3
  xpos -324
  ypos 311
 }
push $N5a7f8c00
 Expression {
  temp_name0 xd
  temp_expr0 red-Camera1.world_matrix.3
  temp_name1 yd
  temp_expr1 green-Camera1.world_matrix.7
  temp_name2 zd
  temp_expr2 blue-Camera1.world_matrix.11
  temp_name3 Distance
  temp_expr3 "sqrt(xd*xd + yd*yd + zd*zd)"
  expr0 Distance
  expr1 Distance
  expr2 Distance
  expr3 Distance
  name Expression1
  xpos -456
  ypos -192
 }
 Grade {
  channels rgba
  blackpoint {{parent.FogFar}}
  whitepoint {{parent.FogNear}}
  gamma {{1/(parent.FogExponent+0.000000001)}}
  white_clamp true
  name Grade1
  xpos -456
  ypos -168
 }
push $N5a7cf000
 Dot {
  name Dot7
  xpos -307
  ypos -513
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -341
  ypos -168
  disable {{!parent.Fog}}
 }
 Shuffle {
  name Shuffle3
  xpos -341
  ypos 8
 }
set N5a850c00 [stack 0]
push $N5a81dc00
 BlinkScript {
  inputs 4
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Render/3D_PointRender_v15.cpp
  recompileCount 792
  ProgramGroup 1
  KernelDescription "2 \"PointRender3D\" iterate pixelWise e0ecbbf4cba39730471d23bc9f9ec846fcae1bbb869971a11b15641cf6fd5620 5 \"ppos\" Read Random \"src\" Read Random \"normals\" Read Random \"occlusion\" Read Random \"dst\" Write Random 48 \"cam_Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"focallength\" Float 1 AAA4QQ== \"hapeture\" Float 1 ppvEQQ== \"format\" Int 2 AAgAAAAIAAA= \"vertexformat\" Int 2 CgAAAAoAAAA= \"Zoom\" Float 1 AACAPw== \"Filtering Method\" Int 1 AQAAAA== \"_alphaMultiplier\" Float 1 AACAPw== \"_pointRender\" Bool 1 AQ== \"_wireRender\" Bool 1 AQ== \"_facetRender\" Bool 1 AQ== \"_maxLDistance\" Float 1 AACAPw== \"_maxLConnections\" Int 1 AQAAAA== \"_maxPlexType\" Int 1 AAAAAA== \"_plexLinedefXY\" Bool 1 AA== \"_plexLinedefX\" Bool 1 AA== \"_plexLinedefY\" Bool 1 AA== \"_plexLinedefXtoY\" Bool 1 AA== \"_plexLinedefAUX\" Bool 1 AA== \"_plexConnectX\" Bool 1 AA== \"_plexConnectY\" Bool 1 AA== \"_L_gamma\" Float 1 AACAPw== \"Enable Depth of Field\" Bool 1 AA== \"samples\" Int 1 AwAAAA== \"rings\" Int 1 BQAAAA== \"focalDepth\" Float 1 AACAPw== \"_depthOfField\" Float 1 AACAQA== \"_depthMult\" Float 1 zczMPQ== \"_maxDofSize\" Float 1 AAAAQQ== \"dof_aspect\" Float 1 AACAPw== \"dof_threshold\" Float 1 AACAPw== \"dof_gain\" Float 1 AAAAAA== \"dof_bias\" Float 1 AAAAwA== \"dof_fringe\" Float 1 AAAAAA== \"_flatshading\" Bool 1 AQ== \"_backfacing\" Bool 1 AQ== \"_frontfacing\" Bool 1 AQ== \"_vertexMode\" Int 1 AAAAAA== \"_depthBuffer\" Bool 1 AQ== \"_texoffset\" Float 2 AAAAPwAAAD8= \"_pointSize\" Int 1 AQAAAA== \"_gaussigma\" Float 1 AACAPw== \"_depthOcclusion\" Bool 1 AQ== \"depthMultiplier\" Float 1 AACAPw== \"_maxLineSteps\" Float 1 AAB6RQ== \"_lineOffset\" Float 1 AACAPw== \"_lineInMultiplier\" Float 1 AACAPw== \"_lineOutMultiplier\" Float 1 AACAPw== 48 \"cam_Matrix\" 16 1 \"cam_Focal\" 1 1 \"cam_Hapeture\" 1 1 \"WHformat\" 2 1 \"Vformat\" 2 1 \"zoom\" 1 1 \"_filtering\" 1 1 \"_alphaMultiplier\" 1 1 \"_pointRender\" 1 1 \"_wireRender\" 1 1 \"_facetRender\" 1 1 \"_maxPlexDistance\" 1 1 \"_maxPlexConnections\" 1 1 \"_maxPlexType\" 1 1 \"_plexLinedefXY\" 1 1 \"_plexLinedefX\" 1 1 \"_plexLinedefY\" 1 1 \"_plexLinedefXtoY\" 1 1 \"_plexLinedefAUX\" 1 1 \"_plexConnectX\" 1 1 \"_plexConnectY\" 1 1 \"_plex_gamma\" 1 1 \"_dof_enable\" 1 1 \"_dof_samples\" 1 1 \"_dof_rings\" 1 1 \"focalDepth\" 1 1 \"_depthOfField\" 1 1 \"_depthMult\" 1 1 \"_maxDofSize\" 1 1 \"dof_aspect\" 1 1 \"dof_threshold\" 1 1 \"dof_gain\" 1 1 \"dof_bias\" 1 1 \"dof_fringe\" 1 1 \"_flatshading\" 1 1 \"_backfacing\" 1 1 \"_frontfacing\" 1 1 \"_vertexMode\" 1 1 \"_depthBuffer\" 1 1 \"_texoffset\" 2 1 \"_pointSize\" 1 1 \"_gaussigma\" 1 1 \"_depthOcclusion\" 1 1 \"depthMultiplier\" 1 1 \"_maxLineSteps\" 1 1 \"_lineOffset\" 1 1 \"_lineInMultiplier\" 1 1 \"_lineOutMultiplier\" 1 1 10 \"max_line_connections\" Int 1 1 AAAAAA== \"vRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"pRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"tRaster\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"vWorld\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"canvasWidth\" Float 1 1 AAAAAA== \"canvasHeight\" Float 1 1 AAAAAA== \"matrixData\" Float 1 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraToWorld\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"worldToCamera\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "//Some basic generic functions.\ninline float Frac(float a_X)\n\{\n    return a_X-floor(a_X);\n\}\n\ninline float3 Cross(float3 A,float3 B)\n\{\n    return float3(A.y*B.z - A.z*B.y,A.z*B.x - A.x*B.z,A.x*B.y - A.y*B.x);\n\}\n\ninline float Fmax(float a_X,float b_X,float c_X)\n\{\n    return max(c_X,max(a_X,b_X));\n\}\ninline float Fmin(float a_X,float b_X,float c_X)\n\{\n    return min(c_X,min(a_X,b_X));\n\}     \n\ninline float3 mix(float3 _X,float3 _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}\ninline float mix(float _X,float _Y,float _A)\{\n  return _X*(1.0f-_A)+_Y*_A;\n\}                                                                                              \n\n//This function is used to multiply a float3 by a matrix4x4\ninline float3 multVecMatrix( float3 src, float4x4 matrix)\n\{\n    float   x,y,z,w;\n\n    x = src\[0]*matrix\[0]\[0] + src\[1]*matrix\[1]\[0] +\n    src\[2]*matrix\[2]\[0] + matrix\[3]\[0];\n    y = src\[0]*matrix\[0]\[1] + src\[1]*matrix\[1]\[1] +\n    src\[2]*matrix\[2]\[1] + matrix\[3]\[1];\n    z = src\[0]*matrix\[0]\[2] + src\[1]*matrix\[1]\[2] +\n    src\[2]*matrix\[2]\[2] + matrix\[3]\[2];\n    w = src\[0]*matrix\[0]\[3] + src\[1]*matrix\[1]\[3] +\n    src\[2]*matrix\[2]\[3] + matrix\[3]\[3];\n    \n    return float3(x/w, y/w, z/w);\n\}\n\n//This function is used to calculate the screenspace coordinates.\ninline bool computePixelCoordinates( \n    const float3 pWorld, \n    float3 &pRaster, \n    const float4x4 &worldToCamera, \n    const float &canvasWidth, \n    const float &canvasHeight, \n    const int &imageWidth, \n    const int &imageHeight\n) \n\{ \n    float3 pCamera; \n    pCamera = multVecMatrix(pWorld, worldToCamera); \n    float2 pScreen; \n    pScreen.x = pCamera.x / -pCamera.z; \n    pScreen.y = pCamera.y / -pCamera.z; \n    float2 pNDC; \n    pNDC.x = (pScreen.x + canvasWidth * 0.5f) / canvasWidth; \n    pNDC.y = (pScreen.y + canvasHeight * 0.5f) / canvasHeight; \n    pRaster.x = (pNDC.x * imageWidth); \n    pRaster.y = ((pNDC.y) * imageHeight); \n    pRaster.z = -pCamera.z; \n    if (pRaster.x < 0.0f || pRaster.x > imageWidth || \n       pRaster.y < 0.0f || pRaster.y > imageHeight || pRaster.z < 0.0f) \{\n       return false;  \n    \}\n    return true;\n\} \n\n\nkernel PointRender3D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> ppos;    //The point position map\n  Image<eRead, eAccessRandom, eEdgeClamped> src;     //The texture map\n  Image<eRead, eAccessRandom, eEdgeClamped> normals;     //The texture map  \n  Image<eRead, eAccessRandom, eEdgeClamped> occlusion;     //The texture map \n  Image<eWrite, eAccessRandom> dst;                 //the output image\n\n  param: //Parameters available to the user\n    float4x4 cam_Matrix;    //The world matrix of the camera\n    float cam_Focal;        //The focal length of the camera\n    float cam_Hapeture;     //The horizontal apeture of the camera\n    int2 WHformat,Vformat;          //The format of the output image\n    float zoom;             //A \"post\" zoom function\n    int _filtering;        //Filter method\n    float _alphaMultiplier; //Additive multiplier\n    bool _pointRender,_wireRender,_facetRender;\n    float _maxPlexDistance; //Additive multiplier\n    int _maxPlexConnections;\n    int _maxPlexType; // 0==Grid, -1==Nearest\n    bool _plexLinedefXY,_plexLinedefX,_plexLinedefY,_plexLinedefXtoY,_plexLinedefAUX; // Define what connections NOT to include\n    bool _plexConnectX,_plexConnectY; //Connect from the edge of x to 0, or edge of y to 0, usually for spheres\n    float _plex_gamma; //The threshold making shorter paths bright and longer paths dark\n    bool _dof_enable; // Enable DOF\n    int _dof_samples; // How many samples per DOF ring\n    int _dof_rings; // How many rings \n    float focalDepth,_depthOfField,_depthMult,_maxDofSize; //DOF Settings\n    float dof_aspect; //Pixel aspect ratio\n    float dof_threshold;\n    float dof_gain;\n    float dof_bias; //bokeh edge bias\n    float dof_fringe; //bokeh chromatic aberration/fringing\n    bool _flatshading,_backfacing,_frontfacing; //Vertex rendering settings\n    int _vertexMode;  //The rendering output mode, (think AOV)\n    bool _depthBuffer; //Non-additive, only render front most pixel\n    float2 _texoffset;\n    int _pointSize;\n    float _gaussigma;\n    bool _depthOcclusion;\n    float depthMultiplier;\n    float _maxLineSteps; //cap the line length to avoid process lock\n    float _lineOffset; //Alow you to shrink or extend the lines\n    float _lineInMultiplier,_lineOutMultiplier; //Control the brightness of the wires at the tips.\n\n  local: //Local variables\n    int max_line_connections;\n    float3 vRaster;\n    float3 pRaster;\n    float3 tRaster;    \n    float3 vWorld;\n    float canvasWidth;\n    float canvasHeight; \n    float matrixData\[4]\[4];\n    float4x4 cameraToWorld;\n    float4x4 worldToCamera;\n\n  void define() \{\n    defineParam(cam_Matrix, \"cam_Matrix\", float4x4( 1.0f,0.0f,0.0f,0.0f,\n                                                    0.0f,1.0f,0.0f,0.0f,\n                                                    0.0f,0.0f,1.0f,0.0f,\n                                                    0.0f,0.0f,0.0f,1.0f));\n    defineParam(cam_Focal,      \"focallength\", 11.5f);\n    defineParam(cam_Hapeture,      \"hapeture\", 24.576f);\n    defineParam(WHformat,      \"format\", int2(2048,2048));\n    defineParam(Vformat,      \"vertexformat\", int2(10,10));\n    defineParam(zoom, \"Zoom\", 1.0f);\n    defineParam(_filtering, \"Filtering Method\", 1); \n    defineParam(_alphaMultiplier, \"_alphaMultiplier\", 1.0f);     \n    defineParam(_pointRender, \"_pointRender\", true);  \n    defineParam(_wireRender, \"_wireRender\", true);\n    defineParam(_facetRender, \"_facetRender\", true);\n    defineParam(_maxPlexDistance, \"_maxLDistance\", 1.0f);    \n    defineParam(_maxPlexConnections, \"_maxLConnections\", 1);    \n    defineParam(_maxPlexType, \"_maxPlexType\", 0); \n    defineParam(_plexLinedefXY, \"_plexLinedefXY\", false);      \n    defineParam(_plexLinedefXtoY, \"_plexLinedefXtoY\", false); //NYI\n    defineParam(_plexLinedefAUX, \"_plexLinedefAUX\", false); \n    defineParam(_plexLinedefX, \"_plexLinedefX\", false);  \n    defineParam(_plexLinedefY, \"_plexLinedefY\", false);  \n    defineParam(_plexConnectX, \"_plexConnectX\", false);      \n    defineParam(_plexConnectY, \"_plexConnectY\", false);   \n    defineParam(_plex_gamma, \"_L_gamma\", 1.0f);\n    //DOF SETTINGS   \n    defineParam(_dof_enable, \"Enable Depth of Field\", false);   \n    defineParam(_dof_samples, \"samples\", 3);    \n    defineParam(_dof_rings, \"rings\", 5);   \n    defineParam(focalDepth, \"focalDepth\", 1.0f);  \n    defineParam(_depthOfField, \"_depthOfField\", 4.0f);  \n    defineParam(_depthMult, \"_depthMult\", 0.1f);  \n    defineParam(_maxDofSize, \"_maxDofSize\", 8.0f);  \n    defineParam(dof_aspect, \"dof_aspect\", 1.0f);  \n    defineParam(dof_threshold, \"dof_threshold\", 1.0f);  \n    defineParam(dof_gain, \"dof_gain\", 0.0f);  \n    defineParam(dof_bias, \"dof_bias\", -2.0f);  \n    defineParam(dof_fringe, \"dof_fringe\", 0.0f); \n    //SHADING SETTINGS \n    defineParam(_flatshading, \"_flatshading\", true);  \n    defineParam(_vertexMode, \"_vertexMode\", 0);  \n    defineParam(_backfacing, \"_backfacing\", true);    \n    defineParam(_frontfacing, \"_frontfacing\", true);        \n    defineParam(_depthBuffer, \"_depthBuffer\", true);  \n    defineParam(_texoffset, \"_texoffset\", float2(0.5f,0.5f)); \n    defineParam(_pointSize, \"_pointSize\", 1); \n    defineParam(_gaussigma, \"_gaussigma\", 1.0f); \n    defineParam(_depthOcclusion, \"_depthOcclusion\", true); \n    defineParam(depthMultiplier, \"depthMultiplier\", 1.0f); \n    defineParam(_maxLineSteps, \"_maxLineSteps\", 4000.0f); \n    defineParam(_lineOffset, \"_lineOffset\", 1.0f); \n    defineParam(_lineInMultiplier, \"_lineInMultiplier\", 1.0f);   \n    defineParam(_lineOutMultiplier, \"_lineOutMultiplier\", 1.0f);     \n\n  \}\n\n  //The init() function is run before any calls to process().\n  void init() \{\n    max_line_connections = 80;\n    canvasWidth = ((cam_Hapeture)/cam_Focal);\n    canvasHeight = ((cam_Hapeture)/cam_Focal)*float(float(WHformat.y)/float(WHformat.x)); \n    float matrixData\[] = \{cam_Matrix\[0]\[0], cam_Matrix\[1]\[0], cam_Matrix\[2]\[0], cam_Matrix\[3]\[0], \n                          cam_Matrix\[0]\[1], cam_Matrix\[1]\[1], cam_Matrix\[2]\[1], cam_Matrix\[3]\[1], \n                          cam_Matrix\[0]\[2], cam_Matrix\[1]\[2], cam_Matrix\[2]\[2], cam_Matrix\[3]\[2], \n                          cam_Matrix\[0]\[3], cam_Matrix\[1]\[3], cam_Matrix\[2]\[3], cam_Matrix\[3]\[3]\};\n    cameraToWorld.setArray(matrixData); //This is a workaround. Due to the buggy matrix implementation, we pass the matrix on from another structure.\n    worldToCamera = cameraToWorld.invert();\n  \}\n\n  //Convert a 3d point position into a 2d raster position.\n  float3 Reconsile3D(float3 _PointPos)\{\n      vWorld = float3(_PointPos.x,_PointPos.y,_PointPos.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, tRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      return tRaster;\n  \}\n\n//------------------------------\n//-------DRAW FUNCTIONS---------\n//------------------------------\n  //Write pixels to output.\n  void writepixel(float posx,float posy, float4 color,int index,float weight=1.0f)\n  \{ \n      if (_depthOcclusion)\{\n        float4 depthSample = occlusion(posx,posy);\n        if (depthSample.x<=vRaster.z && depthSample.w>0.0f)\{\n\n          float depth = (vRaster.z-depthSample.x);\n          color = color*(1.0f-depthSample.w);\n          color = color / (((depth*depth)*depthMultiplier)+1.0f);\n          //return;\n        \}\n      \}\n      float4 finalOutput; //This is used to store the final output\n      float4 dstSample; //This is used to store a sample of the destination\n      if ( dst.bounds.inside( posx, posy ) ) \{ //Test if the pixel written to is inside the output image. \n        if (_depthBuffer) \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          if ((dstSample.w>color.w)||dstSample.w==0.0f) \{\n            dst(posx,posy) = color;\n          \}\n        \}\n        else \{\n          dstSample = (float4)dst(posx,posy); //Sample the destination image\n          finalOutput = dstSample + (color*_alphaMultiplier*weight);\n          finalOutput.w = dstSample.w + ((color.w*_alphaMultiplier*weight));\n\n          finalOutput.w = (dstSample.w + ((color.w*_alphaMultiplier*weight)))-(dstSample.w * ((color.w*_alphaMultiplier*weight)));\n\n          dst(posx,posy) = finalOutput;\n        \}\n      \} \n  \}\n\n  //Calculate a Bilinear Plot\n  void bilinear_Plot(float2 temppos,float4 color,int index)\n  \{\n    float2 p;\n    p.x=Frac(temppos.x);\n    p.y=Frac(temppos.y);\n    float weights\[] = \{(1.0f-p.x)*(1.0f-p.y), p.x*(1.0f-p.y), (1.0f-p.x)*p.y, p.x*p.y\};\n    int2 _position = int2(floor(temppos.x)-0,floor(temppos.y)-0); \n    writepixel(_position.x,_position.y,color,index,weights\[0]);\n    writepixel(_position.x+1,_position.y,color,index,weights\[1]);\n    writepixel(_position.x,_position.y+1,color,index,weights\[2]);\n    writepixel(_position.x+1,_position.y+1,color,index,weights\[3]);\n  \}\n\n  //NYI, unused!\n  void gaussian(float2 temppos,float4 color,int index)\{\n    float in_x = temppos.x;\n    float in_y = temppos.y;\n    int kernelSize = (_pointSize+1)*2;\n    int subsize = (kernelSize /2)-1;\n    float gKernel\[64]\[64];\n    float sigma = _gaussigma;\n    float intSigma = float(_pointSize);\n    float r, s = intSigma * sigma * sigma;\n\n    float sum = 0.0f;\n\n    // generate 5x5 kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            r = float(sqrt(x*x + y*y));\n            gKernel\[x + subsize]\[y + subsize] = (exp(-(r*r)/s))/(3.141592654f * s);\n            sum += gKernel\[x + subsize]\[y + subsize];\n        \}\n    \}\n\n    // normalize the Kernel\n    for (int x = -subsize; x <= subsize; x++)\n    \{\n        for(int y = -subsize; y <= subsize; y++)\n        \{\n            gKernel\[x + subsize]\[y + subsize] /= sum;\n            writepixel(in_x+x,in_y+y,color,index,gKernel\[x + subsize]\[y + subsize]);\n        \}\n    \}\n  \}\n\n//-------------------------------------\n// DrawLine\n// ----------\n// Draw a line between two points, \n// x,y being 2d screenspace pos and z being depth.\n//-------------------------------------\n  void DrawLine(float3 origin, float3 endpoint,float4 _colorA,float4 _colorB) \{\n    float4 _color;\n    float3 delta = origin-endpoint;\n    float3 curPoint = origin;\n    float mag = sqrt(delta.x*delta.x+delta.y*delta.y);\n    mag = min(mag,_maxLineSteps); //Lets not go crazy, we cap it at 10.000 to avoid insane unwated processing time \n    for( float a = 0; a < mag*_lineOffset; a = a + 1.0f )\{\n      curPoint -= (delta/mag);\n      _color = (_colorA*(1.0f-(a/mag*1.0f)))+(_colorB*(a/mag*1.00f));\n      if (_dof_enable)\{\n        Bokeh(curPoint,_color);\n      \}\n      else \{\n        bilinear_Plot(float2(curPoint.x,curPoint.y),_color,1);\n      \}\n      \n    \}\n  \}\n\n//-------------------------------------\n// Point_Render\n//-------------------------------------\nvoid point_render(int2 pos, float3 screen_pos)\{\n  float4 color = src(pos.x,pos.y);\n\n  if (_filtering == 1)\{\n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        bilinear_Plot(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  /*\n  //THIS PART NEEDS TO BE RE-WRITTEN.\n  else if (_filtering == 2)\{ \n      if (_dof_enable)\{\n        Bokeh(screen_pos,color);\n      \}\n      else \{\n        gaussian(float2(screen_pos.x,screen_pos.y),color,1);\n      \}\n  \}\n  */\n  else \{\n      int2 _position = int2(floor(screen_pos.x),floor(screen_pos.y)); \n      if (_depthBuffer) \{color.w = screen_pos.z;\}\n      writepixel(_position.x,_position.y, color,1,1.0f); //OutputSample\n  \}\n\n\}\n\n//-------------------------------------\n// Facet_Render\n//-------------------------------------\n//This function is used to calculate what triangels to draw\nvoid facet_render(int2 pos, float3 _vWorld)\{\n\n    float3 screen_pos = Reconsile3D(_vWorld);\n\n    bool insideX = ppos.bounds.inside(pos.x+1,pos.y );\n    bool insideY = ppos.bounds.inside(pos.x+1,pos.y-1 );\n    bool insideYtop = ppos.bounds.inside(pos.x,pos.y+1);\n    float2 fpos = float2(pos.x,pos.y);\n    float3 V1_Pos,V2_Pos,V1_wPos,V2_wPos,V0_N,V1_N,V2_N;\n    float2 V0_ST,V1_ST,V2_ST;\n    float4 V1_Sample,V2_Sample;\n    float4 _tn;\n    float3 normal0,normal1,normal2;\n    float2 UV_Format = float2(Vformat.x,Vformat.y);\n\n\n    int2 P0 = int2(pos.x-1,pos.y-1);\n    int2 P1 = int2(pos.x+1,pos.y+1);\n    if (_plexConnectX && pos.x == int(Vformat.x))\{\n      insideX == true;\n      P1 = int2(0.0f,pos.y+1);\n    \}\n    if (_plexConnectY && pos.y == int(Vformat.y))\{\n      insideYtop == true;\n      P1 = int2(pos.x+1,0);\n    \} \n\n    if (_plexConnectY && pos.y == 0)\{\n      insideY == true;\n      P0 = int2(pos.x-1,int(UV_Format.y));\n    \} \n\n    if (!_flatshading) \{\n      _tn = normals(pos.x,pos.y);\n      V0_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n    V0_ST = float2(pos.x,pos.y)/UV_Format;\n\n  if (insideX) \{\n    V2_Sample = ppos(P1.x,pos.y);\n    V2_ST = float2(P1.x,pos.y)/UV_Format;\n    V2_wPos = float3(V2_Sample.x,V2_Sample.y,V2_Sample.z);\n    V2_Pos = Reconsile3D(V2_wPos);\n    if (!_flatshading) \{\n      _tn = normals(P1.x,pos.y);\n      V2_N =float3(_tn.x,_tn.y,_tn.z);\n    \}\n        \n\n    if (V2_Sample.w != 0.0f) \{ \n\n      if (insideY) \{\n        V1_Sample = ppos(P1.x,P0.y);\n        V1_ST = float2(P1.x,P0.y)/UV_Format;\n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(P1.x,P0.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}\n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V2_Pos,V1_Pos,_vWorld,V2_wPos,V1_wPos,V0_N,V2_N,V1_N,V0_ST,V2_ST,V1_ST);\n        \}\n      \}\n      if (insideYtop) \{\n        V1_Sample = ppos(pos.x,P1.y);\n        V1_ST = float2(pos.x,P1.y)/UV_Format;        \n        V1_wPos = float3(V1_Sample.x,V1_Sample.y,V1_Sample.z);\n        V1_Pos = Reconsile3D(V1_wPos);\n        if (!_flatshading) \{\n          _tn = normals(pos.x,P1.y);\n          V1_N =float3(_tn.x,_tn.y,_tn.z);\n        \}        \n        if (V1_Sample.w != 0.0f) \{ \n          DrawTriangle(screen_pos,V1_Pos,V2_Pos,_vWorld,V1_wPos,V2_wPos,V0_N,V1_N,V2_N,V0_ST,V1_ST,V2_ST);\n        \}\n      \}\n    \}\n  \}\n\}\n\n\n\n//This function will calculate if pixel C is inside the triangle\nfloat edgeFunction(float3 a, float3 b, float3 c) \n\{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n\} \n\nfloat3 CalculateSurfaceNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat3 CalculateVertexNormals(float3 V0, float3 V1, float3 V2)\n\{\n        float3 v0 = V0; \n        float3 v1 = V1; \n        float3 v2 = V2; \n        float3 hitNormal = cross((v1 - v0),(v2 - v0)); \n        return normalize(hitNormal);\n\}\n\nfloat Distance(float3 _a,float3 _b)\n\{\n          float xd = _a.x - _b.x;\n          float yd = _a.y - _b.y;\n          float zd = _a.z - _b.z;\n          return sqrt(xd*xd + yd*yd + zd*zd);\n\}\n\nvoid DrawTriangle(float3 V0, float3 V1, float3 V2,float3 WP0, float3 WP1, float3 WP2,float3 N0, float3 N1, float3 N2, float2 st0,float2 st1,float2 st2) \{\n\n  // Precompute reciprocal of vertex z-coordinate \n  V0.z = 1.0f / V0.z, V1.z = 1.0f / V1.z, V2.z = 1.0f / V2.z; \n\n  float2 st0n = st0 * V0.z;\n  float2 st1n = st1 * V1.z; \n  float2 st2n = st2 * V2.z; //Normal version of ST\n\n  bool inside; \n  float X0 = Fmin(V0.x,V1.x,V2.x)-1.0f;\n  float X1 = Fmax(V0.x,V1.x,V2.x)+1.0f;\n  float Y0 = Fmin(V0.y,V1.y,V2.y)-1.0f;\n  float Y1 = Fmax(V0.y,V1.y,V2.y)+1.0f;\n  float area = edgeFunction(V2, V1, V0);\n\n\n  float2 sampos = float2(st0.x*float(Vformat.x),st0.y*float(Vformat.y));\n  float4 text0 = src(sampos.x,sampos.y);\n  sampos = float2(st1.x*float(Vformat.x),st1.y*float(Vformat.y));\n  float4 text1 = src(sampos.x,sampos.y);\n  sampos = float2(st2.x*float(Vformat.x),st2.y*float(Vformat.y));  //Why do we have to do this? =(\n  float4 text2 = src(sampos.x,sampos.y);\n  sampos = float2(min(min(st0.x,st1.x),st2.x)*float(Vformat.x),min(min(st0.y,st1.y),st2.y)*float(Vformat.y));\n  float4 text3 = src(sampos.x,sampos.y);\n\n\n  for( int x = X0; x < X1 ; x++) \{\n    for( int y = Y0; y < Y1 ; y++) \{\n      float3 pixelSample(x + _texoffset.x, y + _texoffset.y,0.0f); \n\n      //This is the part where we test if the current pixel is inside the triangle\n      //We check both for front facing and back faing options\n      float w0 = edgeFunction(V1, V0, pixelSample); //Front Facing\n      float w1 = edgeFunction(V2, V1, pixelSample); \n      float w2 = edgeFunction(V0, V2, pixelSample); \n      float w3 = edgeFunction(V0, V1, pixelSample); //Back Facing\n      float w4 = edgeFunction(V1, V2, pixelSample); \n      float w5 = edgeFunction(V2, V0, pixelSample);\n\n      //writepixel(x,y, float4(w1),1,1.0f);\n      if ((w0 >= 0 && w1 >= 0 && w2 >= 0 && _frontfacing) || (w3 >= 0 && w4 >= 0 && w5 >= 0 && _backfacing)) \{ //The curent pixel is inside the triangle\n\n       // calculate vectors from point f to vertices p1, p2 and p3:\n       float3 f1 = V0-pixelSample;\n       float3 f2 = V1-pixelSample;\n       float3 f3 = V2-pixelSample;\n       // calculate the areas and factors (order of parameters doesn't matter):\n       float a = length(cross(V0-V1,V0-V2 )); // main triangle area a\n       area = length(V0-V1)+length(V0-V2)+length(V1-V2);\n\n        w0 /= area; \n        w1 /= area; \n        w2 /= area; \n\n        w3 /= area; \n        w4 /= area; \n        w5 /= area; \n\n       float a1 = length(cross(f2, f3)) / a; // p1's triangle area / a\n       float a2 = length(cross(f3, f1)) / a; // p2's triangle area / a \n       float a3 = length(cross(f1, f2)) / a; // p3's triangle area / a\n       float a_magnitude = a1+a2+a3;\n       a1 = a1/a_magnitude;\n       a2 = a2/a_magnitude;\n       a3 = a3/a_magnitude;\n       float z = 1.0f / (V0.z * a1 + V1.z * a2 + V2.z * a3); \n\n\n        // find the uv corresponding to point f (uv1/uv2/uv3 are associated to p1/p2/p3):\n        float2 uv = st0 * a1 + st1 * a2 + st2 * a3;\n        float2 st = st0 * w0 + st1 * w1 + st2 * w2; \n        st *= z;      \n\n\n        //Calculate normals. Eighter we have flat shading, else we calculate a normal per pixel\n        float3 normalB;\n        if (_flatshading) \{\n          normalB = CalculateSurfaceNormals(WP0,WP1,WP2);\n\n        \}\n        else \{\n          float3 c0 = N2/float3(V0.z); \n          float3 c1 = N0/float3(V1.z); \n          float3 c2 = N1/float3(V2.z);  \n\n          normalB.x = w0 * c0.x + w1 * c1.x + w2 * c2.x; \n          normalB.y = w0 * c0.y + w1 * c1.y + w2 * c2.y; \n          normalB.z = w0 * c0.z + w1 * c1.z + w2 * c2.z; \n\n          normalB.x *= z, normalB.y *= z, normalB.z *= z; \n        \}\n        normalB = normalize(normalB);\n\n        //CALCULATE THE OBJECT TEXTURE COORDINATES\n        float zn = 1.0f / (V0.z * w0 + V1.z * w1 + V2.z * w2); \n        st = st0n * w0 + st1n * w1 + st2n * w2; \n        st *= zn;   \n        //--END \n\n        float3 Wpos = WP0*a1 + WP1*a2 + WP2*a3; //World Position.\n        float3 ViewNormal = normalize(float3(cameraToWorld\[3]\[0],cameraToWorld\[3]\[1],cameraToWorld\[3]\[2])-Wpos);\n\n        float nDotView =  dot(normalB,ViewNormal);\n        nDotView = 1.0f-fabs(nDotView); //make sure that the view normal ramps back around when doing backface\n        float4 tempout;\n\n        //Flatshading or regular?\n        if (!_flatshading) \{\n          tempout = text0 * a1 + text1 * a2 + text2 * a3; \n        \}\n        else\{\n          tempout = text3;\n        \}\n\n        //Additional Render Modes\n        if (_vertexMode == 1)\{\n          tempout = float4(a1,a2,a3,1.0f);\n        \}\n        else if (_vertexMode == 2)\{\n          tempout = float4(normalB.x,normalB.y,normalB.z,1.0f);\n        \}\n        else if (_vertexMode == 3)\{\n          tempout = float4(nDotView,nDotView,nDotView,1.0f);\n        \}\n        else if (_vertexMode == 4)\{\n          tempout = float4(uv.x,uv.y,0.0f,1.0f);\n        \}       \n        else if (_vertexMode == 5)\{\n          tempout = float4(st.x,st.y,0.0f,1.0f);\n        \}               \n        else if (_vertexMode == 6)\{\n          tempout = float4(ViewNormal.x,ViewNormal.y,ViewNormal.z,1.0f);\n        \}             \n        else if (_vertexMode == 7)\{\n          tempout = float4(Wpos.x,Wpos.y,Wpos.z,1.0f);\n        \}   \n\n        if (_depthBuffer)\{\n          writepixel(x,y, float4(tempout.x,tempout.y,tempout.z,z),1,1.0f);  \n        \}\n        else \{\n          if (_dof_enable)\{\n            Bokeh(float3(x,y,z),float4(tempout.x,tempout.y,tempout.z,z));\n          \}\n          else \{\n            bilinear_Plot(float2(x,y),float4(tempout.x,tempout.y,tempout.z,z),1);\n          \}\n        \}\n\n      \}  \n\n    \}\n  \}\n\}\n\n//-------------------------------------\n// Wire_Render\n//-------------------------------------\nvoid wire_render(int2 pos) \{\n  float4 temp = float4(0.0f,0.0f,0.0f,FLT_MAX);\n  float4 wire_ref_sample;\n  int2 tempXY = int2(0,0);\n  float4 plexlist\[11] = \{temp,temp,temp,temp,temp,temp,temp,temp,temp,temp,temp\}; \n  int2 plexlistXY\[11] = \{tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY,tempXY\};\n  int plex_count = 0; //We use this to figure how many points that should connect.\n  float plex_dist;\n  float3 plex_position,plex_position_b;\n  float4 temp_pos, temp_pos_b; //Temporary Position Containers\n  if (_maxPlexType == -1) \{ //Used for random connection types\n    for( int x = 0; x < max_line_connections ; x++)\{ //THIS 80 NUMBER IS THE LIMIT TO AVOID TOO SLOW PROCESSING!\n      for( int y = 0; y < max_line_connections ; y++)\{\n        wire_ref_sample = ppos(x,y);\n        if (wire_ref_sample.w != 0.0f && pos.x!=x && pos.y != y) \{ \n          plex_position = float3(wire_ref_sample.x,wire_ref_sample.y,wire_ref_sample.z)*(zoom);\n          float xd = plex_position.x - vWorld.x;\n          float yd = plex_position.y - vWorld.y;\n          float zd = plex_position.z - vWorld.z;\n          float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n          if (plex_dist<_maxPlexDistance)\{\n            plex_count = min(10,plex_count+1); //Add one to the count\n            for( int h = 0; h < plex_count+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n              if (plex_dist < plexlist\[h].w) \{                  \n                for( int i = plex_count+1; i > h ; i--) \{\n                  plexlist\[i] = plexlist\[i-1];\n                  plexlistXY\[i] = plexlistXY\[i-1];\n                \}\n                plexlist\[h] = float4(plex_position.x,plex_position.y,plex_position.z,plex_dist);\n                plexlistXY\[h] = int2(x,y);\n                break;        \n              \}\n            \}\n          \} \n        \}\n      \}\n    \}\n  \}\n  else\{ //Used for standard connection types\n    float4 temp_pos;\n    bool insideX = !(Vformat.x < pos.x+1);\n    bool insideY = !(Vformat.y < pos.y+1);\n\n\n    if (!_plexLinedefAUX)\{\n      temp_pos = normals(pos.x,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,vWorld+plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideX && !_plexLinedefX) \{\n      temp_pos = ppos(pos.x+1,pos.y );\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && !_plexLinedefX) \{\n      temp_pos = ppos(0,pos.y);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    if ( insideY && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\}                          \n    \}\n    else if ( _plexConnectY  && !_plexLinedefY) \{\n      temp_pos = ppos(pos.x,0);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n\n    //_plexConnect\n    if ( insideX && insideY && !_plexLinedefXY) \{              \n      temp_pos = ppos(pos.x+1,pos.y+1);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && _plexConnectY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectX && insideY && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n    else if ( _plexConnectY && insideX && !_plexLinedefXY) \{\n      temp_pos = ppos((pos.x+1)*insideX,(pos.y+1)*insideY);\n      plex_position = float3(temp_pos.x,temp_pos.y,temp_pos.z)*(zoom);\n      if (temp_pos.w != 0) \{wire_connection(vWorld,plex_position, plexlist,plexlistXY,plex_count,pos);\} \n    \}\n  \}   \n\n  //now that all the connections have been sorted by distance then we connect the dots.\n  for( int x = 0; x < min(_maxPlexConnections,plex_count) ; x++)\{\n    plex_position = float3(plexlist\[x].x,plexlist\[x].y,plexlist\[x].z);\n    plex_dist = plexlist\[x].w;\n\n\n    float plex_distribution = 1.0f-((plexlist\[x].w-plexlist\[0].w)/((plexlist\[min(_maxPlexConnections,plex_count)].w-plexlist\[0].w)+0.00001f)); //Where does it lie between the best and the worst distance?\n    //plexlistXY\n\n    float4 plex_col = float4(pow(1.0f-(plex_dist/_maxPlexDistance),1.0f/_plex_gamma))*float4(plex_distribution); //This one is quite cool aswell, but does leave the center ones a bit too focused \n    float4 plex_colorA = src(pos.x,pos.y);\n    float4 plex_colorB = src( plexlistXY\[x].x,plexlistXY\[x].y);\n    plex_col *= 0.1f;\n\n    computePixelCoordinates(plex_position, pRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n    if (dst.bounds.inside(int(vRaster.x),int(vRaster.y)) || dst.bounds.inside(int(pRaster.x),int(pRaster.y)))\{\n        DrawLine(vRaster,pRaster,(plex_colorA*plex_col)*_lineInMultiplier,(plex_colorB*plex_col)*_lineOutMultiplier);\n    \}\n  \}\n\}\n\nvoid wire_connection(float3 p_source,float3 p_target, float4 (&p_plexlist)\[11], int2 (&p_plexlistXY)\[11],int &p_plexcount,int2 position) \{\n  float xd = p_target.x - p_source.x;\n  float yd = p_target.y - p_source.y;\n  float zd = p_target.z - p_source.z;\n  float plex_dist = sqrt(xd*xd + yd*yd + zd*zd);\n  if (plex_dist<_maxPlexDistance)\{\n    p_plexcount = min(11,p_plexcount+1); //Add one to the count\n    for( int h = 0; h < p_plexcount+1 ; h++) \{ //Loop thought all the points. If the distance is shorter then insert it into the array and push the rest of the array down\n      if (plex_dist < p_plexlist\[h].w) \{                  \n        for( int i = p_plexcount+1; i > h ; i--) \{\n          p_plexlist\[i] = p_plexlist\[i-1];\n          p_plexlistXY\[i] = p_plexlistXY\[i-1];\n        \}\n        p_plexlist\[h] = float4(p_target.x,p_target.y,p_target.z,plex_dist);\n        p_plexlistXY\[h] = int2(position.x,position.y);\n        break;        \n      \}\n    \}  \n  \}\n\}\n//-------END OF WIRE RENDER FUNCTIONS---------\n\n\n\n\n//-------------------------------\n//-------BOKEH FUNCTIONS---------\n//thanks to: http://devlog-martinsh.blogspot.dk/2011/11/glsl-depth-of-field-with-bokeh-v21.html\nfloat2 rand(float2 coord) //generating noise/pattern texture for dithering\n\{\n  float noiseX = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.25)+(Frac(coord.y*(WHformat\[1]/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((Frac(1.0-coord.x*(WHformat\[0]/2.0))*0.75)+(Frac(coord.y*(WHformat\[1]/2.0))*0.25))*2.0-1.0;\n  noiseX = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f))) * 43758.5453f),0.0f,1.0f)*2.0f-1.0f;\n  noiseY = clamp(Frac(sin(dot(coord ,float2(12.9898f,78.233f)*2.0f)) * 43758.5453f),0.0f,1.0f)*2.0-1.0f;\n  return float2(noiseX,noiseY);\n\}\n//-------------------------------------\n// Bokeh\n//-------------------------------------\nvoid Bokeh(float3 pos,float4 color)\{\n  float blur = 0.0;\n  blur = clamp((fabs(pos.z - focalDepth)/_depthOfField)*100.0f,-_maxDofSize,_maxDofSize);\n  \n  float w = (1.0/WHformat.x)*blur;//+noise.x;\n  float h = (1.0/(WHformat.x*dof_aspect))*blur;//+noise.y;\n  float3 v3_col = float3(color.x,color.y,color.z);\n  int ringsamples;\n  float s = 1.0;  \n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples; \n    for (int j = 0 ; j < ringsamples ; j += 1)  \n    \{ \n      s += (1.0f*mix(1.0f,(float(i))/(float(_dof_rings)),dof_bias)*1.0f); //No need to do this in the loop\n    \}\n  \}\n\n  for (int i = 1; i <= _dof_rings; i += 1)\n  \{   \n    ringsamples = i * _dof_samples;\n     \n    for (int j = 0 ; j < ringsamples ; j += 1)   \n    \{\n      float step = PI*2.0 / float(ringsamples);\n      float pw = (cos(float(j)*step)*(float(i)/_dof_rings));\n      float ph = (sin(float(j)*step)*(float(i)/_dof_rings));\n      float p = 1.0;\n\n      float posx = pos.x+((pw*w)*blur);\n      float posy = pos.y+((ph*h)*blur);\n\n\n      float3 lumcoeff = float3(0.299,0.587,0.114);\n      float lum = dot(v3_col, lumcoeff);\n      float thresh = max((lum-dof_threshold)*dof_gain, 0.0f);\n      v3_col+mix(float3(0.0),v3_col,thresh*blur);\n\n      float3 col = (v3_col*mix(1.0,(float(i))/(float(_dof_rings)),dof_bias)*p)/s; \n      bilinear_Plot(float2(posx,posy),float4(col.x,col.y,col.z,color.w/(_dof_rings*_dof_rings)),1);\n    \}\n  \}\n\}\n//-------END OF BOKEH FUNCTIONS---------\n\n\n\n//-------------------------------------\n// Process\n//-------------------------------------\n  void process(int2 pos) \{\n    float4 _sample = ppos(pos.x,pos.y); //Get the XYZ Coordinates\n    float2 posf = float2(pos.x,pos.y);\n\n    if (_sample.w != 0.0f) \{  //No need to process if there is no data.\n\n      //Convert worldspace coordinates to screenspcace coordinates.\n      vWorld = float3(_sample.x,_sample.y,_sample.z)*(zoom);\n      int ret = computePixelCoordinates(vWorld, vRaster, worldToCamera, canvasWidth, canvasHeight, WHformat\[0], WHformat\[1]);\n      if (ret) \{ //Only create points that are visible on screen\n        if (_pointRender)\{\n          point_render(pos,vRaster);\n        \}\n      \} //Pointrender over\n\n      if (_wireRender && _maxPlexConnections>=1) \{\n        if (max(pos.x,pos.y)<=max_line_connections || (_maxPlexType==0))\{ // Don't process more wires than allowed in nearest mode.\n          wire_render(pos);\n        \}\n      \} //WireRender over\n\n      if (_facetRender) \{\n        facet_render(pos,float3(_sample.x,_sample.y,_sample.z));\n      \}  //FacetRender over\n      \n    \}\n  \} //----> process\n\};\n"
  useGPUIfAvailable false
  rebuild ""
  PointRender3D_cam_Matrix {
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
      {{parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix} {parent.Camera1.world_matrix}}
    }
  PointRender3D_focallength {{parent.Camera1.focal}}
  PointRender3D_hapeture {{parent.Camera1.haperture}}
  PointRender3D_format {{Settings_Format.width} {Settings_Format.height}}
  PointRender3D_vertexformat {{parent.InputFormat.box.r-1} {parent.InputFormat.box.t-1}}
  PointRender3D__alphaMultiplier {{parent.AlphaMultiplier}}
  PointRender3D__pointRender {{parent.RenderMode==0}}
  PointRender3D__wireRender {{parent.RenderMode==1}}
  PointRender3D__facetRender {{parent.RenderMode==2}}
  PointRender3D__maxLDistance {{parent.wire_maxdistance}}
  PointRender3D__maxLConnections {{parent.wire_connections}}
  PointRender3D__maxPlexType {{-parent.wire_type}}
  PointRender3D__plexLinedefXY {{!parent.connect_xy}}
  PointRender3D__plexLinedefX {{!parent.connect_x}}
  PointRender3D__plexLinedefY {{!parent.connect_y}}
  PointRender3D__plexLinedefAUX {{!connect_aux}}
  PointRender3D__plexConnectX {{parent.CloseX}}
  PointRender3D__plexConnectY {{parent.CloseY}}
  PointRender3D__L_gamma {{parent.wire_Threshold}}
  "PointRender3D_Enable Depth of Field" {{parent.dof_enable}}
  PointRender3D_samples {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_rings {{3*(parent.Dof_Quality*parent.Dof_Quality+1)}}
  PointRender3D_focalDepth {{parent.dof_focaldepth}}
  PointRender3D__depthOfField {{parent.dof_dof}}
  PointRender3D__depthMult {{parent.DofMultiplier}}
  PointRender3D__maxDofSize {{parent.dof_maxSize*400}}
  PointRender3D_dof_aspect {{parent.dof_Aspect}}
  PointRender3D_dof_bias {{parent.dof_bias}}
  PointRender3D__flatshading {{parent.facet_flatShading}}
  PointRender3D__backfacing {{parent.facet_backface}}
  PointRender3D__frontfacing {{parent.facet_front}}
  PointRender3D__vertexMode {{parent.renderMode}}
  PointRender3D__depthBuffer {{parent.facet_depth}}
  PointRender3D__texoffset {-0.5 0.5}
  PointRender3D__pointSize 0
  PointRender3D__depthOcclusion {{parent.UseOcclusionMap}}
  PointRender3D__maxLineSteps {{parent.maxSamples}}
  PointRender3D__lineOffset {{parent.lineoffset}}
  PointRender3D__lineInMultiplier {{parent.inGain}}
  PointRender3D__lineOutMultiplier {{parent.outGain}}
  format "1280 720 0 0 1280 720 1 HD_720"
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos -27
  ypos 159
 }
 Reformat {
  format {{{Settings_Format.format}}}
  resize none
  center false
  name Reformat1
  xpos -27
  ypos 343
 }
 Group {
  name SoftLook
  xpos -27
  ypos 460
  disable {{!parent.HighlightCompression}}
  addUserKnob {20 User}
  addUserKnob {26 ""}
  addUserKnob {7 Add R 0 4}
  Add {{parent.HighlightCeiling}}
  addUserKnob {7 Offset R 0 4}
  Offset {{parent.Compression}}
 }
  Input {
   inputs 0
   name Input1
   xpos -248
   ypos 500
  }
set N5a88bc00 [stack 0]
  Expression {
   expr0 r/(r+parent.Offset)*parent.Add
   expr1 g/(g+parent.Offset)*parent.Add
   expr2 b/(b+parent.Offset)*parent.Add
   expr3 a/(a+parent.Offset)*parent.Add
   name Expression1
   xpos -339
   ypos 576
  }
push $N5a88bc00
  ShuffleCopy {
   inputs 2
   red red
   green green
   blue blue
   alpha alpha2
   name ShuffleCopy1
   xpos -248
   ypos 576
  }
  Output {
   name Output1
   xpos -248
   ypos 651
  }
 end_group
 TimeBlur {
  divisions {{parent.Samples}}
  shutter {{parent.Shutter}}
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur
  xpos -27
  ypos 581
  disable {{1-parent.mb_enable x89 0}}
 }
 ShuffleCopy {
  inputs 2
  in pos
  red red
  green green
  blue blue
  out pos
  name ShuffleCopy1
  xpos -27
  ypos 673
  disable true
 }
 Output {
  name Output1
  xpos -27
  ypos 710
 }
 Input {
  inputs 0
  name InputCamera
  xpos -1129
  ypos 116
  number 1
 }
 Camera2 {
  focal {{parent.FocalLength}}
  haperture {{parent.horizontalApeture}}
  name Camera1
  xpos -1119
  ypos 223
 }
 Reformat {
  inputs 0
  format "1920 1080 0 0 1920 1080 1 HD_1080"
  resize none
  center false
  name Settings_Format
  xpos -1404
  ypos 241
 }
push $N5a850c00
 PositionToPoints2 {
  display textured
  render_mode textured
  P_channel pos
  detail 0.25
  pointSize 0.6
  name PreviewNode
  xpos -22
  ypos 8
  disable {{!parent.Enable3DPreview}}
 }
push $N5a784000
 Reformat {
  type "to box"
  box_width 100
  box_height 100
  box_fixed true
  scale 0.1
  resize none
  filter Impulse
  black_outside true
  name Reformat3
  xpos -633
  ypos -1109
  disable {{!wire_type==1}}
 }
push $N5a7cf000
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -456
  ypos -402
 }
end_group
ShuffleCopy {
 inputs 2
 red red
 out depth
 name ShuffleCopy2
 xpos -761
 ypos 142
}
Grade {
 white 0.012
 maskChannelInput depth.Z
 name Grade4
 xpos -761
 ypos 1729
}
ZDefocus2 {
 math direct
 legacy_resize_mode false
 show_legacy_resize_mode false
 name ZDefocus1
 xpos -761
 ypos 1764
}
Blur {
 size 3.7
 name Blur2
 xpos -761
 ypos 1796
}
ShuffleCopy {
 inputs 2
 black red
 white green
 red2 blue
 green2 alpha
 out2 motion
 name ShuffleCopy1
 xpos -761
 ypos 1924
}
IDistort {
 uv motion
 uv_scale 41.5
 blur -backward.v
 blur_scale 42
 name IDistort1
 xpos -761
 ypos 1948
}
Dot {
 name Dot14
 xpos -727
 ypos 2024
}
push $N1053f600
Group {
 name SlightGlow
 xpos -55
 ypos 1412
}
 Input {
  inputs 0
  name Input1
  xpos 100
  ypos -285
 }
 Dot {
  name Dot1
  xpos 134
  ypos -194
 }
set N5a8d8000 [stack 0]
 Dot {
  name Dot2
  xpos 74
  ypos -69
 }
push $N5a8d8000
 Grade {
  channels rgba
  gamma {{parent.Grade1.gamma}}
  reverse true
  black_clamp false
  name Grade2
  xpos 100
  ypos -162
 }
set N5a90f800 [stack 0]
 Blur {
  size 512
  name Blur9
  xpos 200
  ypos 200
 }
push $N5a90f800
 Blur {
  size 256
  name Blur8
  xpos 205
  ypos 169
 }
push $N5a90f800
 Blur {
  size 128
  name Blur7
  xpos 206
  ypos 127
 }
push $N5a90f800
 Blur {
  size 64
  name Blur6
  xpos 206
  ypos 85
 }
push $N5a90f800
 Blur {
  size 32
  name Blur5
  xpos 203
  ypos 50
 }
push $N5a90f800
 Blur {
  size 16
  name Blur4
  xpos 207
  ypos 13
 }
push $N5a90f800
 Blur {
  size 8
  name Blur3
  xpos 210
  ypos -19
 }
push $N5a90f800
 Blur {
  size 4
  name Blur2
  xpos 207
  ypos -50
 }
push $N5a90f800
 Merge2 {
  inputs 2
  operation plus
  mix 7
  name Merge2
  xpos 100
  ypos -55
 }
 Merge2 {
  inputs 2
  operation plus
  mix 6
  name Merge3
  xpos 100
  ypos -31
 }
 Merge2 {
  inputs 2
  operation plus
  mix 5
  name Merge4
  xpos 100
  ypos -7
 }
 Merge2 {
  inputs 2
  operation plus
  mix 4
  name Merge5
  xpos 100
  ypos 17
 }
 Merge2 {
  inputs 2
  operation plus
  mix 3
  name Merge6
  xpos 100
  ypos 48
 }
 Merge2 {
  inputs 2
  operation plus
  mix 2
  name Merge7
  xpos 100
  ypos 90
 }
 Merge2 {
  inputs 2
  operation plus
  name Merge8
  xpos 100
  ypos 132
 }
 Merge2 {
  inputs 2
  operation plus
  mix 0.00390625
  name Merge9
  xpos 100
  ypos 191
 }
 Grade {
  channels rgba
  white 0.04
  name Grade1
  xpos 100
  ypos 215
 }
 Merge2 {
  inputs 2
  operation from
  name Merge1
  xpos 97
  ypos 255
  disable true
 }
push $N5a8d8000
 Grade {
  channels rgba
  white 1.26
  name Grade3
  xpos -13
  ypos -54
 }
 Merge2 {
  inputs 2
  operation plus
  Achannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  Bchannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  output {rgba.red rgba.green rgba.blue -rgba.alpha}
  name Merge10
  selected true
  xpos -13
  ypos 255
 }
 Output {
  name Output1
  xpos -13
  ypos 344
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "Don't use this as your glow.\nWas just quickly thrown together to prove the point.\n=)\n"
  xpos 310
  ypos 31
 }
end_group
Dot {
 name Dot6
 xpos -21
 ypos 1726
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097664}
    {t x44700000 x44070000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup Ellipse1 512 bezier
     {{cc
       {f 8192}
       {px 0
        {xc38d6288 0}
        {xc47d999d x43cecccc}
        {x438d6288 0}
        {0 xc357f180}
        {xc3fb333c x44492665}
        {0 x4357f180}
        {x438d6288 0}
        {xc47d999d x44957332}
        {xc38d6288 0}
        {0 x4357f180}
        {xc4beccce x44492665}
        {0 xc357f180}}}
      {cc
       {f 8192}
       {px 0
        {xc38d6288 0}
        {x44effffe xc4323331}
        {x438d6288 0}
        {0 xc357f180}
        {x44143338 xc28b3330}
        {0 x4357f180}
        {x438d6288 0}
        {0 0}
        {xc38d6288 0}
        {0 x4357f180}
        {0 0}
        {0 xc357f180}}}}
     {tx 0 xc3fe0000 x444ac000}
     {a a 0 opc x3e99999a osw x41200000 osf 0 str 1 spx x44700000 spy x44070000 sb 1 ltn 0 ltm 0 tt x40e00000}}
    {curvegroup Rectangle1 512 bezier
     {{cc
       {f 8192}
       {px
        {0 x42c80000}
        {{{0 -}}
      {{xc38caaac -}}}
        {{{xc40d8001 0 1 x3ca3d99a 1}
       {xc40d8000 x3ca3d99a 1 0 1}}
      {{x44918000 0 1 xbe8f5c29 1}
       {x448a8000 xbe8f5c29 1 0 1}}}
        {{{x442cd555 -}}
      {{0 -}}}
        {{{xc42cd555 -}}
      {{0 -}}}
        {{{x44bc8000 0 1 x3ca3d99a 1}
       {x44bc8000 x3ca3d99a 1 0 1}}
      {{x44918000 0 1 xbe8f5c29 1}
       {x448a8000 xbe8f5c29 1 0 1}}}
        {{{0 -}}
      {{xc38caaac -}}}
        {{{0 -}}
      {{x438caaac -}}}
        {{{x44bc5998 0 1 x3d0315c3 1}
       {x44bc8000 x3d0315c3 1 0 1}}
      {{x43b4ffff 0 1 xbf33332e 1}
       {x43840000 xbf33332e 1 0 1}}}
        {{{xc42cd552 0 1 xb5f5c28f 1}
       {xc42cd555 xb5f5c28f 1 0 1}}
      {{0 -}}}
        {{{x442cd555 -}}
      {{0 -}}}
        {{{xc40dcccb 0 1 x3d0311ec 1}
       {xc40d8000 x3d0311ec 1 0 1}}
      {{x43b4ffff 0 1 xbf33332e 1}
       {x43840000 xbf33332e 1 0 1}}}
        {{{0 -}}
      {{x438caaac -}}}}}
      {cc
       {f 8192}
       {px
        {0 x42c80000}
        {{{0 -}}
      {{xc38caaac -}}}
        {{{0 -}}
      {{0 -}}}
        {{{x442cd555 -}}
      {{0 -}}}
        {{{xc42cd555 -}}
      {{0 -}}}
        {{{0 -}}
      {{0 -}}}
        {{{0 -}}
      {{xc38caaac -}}}
        {{{0 -}}
      {{x438caaac -}}}
        {{{x41999a00 0 1 x3dac07ae 1}
       {x41dccd40 x3dac07ae 1 0 1}}
      {{xc34bfffd 0 1 xbeac0838 1}
       {xc36d9998 xbeac0838 1 0 1}}}
        {{{xc42cd553 0 1 xb5a3d70a 1}
       {xc42cd555 xb5a3d70a 1 0 1}}
      {{0 -}}}
        {{{x442cd555 -}}
      {{0 -}}}
        {{{xc1b66680 0 1 xbd75c28f 1}
       {xc1e66680 xbd75c28f 1 0 1}}
      {{xc33c666b 0 1 xbf1cac08 1}
       {xc379999e xbf1cac08 1 0 1}}}
        {{{0 -}}
      {{x438caaac -}}}}}}
     {tx x42c80000 x43eb8000 x442b8000}
     {a osw x41200000 osf 0 str 1 spx x44700000 spy x44070000 sb 1 ltn x42c80000 ltm x42c80000 tt x41000000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 tt 7 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 tt 8 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {960 540}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 100
 lifetime_end 100
 motionblur_shutter_offset_type centred
 source_black_outside true
 name Roto1
 xpos 741
 ypos 1635
}
Blur {
 size 100
 name Blur1
 xpos 741
 ypos 1667
}
set N5a9b5400 [stack 0]
push $N5a9b5400
Constant {
 inputs 0
 channels rgb
 color {0.549875319 0.5011277795 0.4559567273 0}
 format "5184 3456 0 0 5184 3456 1 "
 name Constant2
 xpos 620
 ypos 1460
}
Ramp {
 p0 {-35 1835}
 p1 {5150 1815}
 color {0.1789363772 0.2104376853 0.3434452415 0}
 name Ramp5
 xpos 620
 ypos 1532
}
Ramp {
 p0 {3060 1650}
 p1 {3060 1525}
 color {0.03866031021 0.04114452004 0.05870225653 0}
 name Ramp6
 xpos 620
 ypos 1556
}
Ramp {
 p0 {2830 1595}
 p1 {2795 -20}
 color {0.01277690288 0.01365650538 0.02019722946 0}
 name Ramp7
 xpos 620
 ypos 1580
}
Ramp {
 p0 {2830 1595}
 p1 {2830 3450}
 color {0.1287544221 0.1707740277 0.3224849105 0}
 name Ramp8
 xpos 620
 ypos 1604
}
Reformat {
 format "1280 720 0 0 1280 720 1 HD_720"
 name Reformat3
 xpos 620
 ypos 1638
}
Grade {
 inputs 1+1
 white 0.085
 add_panelDropped true
 gamma 0.72
 name Grade2
 xpos 620
 ypos 1671
}
Fill {
 inputs 1+1
 color {0.115783 0.307205 0.38196 1}
 color_panelDropped true
 mix 0.625
 name Fill2
 xpos 620
 ypos 1695
}
FrameHold {
 name FrameHold2
 xpos 620
 ypos 1740
}
Reformat {
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 name Reformat4
 xpos 620
 ypos 1783
}
Dot {
 name Dot3
 xpos 654
 ypos 1827
}
Merge2 {
 inputs 2
 name Merge2
 xpos -55
 ypos 1824
}
Merge2 {
 inputs 2
 operation plus
 mix 0.21
 name Merge3
 xpos -55
 ypos 2021
}
Dot {
 name Dot2
 xpos -21
 ypos 2564
}
set N5aad9800 [stack 0]
Group {
 name Spot_Flare
 tile_color 0x2f66ff
 xpos 73
 ypos 2561
 addUserKnob {20 User}
 addUserKnob {26 Headline l "" +STARTLINE T "<font color=#80dddd size=\"7\">S</font><font color=#90dede size=\"7\">p</font><font color=#a0dfdf size=\"7\">o</font><font color=#b0e0e0 size=\"7\">t</font><font color=#c0e1e1 size=\"7\">F</font><font color=#b0e0e0 size=\"7\">l</font><font color=#a0dfdf size=\"7\">are</font><font color=#90dede size=\"3\">v</font><font color=#80dddd size=\"2\">1.0</font>"}
 addUserKnob {26 HeadlineB l "" +STARTLINE T "<font color=#80dddd size=\"2\">by Mads Hagbarth Lund</font>"}
 addUserKnob {26 devider001 l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {12 Position}
 Position {{parent.Reconcile3D1.output} {parent.Reconcile3D1.output}}
 addUserKnob {7 Gain}
 Gain {{curve x2 0.505 0.68 0.775 x12 0 s-0.3600000143 t0 u0.515859127}}
 addUserKnob {7 Gamma R 0 5}
 Gamma {{curve x2 1 x4 1.8 x12 2.045700312}}
 addUserKnob {7 Scale}
 Scale 0.55
 addUserKnob {6 SoftClip t "By default, spotflare will be very bright at the center. Use softclip to limit the maximum brightness." +STARTLINE}
 addUserKnob {7 softclipmax l max -STARTLINE R 1 100}
 softclipmax 10
 addUserKnob {6 glow_enable l Glow +STARTLINE}
 addUserKnob {6 EffectOnly l "Effect Only" +STARTLINE}
 EffectOnly true
 addUserKnob {22 FixJitter l "Fix Jitter" t "This does nothing... yet still fixes the bug with the expression node not updating its cashe from time to time.\nPlease fix The Foundry!" +STARTLINE}
 addUserKnob {26 devider02 l "<b><font color=#70EE70>Color</font><b>"}
 addUserKnob {18 GainTint}
 GainTint {0.342034 0.743418 1}
 addUserKnob {6 GainTint_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 GainTint_panelDropped true
 addUserKnob {18 GammaTint}
 GammaTint {1 1 1}
 addUserKnob {6 GammaTint_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 GammaTint_panelDropped true
 addUserKnob {26 devide01 l "" +STARTLINE T " "}
 addUserKnob {22 Reset l "Reset Color" T "nuke.thisNode().knob(\"GainTint\").setValue(1,0)\nnuke.thisNode().knob(\"GainTint\").setValue(1,1)\nnuke.thisNode().knob(\"GainTint\").setValue(1,2)\nnuke.thisNode().knob(\"GainTint\").setValue(1,3)\nnuke.thisNode().knob(\"GammaTint\").setValue(1,0)\nnuke.thisNode().knob(\"GammaTint\").setValue(1,1)\nnuke.thisNode().knob(\"GammaTint\").setValue(1,2)\nnuke.thisNode().knob(\"GammaTint\").setValue(1,3)" +STARTLINE}
 addUserKnob {26 DeviderShimmer l "<b><font color=#70EE70>Shimmer</font><b>"}
 addUserKnob {6 shimmer_enable l Shimmer +STARTLINE}
 shimmer_enable true
 addUserKnob {7 lacunarity l Detail R 0 5}
 lacunarity 2.18
 addUserKnob {7 noise_gain l Gain}
 noise_gain 0.84
 addUserKnob {7 Speed}
 Speed 0.965
 addUserKnob {7 Noise_Gang l "Time Offset" R 0 1000}
 Noise_Gang {{frame}}
 addUserKnob {26 devider04 l "<b><font color=#70EE70>Masking</font><b>"}
 addUserKnob {6 Mask +STARTLINE}
 addUserKnob {7 MaskRotation l "Mask Rotation"}
 MaskRotation 0.31
 addUserKnob {7 MaskGain l "Mask Gain"}
 MaskGain 0.4
 addUserKnob {7 MaskSoftness R 0 10}
 MaskSoftness 2.35
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x7171c600
  label Spike
  note_font_size 42
  xpos -222
  ypos 207
  bdwidth 270
  bdheight 257
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x388e8e00
  label Glow
  note_font_size 42
  xpos -597
  ypos 209
  bdwidth 280
  bdheight 258
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x8e388e00
  label Glare
  note_font_size 42
  xpos -1156
  ypos 207
  bdwidth 468
  bdheight 298
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0xffffffff
  gl_color 0xff
  label "WELCOME TO SPOTFLARE"
  note_font_size 42
  xpos -904
  ypos -206
  bdwidth 523
  bdheight 138
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x71c67100
  label "Spot Facing"
  note_font_size 42
  xpos -1463
  ypos 208
  bdwidth 252
  bdheight 258
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0xff
  label "PLEASE ENJOY"
  note_font_size 42
  xpos -801
  ypos 896
  bdwidth 333
  bdheight 160
 }
 StickyNote {
  inputs 0
  name StickyNote2
  label "This is a super inefficient way\nto avoid the 1-0 seam and\na major performence hit.\nIf anyone have a better solution,\nplease mail me! =)"
  note_font_size 8
  xpos -1045
  ypos 350
 }
 StickyNote {
  inputs 0
  name StickyNote1
  tile_color 0xcc0000ff
  gl_color 0xcc0000ff
  label "not yet implamented"
  xpos -222
  ypos 206
 }
 Dot {
  inputs 0
  name Dot19
  tile_color 0xff0000ff
  xpos -674
  ypos -127
  hide_input true
 }
 Dot {
  inputs 0
  name Dot20
  tile_color 0xffff00ff
  xpos -658
  ypos -127
  hide_input true
 }
 Dot {
  inputs 0
  name Dot21
  tile_color 0xff00ff
  xpos -641
  ypos -127
  hide_input true
 }
 Dot {
  inputs 0
  name Dot22
  tile_color 0xffffff
  xpos -624
  ypos -127
  hide_input true
 }
 Dot {
  inputs 0
  name Dot23
  tile_color 0xffff
  xpos -607
  ypos -127
  hide_input true
 }
 Input {
  inputs 0
  name Input1
  xpos -674
  ypos -106
 }
 Dot {
  name Dot13
  xpos -640
  ypos -25
 }
set N5ab0fc00 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle3
  xpos -674
  ypos 35
 }
 Dot {
  name Dot1
  xpos -640
  ypos 131
 }
set N5ab0f400 [stack 0]
 Dot {
  name Dot9
  xpos -456
  ypos 131
 }
set N5ab0f000 [stack 0]
 Dot {
  name Dot2
  xpos -61
  ypos 131
 }
 Expression {
  expr0 "(atan(x-parent.Position.x,-y--parent.Position.y)+ (pi))/(pi*2)"
  name Expression8
  xpos -95
  ypos 268
 }
 Expression {
  expr0 sin(r*(16*pi))
  name Expression14
  xpos -95
  ypos 310
 }
 Grade {
  white 0.89
  gamma 0.2
  name Grade6
  xpos -95
  ypos 352
 }
 Shuffle {
  green red
  blue red
  alpha red
  name Shuffle2
  xpos -95
  ypos 396
 }
push $N5ab0f000
 Expression {
  temp_name0 xd
  temp_expr0 parent.Position.x-x
  temp_name1 yd
  temp_expr1 parent.Position.y-y
  temp_name2 dist
  temp_expr2 "sqrt(xd*xd + yd*yd)"
  temp_name3 scale
  temp_expr3 "dist / ((parent.Scale*1))"
  expr0 scale
  channel1 {-rgba.red -rgba.green -rgba.blue none}
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 {none none none -rgba.alpha}
  enable_mix_luminance false
  name distance
  xpos -490
  ypos 261
 }
 Grade {
  white {{pow(1-parent.Gain,4)}}
  gamma {{pow2(parent.Gamma)}}
  name Grade16
  xpos -490
  ypos 300
 }
 Grade {
  add -0.6
  name Grade3
  xpos -490
  ypos 324
 }
 Expression {
  temp_name3 invsqr
  temp_expr3 isnan(r)?0:1/(r*r)
  expr0 invsqr
  expr1 invsqr
  expr2 invsqr
  name Inverse_Square
  xpos -490
  ypos 363
 }
 Grade {
  white {{parent.GainTint.r} {parent.GainTint.g} {parent.GainTint.b} 1}
  white_panelDropped true
  multiply {1 1 1 1}
  multiply_panelDropped true
  gamma {{parent.GammaTint} {parent.GammaTint} {parent.GammaTint} 1}
  name Grade2
  xpos -490
  ypos 387
 }
 Clamp {
  maximum 59999
  MinClampTo_enable true
  MaxClampTo {{maximum}}
  MaxClampTo_enable true
  name Clamp_Superbrights
  xpos -490
  ypos 428
 }
set N5ab3a400 [stack 0]
 Merge2 {
  inputs 2
  operation multiply
  name Merge3
  xpos -95
  ypos 434
 }
 Dot {
  name Dot3
  xpos -61
  ypos 708
 }
 Dot {
  name Dot15
  xpos -572
  ypos 708
 }
push $N5ab0f400
 Dot {
  name Dot16
  xpos -750
  ypos 131
 }
set N5ab93400 [stack 0]
 Dot {
  name Dot17
  xpos -868
  ypos 131
 }
 Dot {
  name Dot7
  xpos -1332
  ypos 131
 }
 Expression {
  temp_name0 theta
  temp_expr0 pi*(parent.MaskRotation*2)
  temp_name1 px
  temp_expr1 "cos(theta) * (x-parent.Position.x) - sin(theta) * (y-parent.Position.y) + parent.Position.x"
  temp_name2 py
  temp_expr2 "sin(theta) * (x-parent.Position.x) + cos(theta) * (y-parent.Position.y) + parent.Position.y"
  temp_name3 val
  temp_expr3 "(atan(px-parent.Position.x,-py--parent.Position.y)+ pi)/+ (pi*2)"
  expr0 "smoothstep(0,1, sin(val*pi))"
  name Expression1
  xpos -1366
  ypos 298
 }
 Grade {
  black 0.033
  white {{(pow(parent.MaskGain,2)*10)+0.0001}}
  gamma {{(pow(parent.MaskSoftness,2)/2)+0.15}}
  name Grade9
  xpos -1366
  ypos 336
 }
 Expression {
  expr0 max(0,1-r)
  expr1 max(0,1-r)
  expr2 max(0,1-r)
  name Expression17
  xpos -1366
  ypos 380
 }
 Dot {
  name Dot8
  xpos -1332
  ypos 745
 }
push $N5ab93400
 Dot {
  name Dot4
  xpos -750
  ypos 230
 }
set N5abbf800 [stack 0]
 Dot {
  name Dot5
  xpos -868
  ypos 230
 }
 Expression {
  expr0 "(atan(x-parent.Position.x,-y--parent.Position.y)+ pi)/+ (pi*2)"
  name inversefacing
  xpos -902
  ypos 267
 }
set N5abbf000 [stack 0]
 Dot {
  name Dot18
  xpos -978
  ypos 270
 }
 Expression {
  expr0 pow(sin(r*pi),16)
  name reduction
  xpos -1012
  ypos 313
 }
set N5abbe800 [stack 0]
 Dot {
  name Dot10
  xpos -978
  ypos 415
 }
push $N5abbe800
push $N5abbf000
 ShuffleCopy {
  inputs 2
  green red
  alpha alpha2
  name ShuffleCopy1
  xpos -902
  ypos 313
 }
 Expression {
  temp_name0 octaves
  temp_expr0 5
  temp_name1 lacunarity
  temp_expr1 parent.lacunarity
  temp_name2 gain
  temp_expr2 parent.noise_gain
  temp_name3 Noise
  temp_expr3 g>0.0001?fBm(r,1,1+((frame+parent.Noise_Gang)/((1.0001-parent.Speed)*10000)),octaves,lacunarity,gain):0
  expr0 Noise
  expr1 Noise
  expr2 Noise
  name noise_top
  xpos -902
  ypos 348
 }
 Grade {
  black 0.54
  gamma 0.585
  black_clamp false
  name Grade14
  xpos -902
  ypos 388
 }
push $N5abbf800
 Expression {
  temp_name0 xd
  temp_expr0 parent.Position.x-x
  temp_name1 yd
  temp_expr1 parent.Position.y-y
  temp_name2 dist
  temp_expr2 "sqrt(xd*xd + yd*yd)"
  expr0 "(atan(x-parent.Position.x,y-parent.Position.y)+ pi)/+ (pi*2)"
  expr1 dist/width
  name facing
  xpos -784
  ypos 267
 }
 Expression {
  temp_name0 octaves
  temp_expr0 5
  temp_name1 lacunarity
  temp_expr1 parent.lacunarity
  temp_name2 gain
  temp_expr2 parent.noise_gain
  temp_name3 Noise
  temp_expr3 fBm(r,1,1+((frame+8+parent.Noise_Gang)/((1.0001-parent.Speed)*10000)),octaves,lacunarity,gain)
  expr0 Noise
  expr1 Noise
  expr2 Noise
  name noise
  xpos -784
  ypos 314
 }
 Grade {
  black 0.54
  gamma 0.585
  black_clamp false
  name Grade15
  xpos -784
  ypos 412
 }
 Merge2 {
  inputs 2+1
  operation copy
  maskChannelMask rgba.red
  name FixSeam
  xpos -902
  ypos 412
 }
push $N5ab3a400
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos -902
  ypos 436
 }
 Clamp {
  maximum_enable false
  name Clamp_Negative_Numbers
  xpos -902
  ypos 460
 }
 Dot {
  name Dot6
  xpos -868
  ypos 660
 }
push $N5ab3a400
 Dot {
  name Dot11
  xpos -456
  ypos 587
 }
push $N5ab0f400
 Merge2 {
  inputs 2
  operation plus
  name Merge6
  xpos -674
  ypos 584
  disable {{1-parent.glow_enable}}
 }
 Merge2 {
  inputs 2
  operation plus
  name Merge2
  xpos -674
  ypos 657
  disable {{1-parent.shimmer_enable x2012 1}}
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge5
  xpos -674
  ypos 742
  disable {{1-parent.Mask}}
 }
 SoftClip {
  conversion "preserve hue and saturation"
  softclip_min 1
  softclip_max {{parent.softclipmax}}
  name SoftClip1
  selected true
  xpos -674
  ypos 766
  disable {{1-parent.SoftClip}}
 }
push $N5ab0fc00
 Dot {
  name Dot12
  xpos -689
  ypos -25
 }
 Grade {
  multiply 0
  black_clamp false
  enable_mix_luminance false
  name Grade1
  xpos -723
  ypos 77
  disable {{1-parent.EffectOnly}}
 }
 Dot {
  name Dot14
  xpos -692
  ypos 794
 }
 Merge2 {
  inputs 2
  operation plus
  name Merge7
  xpos -674
  ypos 791
 }
 Output {
  name Output1
  xpos -674
  ypos 991
 }
end_group
Dot {
 name Dot15
 xpos 107
 ypos 2625
}
push $N5aad9800
Merge2 {
 inputs 2
 operation plus
 mix {{curve x1 0 1 x9 1 x12 0}}
 name Merge1
 xpos -55
 ypos 2622
}
Merge2 {
 inputs 2
 operation plus
 mix {{curve i x1 0 1 x7 1 s-0.004999999888 v0.4857212305 x18 0 s0}}
 name Merge6
 xpos -55
 ypos 2849
}
ShuffleCopy {
 inputs 2
 black red
 white green
 red2 blue
 green2 alpha
 out2 motion
 name ShuffleCopy4
 xpos -55
 ypos 3011
}
IDistort {
 channels {rgba.red -rgba.green -rgba.blue none}
 uv motion
 uv_scale {{curve x4 -3 -6 x10 -1 x17 -0.15}}
 blur -backward.u
 blur_scale 42
 name IDistort3
 xpos -55
 ypos 3050
}
IDistort {
 channels {-rgba.red rgba.green -rgba.blue none}
 uv motion
 uv_scale {{parent.IDistort3.uv_scale*0.95 i}}
 blur -backward.u
 blur_scale 42
 name IDistort4
 xpos -55
 ypos 3082
}
IDistort {
 channels {-rgba.red -rgba.green rgba.blue none}
 uv motion
 uv_scale {{parent.IDistort3.uv_scale*0.90 i}}
 blur -backward.u
 blur_scale 42
 name IDistort5
 xpos -55
 ypos 3106
}
Blur {
 inputs 1+1
 size {{curve x7 6.4 x15 0}}
 maskChannelMask rgba.blue
 name Blur5
 xpos -55
 ypos 3223
}
Group {
 name ChromaticTransform5
 xpos -55
 ypos 3669
 addUserKnob {20 User}
 addUserKnob {26 info l "" +STARTLINE T "C H R O M A T I C  T R A N S F O R M v1.0 \nby Mads Hagbarth Damsbo 2017\n\nChromatic Transform is a node that creates a wavelength based chromatic smear \nusing eighter a transform or a input vector map.\nYou can also input a luminance map and use the \"Generate Normals\" checkbox.\n\n\n"}
 addUserKnob {26 deviderGeneral l "<b><font color=#70EE70>GENERAL</font><b>"}
 addUserKnob {41 divisions l Samples T TimeBlur6.divisions}
 addUserKnob {4 Mode M {Transform "Vector (Using vector map)"}}
 addUserKnob {26 DeviderVector l "<b><font color=#70EE70>VECTOR</font><b>"}
 addUserKnob {7 VectorMultiply l "Vector Multiply" R 0 100}
 VectorMultiply 208
 addUserKnob {6 SobelNormal l "Generate Normals (Sobel)" -STARTLINE}
 addUserKnob {26 DeviderTransform l "<b><font color=#70EE70>TRANSFORM</font><b>"}
 addUserKnob {41 translate T TransformFrom.translate}
 addUserKnob {41 rotate T TransformFrom.rotate}
 addUserKnob {41 scale T TransformFrom.scale}
 addUserKnob {41 skewX l "skew X" T TransformFrom.skewX}
 addUserKnob {41 skewY l "skew Y" T TransformFrom.skewY}
 addUserKnob {41 center T TransformFrom.center}
 addUserKnob {26 ""}
 addUserKnob {41 translate_1 l translate T TransformTo.translate}
 addUserKnob {41 rotate_1 l rotate T TransformTo.rotate}
 addUserKnob {41 scale_1 l scale T TransformTo.scale}
 addUserKnob {41 skewX_1 l "skew X" T TransformTo.skewX}
 addUserKnob {41 skewY_1 l "skew Y" T TransformTo.skewY}
 addUserKnob {41 center_1 l center T TransformTo.center}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x8e388e00
  label Transform
  note_font_size 42
  xpos 146
  ypos -414
  bdwidth 265
  bdheight 161
 }
 Crop {
  inputs 0
  box {0 0 2 1}
  reformat true
  crop false
  name Crop6
  xpos 340
  ypos -68
 }
 Expression {
  expr0 1
  expr1 1
  expr2 1
  name Expression11
  xpos 340
  ypos -44
 }
 BlinkScript {
  recompileCount 27
  ProgramGroup 1
  KernelDescription "2 \"WavelengthKernel\" iterate pixelWise b7a56c9b75cb36b8d8dab924acc10f8370a4f0dae201f8eae370c2dba27fd46d 2 \"src\" Read Point \"dst\" Write Point 1 \"frequency\" Float 1 AADIQw== 1 \"frequency\" 1 1 0"
  kernelSource "kernel WavelengthKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float frequency; \n\n  void define() \{\n    defineParam(frequency, \"frequency\", 400.0f);\n  \}\n\n  void init() \{\n\n  \}\n\nvoid spectral_color(double &r,double &g,double &b,double l)\n    \{\n    double t;  r=0.0; g=0.0; b=0.0;\n         if ((l>=400.0)&&(l<410.0)) \{ t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); \}\n    else if ((l>=410.0)&&(l<475.0)) \{ t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); \}\n    else if ((l>=545.0)&&(l<595.0)) \{ t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); \}\n    else if ((l>=595.0)&&(l<650.0)) \{ t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); \}\n    else if ((l>=650.0)&&(l<700.0)) \{ t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); \}\n         if ((l>=415.0)&&(l<475.0)) \{ t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); \}\n    else if ((l>=475.0)&&(l<590.0)) \{ t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); \}\n    else if ((l>=585.0)&&(l<639.0)) \{ t=(l-585.0)/(639.0-585.0); g=0.84-(0.84*t)           ; \}\n         if ((l>=400.0)&&(l<475.0)) \{ t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); \}\n    else if ((l>=475.0)&&(l<560.0)) \{ t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); \}\n    \}\n\n  void process() \{\n    double red, green, blue;\n\n    spectral_color(red,green,blue,frequency);\n    dst() = 1.0f*float4(red,green,blue,1);\n  \}\n\};\n"
  rebuild ""
  WavelengthKernel_frequency {{((1-(frame-floor(frame)))*300)+400}}
  rebuild_finalise ""
  name BlinkScript11
  xpos 340
  ypos -16
 }
set N5ac7c400 [stack 0]
 TimeBlur {
  divisions 20
  shutter 1
  shutteroffset start
  shuttercustomoffset 1
  name TimeBlur6
  xpos 340
  ypos 32
 }
 set C5ac7c000 [stack 0]
push $N5ac7c400
 Input {
  inputs 0
  name InputVector
  xpos -186
  ypos -618
  number 1
 }
set N680adc00 [stack 0]
 Matrix {
  channels {rgba.red -rgba.green -rgba.blue none}
  matrix {
      {1 0 -1}
      {2 0 -2}
      {1 0 -1}
    }
  name Matrix1
  xpos -301
  ypos -589
 }
 Matrix {
  channels {-rgba.red rgba.green -rgba.blue none}
  matrix {
      {-1 -2 -1}
      {0 0 0}
      {1 2 1}
    }
  name Matrix2
  xpos -301
  ypos -553
 }
 Grade {
  white 18
  black_clamp false
  name Grade1
  xpos -301
  ypos -529
 }
push $N680adc00
 Switch {
  inputs 2
  which {{parent.SobelNormal}}
  name Switch2
  xpos -186
  ypos -529
 }
 Input {
  inputs 0
  name InputSrc
  xpos 163
  ypos -579
 }
 NoTimeBlur {
  name NoTimeBlur1
  selected true
  xpos 163
  ypos -555
 }
 Dot {
  name Dot2
  xpos 197
  ypos -505
 }
set N680ac400 [stack 0]
 Dot {
  name Dot3
  xpos 30
  ypos -505
 }
add_layer {distort distort.red distort.green distort.blue distort.alpha}
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black red
  white green
  red2 blue
  green2 alpha
  out2 distort
  name ShuffleCopy1
  label "\[python nuke.thisNode().knob('in').value()] >> \[python nuke.thisNode().knob('out').value()]"
  xpos -186
  ypos -414
 }
 IDistort {
  uv distort
  uv_scale {{(frame-floor(frame))*parent.VectorMultiply}}
  name IDistort1
  xpos -186
  ypos -291
 }
 Dot {
  name Dot1
  xpos -152
  ypos -193
 }
push $N680ac400
 Transform {
  translate {{(TransformFrom.translate*(1-(frame-floor(frame))))+(TransformTo.translate*(frame-floor(frame)))} {(TransformFrom.translate*(1-(frame-floor(frame))))+(TransformTo.translate*(frame-floor(frame)))}}
  rotate {{(TransformFrom.rotate*(1-(frame-floor(frame))))+(TransformTo.rotate*(frame-floor(frame)))}}
  scale {{(TransformFrom.scale*(1-(frame-floor(frame))))+(TransformTo.scale*(frame-floor(frame)))}}
  skewX {{(TransformFrom.skewX*(1-(frame-floor(frame))))+(TransformTo.skewX*(frame-floor(frame)))}}
  skewY {{(TransformFrom.skewY*(1-(frame-floor(frame))))+(TransformTo.skewY*(frame-floor(frame)))}}
  center {{(TransformFrom.center*(1-(frame-floor(frame))))+(TransformTo.center*(frame-floor(frame)))} {(TransformFrom.center*(1-(frame-floor(frame))))+(TransformTo.center*(frame-floor(frame)))}}
  shutteroffset centred
  name Transform5
  xpos 163
  ypos -324
 }
 Switch {
  inputs 2
  which {{parent.Mode}}
  name Switch1
  xpos 163
  ypos -188
 }
 MergeExpression {
  inputs 2
  expr0 B.r*A.r(0,0)
  expr1 B.g*A.g(0,0)
  expr2 B.b*A.b(0,0)
  name MergeExpression1
  xpos 163
  ypos -12
 }
clone $C5ac7c000 {
  xpos 163
  ypos 34
  selected false
 }
 MergeExpression {
  inputs 2
  expr0 B.r/A.r(0,0)
  expr1 B.g/A.g(0,0)
  expr2 B.b/A.b(0,0)
  name MergeExpression2
  xpos 163
  ypos 87
 }
 Output {
  name Output1
  xpos 163
  ypos 187
 }
 Transform {
  inputs 0
  scale 1.01
  center {{input.width/2 x1 0 x8 0} {input.height/2 x1 0 x8 0}}
  shutteroffset centred
  name TransformTo
  xpos 318
  ypos -351
  disable true
 }
 Transform {
  inputs 0
  center {{input.width/2 x8 0} {input.height/2 x8 0}}
  shutteroffset centred
  name TransformFrom
  xpos 328
  ypos -298
  disable true
 }
end_group
Group {
 name LUE4NUKE
 tile_color 0x2c00ffff
 xpos -55
 ypos 3726
 addUserKnob {20 Primaries}
 addUserKnob {26 Credits l "" +STARTLINE T "<img src=C:/Users/Mads/.nuke/LUE/lue.png>"}
 addUserKnob {22 Init_logo l INVISIBLE +INVISIBLE T "DotNuke = nukescripts.getNukeUserFolder() \nif os.path.isfile(DotNuke+\"/LUE/lue.png\"):\n\tnuke.thisNode().knob(\"Credits\").setValue(\"<img src=\"+DotNuke+\"/LUE/lue.png>\")" +STARTLINE}
 addUserKnob {52 Init_Init_logo T "nuke.thisNode().knob(\"Init_logo\").execute()" +STARTLINE}
 addUserKnob {22 CurveKnobSetup l INVISIBLE +INVISIBLE T "#Initialize Curve Knobs\n#Need to clean up old code!!!\n\nthisNode = nuke.thisNode()\n\ntry:\n\tthisNode.knob(\"lut\").delCurve(\"sat_thrsh\")\n\tthisNode.knob(\"lut\").delCurve(\"amount\")\n\tthisNode.knob(\"lut\").addCurve(\"HueVsHue\")\n\tthisNode.knob(\"lut\").addCurve(\"HueVsSat\")\n\tthisNode.knob(\"lut\").addCurve(\"HueVsLum\")\n\tthisNode.knob(\"lut\").addCurve(\"SatVsSat\")\n\tthisNode.knob(\"lut\").addCurve(\"SatVsLum\")\n\tthisNode.knob(\"lut\").addCurve(\"BlackAndWhite\")\n\n\tdef RunNode():\n\t\tif nuke.thisKnob().Class() == \"LookupCurves_Knob\":\n\t\t\tthisNode = nuke.thisNode().fullName().split(\".\")\[-2]\n\t\t\twith nuke.Root():\n\t\t\t\tinputNode = nuke.toNode(thisNode)\n\t\t\t\tcurve = inputNode.knob(\"lut\").toScript()\n\t\t\twith inputNode:\n\t\t\t\tmyCurve = curve.splitlines()\[0]\n\t\t\t\tnuke.toNode(inputNode.name()+\".HueVsHue\").knob(\"lut\").editCurve(\"amount\",myCurve)\n\t\t\t\tmyCurve = curve.splitlines()\[1]\n\t\t\t\tnuke.toNode(inputNode.name()+\".HueVsSat\").knob(\"lut\").editCurve(\"amount\",myCurve)\n\t\t\t\tmyCurve = curve.splitlines()\[2]\n\t\t\t\tnuke.toNode(inputNode.name()+\".HueVsLum\").knob(\"lut\").editCurve(\"amount\",myCurve)\n\t\t\t\tmyCurve = curve.splitlines()\[3]\n\t\t\t\tnuke.toNode(inputNode.name()+\".SatVsSat\").knob(\"lut\").editCurve(\"master\",myCurve)\n\t\t\t\tmyCurve = curve.splitlines()\[4]\n\t\t\t\tnuke.toNode(inputNode.name()+\".SatVsLum\").knob(\"lut\").editCurve(\"master\",myCurve)            \n\t\t\t\tmyCurve = curve.splitlines()\[5]\n\t\t\t\tnuke.toNode(inputNode.name()+\".BlackAndWhite\").knob(\"lut\").editCurve(\"amount\",myCurve) \n\t\t\t\tnuke.toNode(\"HueKeyer2\").knob('knobChanged').setValue(\"RunNode()\")\n\t\t\t#help(nuke.toNode(\"HueKeyer1\").knob('knobChanged').setValue)\nexcept:\n    pass\n\n\n#Hue VS Hue\nwith thisNode:\n    curve = nuke.toNode(\"HueVsHue\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"HueVsHue\",myCurve\[8:-1])\n\n#Hue Vs Sat\nwith thisNode:\n    curve = nuke.toNode(\"HueVsSat\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"HueVsSat\",myCurve\[8:-1])\n\n#Hue Vs Lum\nwith thisNode:\n    curve = nuke.toNode(\"HueVsLum\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"HueVsLum\",myCurve\[8:-1])\n\n#Sat Vs Sat\nwith thisNode:\n    curve = nuke.toNode(\"SatVsSat\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"SatVsSat\",myCurve\[8:-1])\n\n#Sat Vs Lum\nwith thisNode:\n    curve = nuke.toNode(\"SatVsLum\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"SatVsLum\",myCurve\[8:-1])\n\n\n#Hue Vs Lum\nwith thisNode:\n    curve = nuke.toNode(\"BlackAndWhite\").knob(\"lut\").toScript()\n    myCurve = curve.splitlines()\[0]\nthisNode.knob(\"lut\").editCurve(\"BlackAndWhite\",myCurve\[13:-1])\n\n\n\n#curve = nuke.toNode(\"HueKeyer1\").knob(\"lut\").toScript()\n#myCurve = curve.splitlines()\[2]\n#print myCurve\n#nuke.toNode(\"HueKeyer2\").knob(\"lut\").editCurve(\"amount\",myCurve)\n\n\n\n\ndef RunNode():\n\tif nuke.thisKnob().Class() == \"LookupCurves_Knob\":\n\t\tthisNode = nuke.thisNode().fullName().split(\".\")\[-2]\n\t\twith nuke.Root():\n\t\t\tinputNode = nuke.toNode(thisNode)\n\t\t\tcurve = inputNode.knob(\"lut\").toScript()\n\t\twith inputNode:\n\t\t\tmyCurve = curve.splitlines()\[0]\n\t\t\tnuke.toNode(inputNode.name()+\".HueVsHue\").knob(\"lut\").editCurve(\"amount\",myCurve.replace(\"amount\",\"curve\")\[10:-1])\n\t\t\tmyCurve = curve.splitlines()\[1]\n\t\t\tnuke.toNode(inputNode.name()+\".HueVsSat\").knob(\"lut\").editCurve(\"amount\",myCurve.replace(\"amount\",\"curve\")\[10:-1])\n\t\t\tmyCurve = curve.splitlines()\[2]\n\t\t\tnuke.toNode(inputNode.name()+\".HueVsLum\").knob(\"lut\").editCurve(\"amount\",myCurve.replace(\"amount\",\"curve\")\[10:-1])\n\t\t\tmyCurve = curve.splitlines()\[3]\n\t\t\tnuke.toNode(inputNode.name()+\".SatVsSat\").knob(\"lut\").editCurve(\"master\",myCurve.replace(\"master\",\"curve\")\[10:-1])\n\t\t\tmyCurve = curve.splitlines()\[4]\n\t\t\tnuke.toNode(inputNode.name()+\".SatVsLum\").knob(\"lut\").editCurve(\"master\",myCurve.replace(\"master\",\"curve\")\[10:-1])    \n\t\t\tmyCurve = curve.splitlines()\[5]\n\t\t\tnuke.toNode(inputNode.name()+\".BlackAndWhite\").knob(\"lut\").editCurve(\"amount\",myCurve.replace(\"amount\",\"curve\")\[15:-1])          \n\t\t\tnuke.toNode(\"HueKeyer2\").knob('knobChanged').setValue(\"RunNode()\")" +STARTLINE}
 addUserKnob {52 Init_CurveKnobSetup l "" +STARTLINE T "nuke.thisNode().knob(\"CurveKnobSetup\").execute()" +STARTLINE}
 addUserKnob {52 SMH_init T "nuke.toNode(nuke.thisNode().name()+\".BaseColorCorrect\").knob(\"RunThis\").execute()" +STARTLINE}
 addUserKnob {52 init_init_colorwheel l "" +STARTLINE T "nuke.thisNode().knob(\"init_colorwheel\").execute()" +STARTLINE}
 addUserKnob {22 init_colorwheel l INVISIBLE +INVISIBLE T "import sys, math\nimport nuke\nimport PySide.QtGui as QtGui\nimport PySide.QtCore as QtCore\nfrom PySide.QtGui import *\nfrom PySide.QtCore import *\nfrom PySide.QtWebKit import *\nfrom nukescripts import panels\nimport datetime\n#Projekt Variabler\n\n#FasteVariabler\ntry:\n\tif defined == 1:\n\t    pass\n\t    #print \"allready launched\"\nexcept: \n\tclass ColorWheelWidget(QtGui.QWidget):\n\t    def __init__(self, parent=None, mainDiameter=138, outerRingWidth=10,my_Knob=\"None\"):\n\t        QtGui.QWidget.__init__(self, parent)\n\t        # this is the pixel diameter of the actual color wheel, without the extra decorations drawn as part of this widget\n\t        self.dim = mainDiameter\n\t        self.offset = outerRingWidth\n\t        self.ColorKnob = my_Knob\n\t        self.colorWheelSensitivity = 0.1\n\t        self.setstate = 0\n\t        self.bMouseDown = False\n\t        self.shiftDown = False\n\t        self.ctrlDown = False\n\t        self.altDown = False\n\t        self.guiSelection = 0\n\t        self.middleMouse = 0\n\t        self.initialPoint = (0,0)    \n\t        self.master_radius = (self.dim/2)+self.offset+1\n\t        self.huepoint = (self.master_radius, self.master_radius)\n\t        self.value_angle = 360\n\t        self.value_angleSat = 0\t   \n\t        color = QtGui.QColor(0,0,0,0).rgba()\n\t        self.myTimer = QtCore.QTime()\n\t \n\t        self.center = (self.master_radius, self.master_radius)\n\t        # this is the color value that this widget represents\n\t        self.color = QtGui.QColor()\n\n\n\n\t        # the color wheel image, only needs to be generated once\n\t        self.image = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        # this is the image for the current color selection\n\t        self.current_image = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        self.current_image.fill(QtGui.QColor(self.color).rgba())\n\t        self.current_imageB = QtGui.QImage(self.master_radius*2, self.master_radius*2, QtGui.QImage.Format_ARGB32)\n\t        self.current_imageB.fill(QtGui.QColor(self.color).rgba())       \n\t        # these are used for the current color selection image\n\t        self.lastPoint = (self.master_radius, self.master_radius)\n\t        self.currentPoint = (self.master_radius, self.master_radius)\n\t        self.points = self.getRadialLinePoints((self.dim / 2), self.master_radius, 45)\n\t        self.points2 = self.getRadialLinePoints((self.dim / 2), self.master_radius, 135)\t        \n\t        self.image.fill(color)\n\n\n\t        self.color.setRgbF(min(1,max(0,my_Knob.value()\[0])),min(1,max(0,my_Knob.value()\[1])),min(1,max(0,my_Knob.value()\[2])))\n\n\n\t        self.luma = (my_Knob.value()\[3]/2.0)*255.0\n\t        self.hue = self.color.hueF()*255.0\n\t        self.sat = self.color.saturationF()*255.0\n\t   \n\n\t        self.setUIColor(self.hue,self.sat,self.luma) \n\n\t        for y in range(int(self.master_radius*2)):\n\t            for x in range(int(self.master_radius*2)):\n\t                d = 2 * self.getDist((x,y),self.center) / self.dim\n\t                if d <= 1: #Hue Wheel\n\t                    color = QtGui.QColor()\n\t                    hue = self.getHue(x, y)\n\t                    percent = max(0,min(1,(d - 0.90)*30))\n\t                    color.setHsv(hue,(d*255),90+(165*percent),90+(165*percent)) #The dark part in the center\n\n\t                    self.image.setPixel(x,y, color.rgba())\n\t                else:\n\t                    d2 = self.getDist((x,y),self.center) / (self.master_radius-1)\n\t                    if d2 > 1: #MainBG                       \n\t                        color = QtGui.QColor()\n\t                        color.setAlpha(0)\n\t                        self.image.setPixel(x,y, color.rgba())\n\t                    else:\n\t                    \tpass\n\n\t        self.setUIColor(self.hue,self.sat,self.luma) \n\t        self.setColor(self.hue, self.sat, self.luma)\n\n\n\t    def getRadialLinePoints(self, r_inner, r_outer, angle,distance=1.0):\n\t        rad = math.radians(angle)\n\t        sr = math.sin(rad)\n\t        cr = math.cos(rad)\n\t        x1 = r_outer - (r_outer * (sr*distance))\n\t        y1 = r_outer - (r_outer * (cr*distance)) \n\t        x2 = r_outer - (r_inner * (sr*distance))\n\t        y2 = r_outer - (r_inner * (cr*distance))\n\t        return (x1, y1, x2, y2)\n\t  \n\t    def getRot(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2*(x - self.master_radius),2*(y - self.master_radius)))) % 360\n\t    def getLum(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2.0*(x - self.master_radius),2.0*(y - self.master_radius)))) % 360\n\n\t    def getHue(self, x, y):\n\t        return ( math.degrees ( math.atan2 ( 2*(x - self.master_radius),2*(y - self.master_radius))) + 165 ) % 360\n\t    \n\t    def setColor(self, h, s, v):\n\n\t        self.color.setHsvF(0.0,0.0,min(1,v/255.0))\n\t        alpha = self.current_image.alphaChannel()\n\t        self.current_image.fill(self.color.rgb())\n\t        self.current_image.setAlphaChannel(alpha)\n\t        self.color.setHsvF(min(1,h/255.0),1.0,min(1,v/255.0)) #Should be 255 and not 254.5 but it causes a unknown error!\n\t        alpha = self.current_imageB.alphaChannel()\n\t        self.current_imageB.fill(self.color.rgb())\n\t        self.current_imageB.setAlphaChannel(alpha)\n\t        self.update()      \n\n\t    def reset(self,x):\n\t        self.middleMouse = 1\n\t        self.bMouseDown = True\n\t        self.guiSelection = 0\n\t        self.initialPoint = (self.center\[0], self.center\[1])\n\t        self.lastPoint = (self.center\[0], self.center\[1]) \n\t        self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t        self.guiSelection = 1\n\t        self.initialPoint = (self.center\[0], self.center\[1])\n\t        self.lastPoint = (self.center\[0], self.center\[1]) \n\t        self.alterColor(self.lastPoint\[0], self.lastPoint\[1]-10)\n\t        self.lastPoint = self.currentPoint\n\t        self.setColor(self.hue, self.sat, self.luma)\n\t        self.setUIColor(self.hue,self.sat,self.luma)\n\t        self.bMouseDown = False\n\t        if not self.ColorKnob == \"None\":\n\t\t\t\ttry:\n\t\t\t\t\tself.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),1.0)\n\t\t\t\t\tself.ColorKnob.setValue(\[float(self.color.redF()),float(self.color.greenF()),float(self.color.blueF()),float(self.luma*2)/255])\n\t\t\t\texcept: \n\t\t\t\t\tprint \"Error trying to send values to color control. Make sure all layouts are set to 4 Colors and not 1\"\n\n\t        \n\t    def getDist(self, (x1, y1), (x2, y2)):\n\t        return math.sqrt((x2-x1)**2 + (y2-y1)**2)\n\t        \n\t    def paintEvent(self, evt):\n\t        painter = QtGui.QPainter(self)\n\t        painter.setRenderHint(QtGui.QPainter.Antialiasing)\n\t        pen = QtGui.QPen()\n\t        if not self.ColorKnob == \"None\":\n\t\t\t\ttry:\n\t\t\t\t\tif self.setstate > 0:\n\t\t\t\t\t\tself.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),1.0)\n\t\t\t\t\t\tself.ColorKnob.setValue(\[float(self.color.redF()),float(self.color.greenF()),float(self.color.blueF()),float(self.luma*2)/255])\n\t\t\t\t\tif self.setstate > 1:\n\t\t\t\t\t\tself.setstate = 0\n\n\t\t\t\texcept: \n\t\t\t\t\tprint \"Error trying to send values to color control. Make sure all layouts are set to 4 Colors and not 1\"\n\t        self.color.setHsvF(min(1,self.hue/255.0),min(1,self.sat/255.0),min((self.luma/255.0)*2.0,1.0))\n\t        brush = QtGui.QBrush(QtGui.QColor(self.color.rgb())) #Color of the elipse\n\t        pen.setColor(QtGui.QColor(20,20,20)) #Outline Color\n\t        pen.setWidth(2) #Outline Width\n\t        painter.setPen(pen)\n\t        \n\t        painter.drawImage(0,0,self.image)\n\t        #painter.drawImage(0,0,self.current_image)\n\t        #painter.drawImage(0,0,self.current_imageB)\n\t        r = self.dim/2 \n\t        r2 = r + self.offset\n\t        center = QtCore.QPoint(r2+2,r2+2) \n\t        center = QtCore.QPointF(self.center\[0],self.center\[1] )\n\t        \n\t        painter.drawEllipse(center, r, r ) #DRAW THE OUTER BLACK CIRCLE\n\n\n\t   \n\t        #LUMINANCE ARC\n\t        pen.setWidth(3) #Outline Width\n\t        pen.setColor(QtGui.QColor(150,150,150)) #Outline Color\n\t        gradient = QtGui.QConicalGradient()\n\t        gradient.setCenter(center)\n\t        gradient.setAngle(-90)\n\t        gradient.setColorAt(1, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.497, QtGui.QColor(170, 170, 170))\n\t        gradient.setColorAt(0.498, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.5, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.502, QtGui.QColor(255, 255, 255))\n\t        gradient.setColorAt(0.503, QtGui.QColor(170, 170, 170))\n\t        gradient.setColorAt(0, QtGui.QColor(70, 70, 70))\n\t        pen.setBrush(gradient)\n\n\t        painter.setPen(pen)    \n\t        rectangle = QtCore.QRectF(self.center\[0]-((self.dim*1.1)/2), self.center\[1]-((self.dim*1.1)/2), self.dim*1.1, self.dim*1.1)     \n\t        startAngle = -90*16\n\n\t        spanAngle = (self.value_angle)*16\n\t        painter.drawArc(rectangle, startAngle, spanAngle)\n\n\n\t        pen.setWidth(1) #Outline Width\n\t        pen.setColor(QtGui.QColor(20,20,20)) #Outline Color\n\t        painter.setPen(pen)\n\t        #painter.drawEllipse(center, r-8, r-8) #DRAW THE INNER BLACK CIRCLE\n\n\t        pen.setColor(QtGui.QColor(200,200,200)) #Outline Color\n\t        painter.setPen(pen)\n\t        #Middle Crosshair\n\t        painter.drawLine((self.master_radius)+4,(self.master_radius),(self.master_radius)-4,(self.master_radius))\n\t        painter.drawLine((self.master_radius),(self.master_radius)+4,(self.master_radius),(self.master_radius)-4)\n\n\t        pen.setWidth(6) #Outline Width\n\t        painter.setPen(pen)\n\t        (x1,y1,x2,y2) = self.points\n\t        (x1,y1,x2,y2) = self.points2\n\n\n\t        #Draw the GuideLines\n\t        pen.setWidth(1.99)\n\t        pen.setColor(QtGui.QColor(220,220,220))\n\t        pen.setStyle(QtCore.Qt.PenStyle.DashLine)\n\t        painter.setPen(pen)\n\t        (hpx, hpy) =  self.huepoint\n\t        d = self.getDist((hpx,hpy),self.center)\n\t        if self.bMouseDown == False: #Hide the guidelines when the mouse is not clicked\n\t            pass\n\t        else:\n\t            (x1,y1,x2,y2) = self.getRadialLinePoints(0, self.master_radius, ((self.hue/255)*360)+15,0.80) \n\t            painter.drawLine(x1,y1,x2,y2)\n\t            if d > 46: #If the radial is in the bright area, then display a dark version\n\t                pen.setColor(QtGui.QColor(20,20,20))  \n\t                painter.setPen(pen)\n\t            if d != 0:\n\t                painter.drawEllipse(QtCore.QPointF(self.master_radius, self.master_radius), d, d)\n\n\n\t        #Draw Hue Dot\n\t        pen.setWidth(1)\n\t        pen.setStyle(QtCore.Qt.PenStyle.SolidLine)\n\t        if self.luma > 90:\n\t            pen.setColor(QtGui.QColor(0,0,0))\n\t        else:\n\t            pen.setColor(QtGui.QColor(220,220,220))\n\t        painter.setPen(pen)\n\t        painter.setBrush(brush)\n\t        painter.drawEllipse(QtCore.QPointF(hpx, hpy), 5, 5)\n\n\n\n\t    def setUIColor(self,h,s,v):\n\t        (x1,y1,x2,y2) = self.getRadialLinePoints((self.dim / 2.0), self.master_radius,  ((self.hue/255)*360)+15,(s/255.0))\n\t        self.huepoint = (x2,y2)\n\t        self.lastPoint = (x2,y2)\n\t        self.currentPoint = (x2,y2)\n\t        #Saturation\n\t        self.value_angleSat = (1.0-((s/255.0) * 90.0)) + 135.0       \n\n\t        #Luminance\n\t        self.value_angle = ((v/255.0) * 360.0) \n\n\n\t        \n\t    def alterColor(self, x, y):\t\n\t        d = 2.0 * self.getDist((x,y),self.center) / self.dim\n\t        if self.guiSelection == 0:\n\t            if self.getDist((x,y),self.center) >= (self.dim/2.0):\n\t                Percent = self.getDist((x,y),self.center) / (self.dim/2.0)\n\t                prex = (((x-self.center\[0]) / Percent) * 1)+self.center\[0]\n\t                prey = (((y-self.center\[1]) / Percent) * 1)+self.center\[1]\n\t                self.initialPoint = (self.initialPoint\[0]-(prex-x), self.initialPoint\[1]-(prey-y))\n\t                x = prex\n\t                y = prey\n\t            hue = self.getHue(x, y)\n\n\t            self.value_angleSat = (1.0-((self.getDist((x,y),self.center) / (self.dim/2.0)) * 90.0)) + 135.0  \n\t            self.hue = (hue/360)*255\n\t            self.sat = min(d*255.0,255.0)\n\t            self.huepoint = (x,y)\n\t            self.setColor(hue,min(d*255.0,255.0),self.luma)\n\t        \n\t        elif self.guiSelection == 1:\n\t            self.value_angle = self.getRot(x, y)\n\t            lum = self.getLum(x, y)\n\t            v = (lum/360.0)*255.0\n\t            self.setColor(self.color.hueF(), self.color.saturationF(), v)\n\t            self.luma = v\n\n\n\t        else:\n\t            pass\n\n\n\t    def mousePressEvent(self, evt):\n\t    \tself.setstate = 1\n\t        self.myTimer.start()\n\t\t\t\n\t        d = 2 * self.getDist((evt.x(), evt.y()),self.center) / self.dim\n\t        if evt.button() == QtCore.Qt.MouseButton.MiddleButton:\n\t            self.middleMouse = 1\n\t        else:\n\t            self.middleMouse = 0\n\t        if d <= 1: \n\t            self.guiSelection = 0\n\t            if self.middleMouse == 1:\n\t                self.initialPoint = (self.center\[0], self.center\[1])\n\t                self.lastPoint = (self.center\[0], self.center\[1]) \n\t                self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t            else:\n\t                self.initialPoint = (evt.x(), evt.y())\n\t                self.alterColor(self.lastPoint\[0], self.lastPoint\[1])\n\t        else:\n\t            d = self.getDist((evt.x(), evt.y()),self.center) / self.master_radius\n\t            if d <= 1:\n\t                self.guiSelection = 1\n\t                if self.middleMouse == 1:\n\t                    self.initialPoint = (self.center\[0], self.center\[1])\n\t                    self.lastPoint = (self.center\[0], self.center\[1]) \n\t                    self.alterColor(self.lastPoint\[0], self.lastPoint\[1]-10)\n\t                else:\n\t                    self.alterColor(evt.x(), evt.y())\n\t            else:\n\t                self.guiSelection = 3\n\t        self.bMouseDown = True\n\n\n\n\n\t    def mouseMoveEvent(self, evt):\n\t    \tself.setstate = 1\n\t    \tnMilliseconds = self.myTimer.elapsed()\n\t    \tif nMilliseconds < 1:\n\t    \t\tpass\n\t    \telse:\n\n\t\t        modifiers = QtGui.QApplication.keyboardModifiers()\n\t\t        self.shiftDown = False\n\t\t        self.ctrlDown = False\n\t\t        self.altDown = False\n\t\t        self.colorWheelSensitivity = 0.1\n\n\t\t        if modifiers == QtCore.Qt.ShiftModifier:\n\t\t            self.shiftDown = True\n\t\t        if modifiers == QtCore.Qt.ControlModifier:\n\t\t            self.ctrlDown = True\n\t\t        if modifiers == QtCore.Qt.AltModifier:\n\t\t            self.altDown = True\n\t\t            self.colorWheelSensitivity = 1\n\t\t        if modifiers == (QtCore.Qt.ControlModifier | QtCore.Qt.ShiftModifier):\n\t\t            self.ctrlDown = True\n\t\t            self.shiftDown = True\n\n\t\t        if self.bMouseDown and self.middleMouse == 0:\n\t\t            if self.guiSelection == 1 or self.guiSelection == 2:\n\t\t                self.alterColor(evt.x(), evt.y())\n\t\t            else:\n\n\t\t                x = (((evt.x()-self.initialPoint\[0]) * self.colorWheelSensitivity))+self.lastPoint\[0]\n\t\t                y = (((evt.y()-self.initialPoint\[1]) * self.colorWheelSensitivity))+self.lastPoint\[1]\n\t\t                self.alterColor(x, y)\n\t\t                self.currentPoint = (x, y) \n\t\t        self.myTimer.restart()\n\t        \n\n\t    def mouseReleaseEvent(self, evt):\n\t    \tself.setstate = 2\n\t        self.lastPoint = self.currentPoint\n\t        self.setColor(self.hue, self.sat, self.luma)\n\t        self.setUIColor(self.hue,self.sat,self.luma)\n\t        self.bMouseDown = False\n\nclass Example(QtGui.QWidget):\n\tdef __init__(self, parent=None,myNode=\"none\"):\n\t\tQtGui.QWidget.__init__(self, None)\n\t\t#self.setGeometry(900, 900, 800, 600)\n\t\t#self.setWindowTitle('ColorBars')\n\t\tself.baseNode = myNode\n\t\tself.palette = QtGui.QPalette()\n\t\tself.LiftLabel = QtGui.QLabel(\"<b>Lift</b>\")\n\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\tself.LiftLabel.setPalette(self.palette)\n\t\tself.LiftLabel.mouseReleaseEvent = self.showText1\n\t\tself.Lift = ColorWheelWidget(None, 138, 10,myNode.knob(\"Lift\"))\n\n\n\t\tself.GammaLabel = QtGui.QLabel(\"<b>Gamma</b>\")\n\t\tself.GammaLabel.setPalette(self.palette)\n\t\tself.GammaLabel.mouseReleaseEvent = self.showText2\n\t\tself.Gamma = ColorWheelWidget(None, 138, 10,myNode.knob(\"Gamma\"))\n\n\t\tself.GainLabel = QtGui.QLabel(\"<b>Gain</b>\")\n\t\tself.GainLabel.setPalette(self.palette)\n\t\tself.GainLabel.mouseReleaseEvent = self.showText3\n\t\tself.Gain = ColorWheelWidget(None, 138, 10,myNode.knob(\"Gain\"))\n\n\t\tlayout = QtGui.QGridLayout()\n\t\tlayout.addWidget(self.LiftLabel,0,0)\n\t\tlayout.addWidget(self.GammaLabel,0,1)\n\t\tlayout.addWidget(self.GainLabel,0,2)\n\t\tlayout.addWidget(self.Lift,1,0)\n\t\tlayout.addWidget(self.Gamma,1,1)\n\t\tlayout.addWidget(self.Gain,1,2)\n\t\tlayout.setRowStretch(1,1)\n\t\tself.setLayout(layout)\n\t\t#self.show()\n\tdef showText1(self, event):\n\t\tmyNode = self.baseNode.knob(\"LiftEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.LiftLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.LiftLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\tdef showText2(self, event):\n\t\tmyNode = self.baseNode.knob(\"GammaEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.GammaLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.GammaLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\tdef showText3(self, event):\n\t\tmyNode = self.baseNode.knob(\"GainEnabled\")\n\t\tif myNode.value() == 1:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n\t\t\tself.GainLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(0)\n\t\telse:\n\t\t\tself.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n\t\t\tself.GainLabel.setPalette(self.palette)\n\t\t\tmyNode.setValue(1)\n\n\nclass ColorWheelKnob_LGG:\n\tdef __init__( self ):\n\t\tself.instance = 0\n\t\treturn None\n\n\tdef makeUI( self ):\n\t\tself.instance = Example(None,nuke.thisNode())\n\t\treturn self.instance\n\ndefined = 1" +STARTLINE}
 addUserKnob {22 init_colorwheel2 l INVISIBLE +INVISIBLE T "class Example2(QtGui.QWidget):\n  def __init__(self, parent=None,myNode=\"none\"):\n    QtGui.QWidget.__init__(self, None)\n    #self.setGeometry(900, 900, 800, 600)\n    #self.setWindowTitle('ColorBars')\n    self.baseNode = myNode\n    self.palette = QtGui.QPalette()\n    self.ShadowLabel = QtGui.QLabel(\"<b>Shadows</b>\")\n    self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n    self.ShadowLabel.setPalette(self.palette)\n    self.ShadowLabel.mouseReleaseEvent = self.showText1\n    self.Shadow = ColorWheelWidget(None, 138, 10,myNode.knob(\"Shadows\"))\n\n\n    self.MidtoneLabel = QtGui.QLabel(\"<b>Midtones</b>\")\n    self.MidtoneLabel.setPalette(self.palette)\n    self.MidtoneLabel.mouseReleaseEvent = self.showText2\n    self.Midtone = ColorWheelWidget(None, 138, 10,myNode.knob(\"Midtones\"))\n\n    self.HighlightLabel = QtGui.QLabel(\"<b>Highlights</b>\")\n    self.HighlightLabel.setPalette(self.palette)\n    self.HighlightLabel.mouseReleaseEvent = self.showText3\n    self.Highlight = ColorWheelWidget(None, 138, 10,myNode.knob(\"Highlights\"))\n\n    layout = QtGui.QGridLayout()\n    layout.addWidget(self.ShadowLabel,0,0)\n    layout.addWidget(self.MidtoneLabel,0,1)\n    layout.addWidget(self.HighlightLabel,0,2)\n    layout.addWidget(self.Shadow,1,0)\n    layout.addWidget(self.Midtone,1,1)\n    layout.addWidget(self.Highlight,1,2)\n    layout.setRowStretch(1,1)\n    self.setLayout(layout)\n    #self.show()\n  def showText1(self, event):\n    myNode = self.baseNode.knob(\"ShadowsEnabled\")\n    if myNode.value() == 1:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n      self.ShadowLabel.setPalette(self.palette)\n      myNode.setValue(0)\n    else:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n      self.ShadowLabel.setPalette(self.palette)\n      myNode.setValue(1)\n\n  def showText2(self, event):\n    myNode = self.baseNode.knob(\"MidtonesEnabled\")\n    if myNode.value() == 1:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n      self.MidtoneLabel.setPalette(self.palette)\n      myNode.setValue(0)\n    else:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n      self.MidtoneLabel.setPalette(self.palette)\n      myNode.setValue(1)\n\n  def showText3(self, event):\n    myNode = self.baseNode.knob(\"HighlightsEnabled\")\n    if myNode.value() == 1:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.red)\n      self.HighlightLabel.setPalette(self.palette)\n      myNode.setValue(0)\n    else:\n      self.palette.setColor(QtGui.QPalette.Foreground,QtCore.Qt.white)\n      self.HighlightLabel.setPalette(self.palette)\n      myNode.setValue(1)\n\nclass ColorWheelKnob_SMH:\n  def __init__( self ):\n    self.instance = 0\n    return None\n\n  def makeUI( self ):\n    self.instance = Example2(None,nuke.thisNode())\n    return self.instance\n" +STARTLINE}
 addUserKnob {52 init_init_colorwheel2 T "nuke.thisNode().knob(\"init_colorwheel2\").execute()" +STARTLINE}
 addUserKnob {26 info_general l "<b><font color=#70EE70>General</font><b>"}
 addUserKnob {22 General_Clear l Clear T "nuke.thisNode().knob(\"blackpoint\").setValue(\[0,0,0,0])\nnuke.thisNode().knob(\"blackpoint\").setValue(0)\nnuke.thisNode().knob(\"whitepoint\").setValue(\[0,0,0,0])\nnuke.thisNode().knob(\"whitepoint\").setValue(1)\nnuke.thisNode().knob(\"add\").setValue(\[0,0,0,0])\nnuke.thisNode().knob(\"add\").setValue(0)\nnuke.thisNode().knob(\"red\").setValue(0)\nnuke.thisNode().knob(\"Temperature\").setValue(1)\nnuke.thisNode().knob(\"Tint\").setValue(1)\nnuke.thisNode().knob(\"Contrast\").setValue(1)\nnuke.thisNode().knob(\"Saturation\").setValue(1)\nnuke.thisNode().knob(\"ColorBoost\").setValue(1)" +STARTLINE}
 addUserKnob {6 General_Enable l Enable -STARTLINE}
 General_Enable true
 addUserKnob {41 blackpoint l "Blackpoint <font color=#1A1A1A>●</font>" T BaseGrade.blackpoint}
 addUserKnob {41 whitepoint l "Whitepoint <font color=#E6E6E6>●</font>" T BaseGrade.whitepoint}
 addUserKnob {41 add l "Offset <sup>▲</sup><sub>▼</sub>" T BaseGrade.add}
 addUserKnob {26 basedevider l "" +STARTLINE T " \n"}
 addUserKnob {41 red l Exposure T Exposure1.red}
 addUserKnob {7 Temperature l "Temperature <font color=#E6E6A1><sup>◄</sup></font><font color=#A1E6E6><sub>►</sub></font>" R 0 2}
 Temperature 1
 addUserKnob {7 Tint l "Tint <font color=#E6A1A1><sup>◄</sup></font><font color=#A1E6A1><sub>►</sub></font>" R 0 2}
 Tint 1
 addUserKnob {7 Contrast R 0.5 1.5}
 Contrast 1
 addUserKnob {7 Saturation R 0 2}
 Saturation 1
 addUserKnob {7 ColorBoost l Vibrance R 0 2}
 ColorBoost 1
 addUserKnob {6 pop_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 info_liftgammagain l "<b><font color=#70EE70>3-Way LGG</font><b>"}
 addUserKnob {22 liftgammagain_clear l Clear T "nuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Lift.reset(1)\nnuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Gamma.reset(1)\nnuke.thisNode().knob(\"LiftGammaGain\").getObject().instance.Gain.reset(1)" +STARTLINE}
 addUserKnob {6 liftgammagain_Enable l Enable -STARTLINE}
 liftgammagain_Enable true
 addUserKnob {52 LiftGammaGain l "" t "Hotkeys:\nClick MiddleMouse = Reset\nALT+Drag = Absolute Offset" +STARTLINE T ColorWheelKnob_LGG() +STARTLINE}
 addUserKnob {41 colorspace_out l GradingSpace T LGGColorspace_in.colorspace_out}
 addUserKnob {7 LumaMix l " Mix Luma" -STARTLINE}
 LumaMix 1
 addUserKnob {20 org l "" +STARTLINE n 1}
 org 0
 addUserKnob {19 Lift R 0 2}
 Lift {1 1 1 1}
 addUserKnob {6 Lift_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Lift_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Lift_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Lift_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 LiftEnabled l "" -STARTLINE}
 LiftEnabled true
 addUserKnob {19 Gamma R 0 2}
 Gamma {1 1 1 1}
 addUserKnob {6 Gamma_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gamma_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gamma_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gamma_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 GammaEnabled l "" -STARTLINE}
 GammaEnabled true
 addUserKnob {19 Gain R 0 2}
 Gain {1 1 1 1}
 addUserKnob {6 Gain_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gain_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gain_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Gain_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 GainEnabled l "" -STARTLINE}
 GainEnabled true
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 info_ShadowMidtoneHighlight l "<b><font color=#70EE70>3-Way SMH</font><b>"}
 addUserKnob {22 SMH_Clear l Clear T "nuke.thisNode().knob(\"ShadowsMidtonesHighlights\").getObject().instance.Shadow.reset(1)\nnuke.thisNode().knob(\"ShadowsMidtonesHighlights\").getObject().instance.Midtone.reset(1)\nnuke.thisNode().knob(\"ShadowsMidtonesHighlights\").getObject().instance.Highlight.reset(1)" +STARTLINE}
 addUserKnob {6 SMH_Enable l Enable -STARTLINE}
 addUserKnob {52 ShadowsMidtonesHighlights l "" +STARTLINE T ColorWheelKnob_SMH() +STARTLINE}
 addUserKnob {41 low l Low T BaseColorCorrect.low}
 addUserKnob {41 High -STARTLINE T BaseColorCorrect.High}
 addUserKnob {20 smh_group l "" +STARTLINE n 1}
 smh_group 0
 addUserKnob {19 Shadows R 0 2}
 Shadows {1 1 1 1}
 addUserKnob {6 Shadows_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Shadows_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Shadows_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Shadows_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 ShadowsEnabled l "" -STARTLINE}
 ShadowsEnabled true
 addUserKnob {6 Midtones_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Highlights_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Midtones R 0 2}
 Midtones {1 1 1 1}
 addUserKnob {6 Midtones_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Midtones_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Midtones_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Midtones_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 MidtonesEnabled l "" -STARTLINE}
 MidtonesEnabled true
 addUserKnob {19 Highlights R 0 2}
 Highlights {1 1 1 1}
 addUserKnob {6 Highlights_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Highlights_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Highlights_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Highlights_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 HighlightsEnabled l "" -STARTLINE}
 HighlightsEnabled true
 addUserKnob {20 endGroup_1 l endGroup n -1}
 addUserKnob {20 PAGE_Secondaries l Secondaries}
 addUserKnob {26 SplitToning_DEVIDER l "<b><font color=#70EE70>Split Toning</font><b>"}
 addUserKnob {22 SplitToning_Clear l Clear T "nuke.thisNode().knob(\"Split_Bright_Hue\").setValue(0.095)\nnuke.thisNode().knob(\"Split_Bright_Sat\").setValue(1)\nnuke.thisNode().knob(\"Split_Dark_Hue\").setValue(0.715)\nnuke.thisNode().knob(\"Split_Dark_Sat\").setValue(1)\nnuke.thisNode().knob(\"Split_Contrast\").setValue(0)\nnuke.thisNode().knob(\"Split_Mix\").setValue(0.17)\nnuke.thisNode().knob(\"Split_Offset\").setValue(0)" +STARTLINE}
 addUserKnob {6 SplitToning_Enable l Enable -STARTLINE}
 addUserKnob {7 Split_Bright_Hue l "Hue White <font color=#E6E6E6>●</font>"}
 Split_Bright_Hue 0.095
 addUserKnob {7 Split_Bright_Sat l "Sat  <font color=#E6E6E6>●</font>" -STARTLINE}
 Split_Bright_Sat 1
 addUserKnob {7 Split_Dark_Hue l "Hue Black <font color=#1A1A1A>●</font>"}
 Split_Dark_Hue 0.715
 addUserKnob {7 Split_Dark_Sat l "Sat <font color=#1A1A1A>●</font>" -STARTLINE}
 Split_Dark_Sat 1
 addUserKnob {7 Split_Contrast l "Contrast ◊"}
 addUserKnob {7 Split_Offset l Offset -STARTLINE R -1 1}
 addUserKnob {7 Split_Mix l "Mix ◌"}
 Split_Mix 0.17
 addUserKnob {26 PrimariesOffset_Devider l "<b><font color=#70EE70>Primaries Offset</font><b>"}
 addUserKnob {22 Primatries_Clear l Clear T "nuke.thisNode().knob(\"Prim_HueRed\").setValue(0)\nnuke.thisNode().knob(\"Prim_HueGreen\").setValue(0)\nnuke.thisNode().knob(\"Prim_HueBlue\").setValue(0)" +STARTLINE}
 addUserKnob {6 Primaries_Enable l Enable -STARTLINE}
 addUserKnob {7 Prim_HueRed l "Offset Red <font color=#FF4040>●</font>" R -1 1}
 addUserKnob {7 Prim_HueGreen l "Offset Green <font color=#40FF40>●</font>" R -1 1}
 addUserKnob {7 Prim_HueBlue l "Offset Blue <font color=#4040FF>●</font>" R -1 1}
 addUserKnob {4 PO_Method l Method M {"Color Overwrite" "Color Shift" "YCbCr Rotation" "" "" "" "" "" "" ""}}
 PO_Method "Color Shift"
 addUserKnob {26 ColorMixer_DEVIDER l "<b><font color=#70EE70>Color Mixer</font><b>"}
 addUserKnob {22 ColorMixer_Clear l Clear T "nuke.thisNode().knob(\"RED\").setValue(\[1,0,0])\nnuke.thisNode().knob(\"Green\").setValue(\[0,1,0])\nnuke.thisNode().knob(\"Blue\").setValue(\[0,0,1])\n\n" +STARTLINE}
 addUserKnob {6 ColorMixer_Enable l Enable -STARTLINE}
 addUserKnob {41 RED T NoOp1.RED}
 addUserKnob {41 Green l GREEN T NoOp1.Green}
 addUserKnob {41 Blue l BLUE T NoOp1.Blue}
 addUserKnob {20 PAGE_HUE l "Hue Corrections"}
 addUserKnob {26 HueShift_DEVIDER l "<b><font color=#70EE70>Hue Shift</font><b>"}
 addUserKnob {22 HueShift_Clear l Clear T "string = \"\"\"HueVsHue \{amount L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0\}\nHueVsSat \{amount L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0\}\nHueVsLum \{amount L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0\}\nSatVsSat \{master L x-1 0.5 0.5 x6 0.5 K x7 0.5\}\nSatVsLum \{master L x-1 0.5 0.5 x6 0.5 K x7 0.5\}\nBlackAndWhite \{amount L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0\}\n\"\"\"\nwith nuke.thisNode():\n    nuke.toNode(\"HueKeyer2\").knob(\"lut\").fromScript(string)" +STARTLINE}
 addUserKnob {6 HueShift_Enable l Enable -STARTLINE}
 addUserKnob {41 lut l "" +STARTLINE T HueKeyer2.lut}
 addUserKnob {26 TEEEEEEEEEEEEEEEEEEEEEEEEEEEEEST l "<b><font color=#70EE70>Settings</font><b>"}
 addUserKnob {6 BW_Enable l "Enable Black and White" +STARTLINE}
 addUserKnob {7 BWSoftFilter l "BW Soft Filter"}
 BWSoftFilter 0.245
 addUserKnob {26 soft_devider l "" +STARTLINE T "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-"}
 addUserKnob {20 Vingette}
 addUserKnob {26 Vingette_DEVIDER l "<b><font color=#70EE70>Vingette Add</font><b>"}
 addUserKnob {22 Vingette_Clear l Clear T "nuke.thisNode().knob(\"Vin_Scale\").setValue(0.7)\nnuke.thisNode().knob(\"Vin_Feather\").setValue(0.8)\nnuke.thisNode().knob(\"Vin_Gain\").setValue(1)" +STARTLINE}
 addUserKnob {6 Vingette_Enable l Enable -STARTLINE}
 Vingette_Enable true
 addUserKnob {18 Vin_Gain l Gain}
 Vin_Gain 0.35
 addUserKnob {6 Vin_Gain_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Vin_Gain_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Vin_Gain_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Vin_Gain_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 Vin_Scale l Scale R 0.5 4}
 Vin_Scale 0.7
 addUserKnob {7 Vin_Feather l Feather}
 Vin_Feather 0.8
 addUserKnob {12 Vin_Offset l Center}
 addUserKnob {6 Vin_HighlightPrio l "Highlight Preservation" +STARTLINE}
 Vin_HighlightPrio true
 addUserKnob {4 Vin_Method l "" -STARTLINE M {Straight Ease Gaussian "" ""}}
 addUserKnob {7 Vin_HilightIn l In R 0 3}
 addUserKnob {7 Vin_HilightOut l Out -STARTLINE R 0.5 3}
 Vin_HilightOut 0.98
 addUserKnob {26 VingetteOver_DEVIDER l "<b><font color=#70EE70>Vingette Over</font><b>"}
 addUserKnob {22 VingetteO_Clear l Clear T "nuke.thisNode().knob(\"VinO_Scale\").setValue(0.5)\nnuke.thisNode().knob(\"VinO_Feather\").setValue(0.5)\nnuke.thisNode().knob(\"VinO_Opacity\").setValue(0)\nnuke.thisNode().knob(\"VinO_Tint\").setValue(0.5,0)\nnuke.thisNode().knob(\"VinO_Tint\").setValue(0.5,1)\nnuke.thisNode().knob(\"VinO_Tint\").setValue(0.5,2)" +STARTLINE}
 addUserKnob {6 VingetteO_Enable l Enable -STARTLINE}
 VingetteO_Enable true
 addUserKnob {7 VinO_Opacity l Opacity}
 VinO_Opacity 0.14
 addUserKnob {6 VinO_Invert l Inverse -STARTLINE}
 VinO_Invert true
 addUserKnob {7 VinO_Scale l Scale R 0 4}
 VinO_Scale 0.5
 addUserKnob {7 VinO_Feather l Feather}
 VinO_Feather 1
 addUserKnob {12 VinO_Offset l Center}
 addUserKnob {18 VinO_Tint l Tint R 0 2}
 VinO_Tint {0.447041 0.040836 0.5}
 addUserKnob {6 VinO_Tint_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 VinO_Tint_panelDropped true
 addUserKnob {6 VinO_Tint_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 VinO_Tint_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 VinO_Tint_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 Effects}
 addUserKnob {26 Sharpen_DEVIDER l "<b><font color=#70EE70>Sharpen</font><b>"}
 addUserKnob {22 Sharpen_Clear l Clear T "nuke.thisNode().knob(\"Grain_Size\").setValue(1)\nnuke.thisNode().knob(\"Grain_Intensity\").setValue(0.25)" +STARTLINE}
 addUserKnob {6 Sharpen_Enable l Enable -STARTLINE}
 addUserKnob {7 Sharpen_1 l Sharpen}
 Sharpen_1 0.4
 addUserKnob {26 Grain_DEVIDER l "<b><font color=#70EE70>Grain</font><b>"}
 addUserKnob {22 Grain_Clear l Clear T "nuke.thisNode().knob(\"Grain_Size\").setValue(1)\nnuke.thisNode().knob(\"Grain_Intensity\").setValue(0.25)" +STARTLINE}
 addUserKnob {6 Grain_Enable l Enable -STARTLINE}
 Grain_Enable true
 addUserKnob {7 Grain_Size l Size R 0 8}
 Grain_Size 1
 addUserKnob {7 Grain_Intensity l Intensity}
 Grain_Intensity 0.25
 addUserKnob {26 Mist_DEVIDER l "<b><font color=#70EE70>Mist</font><b>"}
 addUserKnob {22 Mist_Clear l Clear T "nuke.thisNode().knob(\"Grain_Size\").setValue(1)\nnuke.thisNode().knob(\"Grain_Intensity\").setValue(0.25)" +STARTLINE}
 addUserKnob {6 Mist_Enable l Enable -STARTLINE}
 addUserKnob {7 Mist_Opacity l Opacity}
 Mist_Opacity 1
 addUserKnob {7 Mist_Gamma l "Selection Curve"}
 Mist_Gamma 1
 addUserKnob {7 Feather}
 Feather 1
 addUserKnob {7 Mist_ColorMix l "Color Mix"}
 Mist_ColorMix 1
 addUserKnob {6 Mist_Premultiplied l Premult -STARTLINE}
 Mist_Premultiplied true
 addUserKnob {20 Mask}
 addUserKnob {26 Devider_Mask l Mask}
 addUserKnob {41 mix -STARTLINE T Merge18.mix}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge18.invert_mask}
}
 BackdropNode {
  inputs 0
  name BackdropNode16
  tile_color 0x63c681ff
  label "Hue Curves"
  note_font_size 42
  xpos 455
  ypos 779
  bdwidth 1236
  bdheight 482
  z_order -1
 }
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0xafc663ff
  label Lift/Gain/Gamma
  note_font_size 42
  xpos 467
  ypos -269
  bdwidth 540
  bdheight 583
 }
 BackdropNode {
  inputs 0
  name BackdropNode10
  tile_color 0x6369c6ff
  label "Overlay Vingette"
  note_font_size 42
  xpos 467
  ypos 2846
  bdwidth 445
  bdheight 122
 }
 BackdropNode {
  inputs 0
  name BackdropNode11
  tile_color 0x63c0c6ff
  label "Primaries Offset"
  note_font_size 42
  xpos 462
  ypos 1821
  bdwidth 483
  bdheight 276
 }
 BackdropNode {
  inputs 0
  name BackdropNode12
  tile_color 0x639fc6ff
  label "Two Strip (NYI)"
  note_font_size 42
  xpos 464
  ypos 2154
  bdwidth 452
  bdheight 202
 }
 BackdropNode {
  inputs 0
  name BackdropNode13
  tile_color 0x8863c6ff
  label Mist
  note_font_size 42
  xpos 464
  ypos 3227
  bdwidth 496
  bdheight 179
 }
 BackdropNode {
  inputs 0
  name BackdropNode14
  tile_color 0x9763c6ff
  label Grain
  note_font_size 42
  xpos 464
  ypos 3417
  bdwidth 498
  bdheight 140
 }
 BackdropNode {
  inputs 0
  name BackdropNode15
  tile_color 0x7363c6ff
  label Sharpen
  note_font_size 42
  xpos 468
  ypos 3034
  bdwidth 500
  bdheight 177
 }
 BackdropNode {
  inputs 0
  name BackdropNode17
  tile_color 0xaa5555ff
  label ColorMixer
  note_font_size 42
  xpos 489
  ypos -1823
  bdwidth 515
  bdheight 349
 }
 BackdropNode {
  inputs 0
  name BackdropNode19
  tile_color 0x6dc663ff
  label "Curves (NYI)"
  note_font_size 42
  xpos 464
  ypos 560
  bdwidth 539
  bdheight 152
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0xc67a63ff
  label "Black & White Mix (NYI)"
  note_font_size 42
  xpos 490
  ypos -1447
  bdwidth 517
  bdheight 319
 }
 BackdropNode {
  inputs 0
  name BackdropNode20
  tile_color 0xaaaaaa00
  label REPLACE
  note_font_size 42
  xpos 956
  ypos 1820
  bdwidth 288
  bdheight 275
 }
 BackdropNode {
  inputs 0
  name BackdropNode21
  tile_color 0xaaaaaa00
  label "YCbCr Rotation"
  note_font_size 42
  xpos 1436
  ypos 1822
  bdwidth 313
  bdheight 272
 }
 BackdropNode {
  inputs 0
  name BackdropNode22
  tile_color 0x91c663ff
  label Shadow/Midtone/Highlights
  note_font_size 42
  xpos 465
  ypos 357
  bdwidth 545
  bdheight 155
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x63c6a8ff
  label "Split Toning"
  note_font_size 42
  xpos 457
  ypos 1312
  bdwidth 443
  bdheight 365
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  tile_color 0xaaaaaa00
  label SHIFT
  note_font_size 42
  xpos 1264
  ypos 1821
  bdwidth 158
  bdheight 276
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x388e8e00
  label "Used to store curves.\n(Do NOT cut and paste)"
  note_font_size 20
  xpos 1414
  ypos 943
  bdwidth 239
  bdheight 159
 }
 BackdropNode {
  inputs 0
  name BackdropNode6
  tile_color 0xc6bf63ff
  label "Color Boost"
  note_font_size 42
  xpos 499
  ypos -631
  bdwidth 526
  bdheight 261
 }
 BackdropNode {
  inputs 0
  name BackdropNode7
  tile_color 0xc69563ff
  label "Temperature & Tint"
  note_font_size 42
  xpos 499
  ypos -1091
  bdwidth 511
  bdheight 188
 }
 BackdropNode {
  inputs 0
  name BackdropNode8
  tile_color 0xc6aa63ff
  label "Base Color Correction"
  note_font_size 42
  xpos 499
  ypos -859
  bdwidth 516
  bdheight 182
 }
 BackdropNode {
  inputs 0
  name BackdropNode9
  tile_color 0x6387c6ff
  label "Gain Vingette"
  note_font_size 42
  xpos 467
  ypos 2519
  bdwidth 439
  bdheight 265
 }
 Input {
  inputs 0
  name Input
  xpos 509
  ypos -2122
 }
 Dot {
  name Dot47
  xpos 543
  ypos -2059
 }
set N68171c00 [stack 0]
 Shuffle {
  alpha white
  name Shuffle21
  xpos 509
  ypos -2007
 }
 Dot {
  name Dot33
  xpos 543
  ypos -1708
 }
set N68171400 [stack 0]
 Dot {
  name Dot32
  xpos 749
  ypos -1708
 }
 ColorMatrix {
  matrix {
      {{(parent.NoOp1.RED.r/(parent.NoOp1.RED.r+parent.NoOp1.RED.g+parent.NoOp1.RED.b)*(parent.NoOp1.RED.r>=0?parent.NoOp1.RED.r:-parent.NoOp1.RED.r))} {(parent.NoOp1.RED.g/(parent.NoOp1.RED.r+parent.NoOp1.RED.g+parent.NoOp1.RED.b)*(parent.NoOp1.RED.g>=0?parent.NoOp1.RED.g:-parent.NoOp1.RED.g))} {(parent.NoOp1.RED.b/(parent.NoOp1.RED.r+parent.NoOp1.RED.g+parent.NoOp1.RED.b)*(parent.NoOp1.RED.b>=0?parent.NoOp1.RED.b:-parent.NoOp1.RED.b))}}
      {{(parent.NoOp1.Green.r/(parent.NoOp1.Green.r+parent.NoOp1.Green.g+parent.NoOp1.Green.b)*(parent.NoOp1.Green.r>=0?parent.NoOp1.Green.r:-parent.NoOp1.Green.r))} {(parent.NoOp1.Green.g/(parent.NoOp1.Green.r+parent.NoOp1.Green.g+parent.NoOp1.Green.b)*(parent.NoOp1.Green.g>=0?parent.NoOp1.Green.g:-parent.NoOp1.Green.g))} {(parent.NoOp1.Green.b/(parent.NoOp1.Green.r+parent.NoOp1.Green.g+parent.NoOp1.Green.b)*(parent.NoOp1.Green.b>=0?parent.NoOp1.Green.b:-parent.NoOp1.Green.b))}}
      {{(parent.NoOp1.Blue.r/(parent.NoOp1.Blue.r+parent.NoOp1.Blue.g+parent.NoOp1.Blue.b)*(parent.NoOp1.Blue.r>=0?parent.NoOp1.Blue.r:-parent.NoOp1.Blue.r))} {(parent.NoOp1.Blue.g/(parent.NoOp1.Blue.r+parent.NoOp1.Blue.g+parent.NoOp1.Blue.b)*(parent.NoOp1.Blue.g>=0?parent.NoOp1.Blue.g:-parent.NoOp1.Blue.g))} {(parent.NoOp1.Blue.b/(parent.NoOp1.Blue.r+parent.NoOp1.Blue.g+parent.NoOp1.Blue.b)*(parent.NoOp1.Blue.b>=0?parent.NoOp1.Blue.b:-parent.NoOp1.Blue.b))}}
    }
  name ColorMatrix3
  xpos 715
  ypos -1633
 }
 Expression {
  expr0 isnan(r)==1?0:r
  expr1 isnan(g)==1?0:g
  expr2 isnan(b)==1?0:b
  name Expression3
  xpos 715
  ypos -1530
 }
push $N68171400
 Switch {
  inputs 2
  which {{parent.ColorMixer_Enable}}
  name Switch1
  xpos 509
  ypos -1530
 }
 Dot {
  name Dot12
  xpos 543
  ypos -1354
 }
set N68170400 [stack 0]
 Dot {
  name Dot13
  xpos 814
  ypos -1354
 }
 Saturation {
  saturation 0
  mode Maximum
  name Saturation1
  xpos 780
  ypos -1250
 }
set N68195c00 [stack 0]
 Dot {
  name Dot14
  xpos 814
  ypos -1153
 }
push $N68195c00
 ColorLookup {
  lut {master {curve C x0.008857131004 0 s0.400000006 v1.05014801 L x0.7664735317 1 s0.5 t0 u1.130736947}
    red {}
    green {}
    blue {}
    alpha {}}
  name ColorLookup1
  xpos 678
  ypos -1250
 }
 Shuffle {
  green red
  blue red
  alpha red
  name Shuffle3
  xpos 678
  ypos -1224
 }
push $N68170400
 HueKeyer {
  lut {amount {curve L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0}
    sat_thrsh {curve 0}}
  invert false
  name BlackAndWhite
  xpos 509
  ypos -1331
  disable {{1-parent.BW_Enable}}
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle2
  xpos 509
  ypos -1285
  disable {{1-parent.BW_Enable}}
 }
set N68194800 [stack 0]
 Shuffle {
  red white
  green white
  blue white
  alpha white
  name Shuffle4
  xpos 619
  ypos -1285
 }
 Dot {
  name Dot15
  xpos 653
  ypos -1252
 }
push $N68194800
 Blur {
  size {{75*parent.BWSoftFilter}}
  filter box
  quality 2
  name Blur2
  xpos 509
  ypos -1259
  disable {{1-parent.BW_Enable}}
 }
 Merge2 {
  inputs 2+1
  maskChannelMask rgba.red
  name Merge1
  xpos 509
  ypos -1224
  disable {{1-parent.BW_Enable}}
 }
set N681bf800 [stack 0]
 Merge2 {
  inputs 2
  operation multiply
  name Merge4
  xpos 509
  ypos -1157
  disable {{1-parent.BW_Enable}}
 }
 Colorspace {
  colorspace_out CIE-XYZ
  name Colorspace3
  xpos 509
  ypos -1011
  disable {{1-parent.General_Enable}}
 }
 Grade {
  white {1 {parent.Tint*0.1+0.9} {parent.Temperature*0.5+0.5} 1}
  black_clamp false
  name Grade2
  xpos 509
  ypos -972
  disable {{parent.Colorspace3.disable}}
 }
set N681bec00 [stack 0]
 Colorspace {
  colorspace_in CIE-XYZ
  name Colorspace7
  xpos 509
  ypos -933
  disable {{parent.Colorspace3.disable}}
 }
 Saturation {
  saturation {{parent.Saturation}}
  name Saturation2
  xpos 509
  ypos -795
  disable {{1-parent.General_Enable}}
 }
 Grade {
  black_clamp false
  name BaseGrade
  xpos 509
  ypos -769
  disable {{1-parent.General_Enable}}
 }
set N681be000 [stack 0]
 EXPTool {
  mode Stops
  name Exposure1
  xpos 509
  ypos -743
  disable {{parent.red==0?1:1-parent.General_Enable}}
 }
 Expression {
  temp_name0 Gamma
  temp_expr0 parent.Contrast
  expr0 "r<1&&r>0?r<0.5?pow(r,Gamma)*pow(0.5, 1-Gamma):1-pow(1-r,Gamma)*pow(0.5, 1-Gamma):r"
  expr1 "g<1&&g>0?g<0.5?pow(g,Gamma)*pow(0.5, 1-Gamma):1-pow(1-g,Gamma)*pow(0.5, 1-Gamma):g"
  expr2 "b<1&&b>0?b<0.5?pow(b,Gamma)*pow(0.5, 1-Gamma):1-pow(1-b,Gamma)*pow(0.5, 1-Gamma):b"
  name Expression9
  xpos 509
  ypos -717
  disable {{parent.Contrast==1?1:1-parent.General_Enable}}
 }
 Expression {
  temp_name0 Gamma
  temp_expr0 parent.Contrast
  expr0 r<1?(r>0?r:1-pow(1-r,1/(pow(Gamma,4)))):pow(r,1/(pow(Gamma,4)))
  expr1 g<1?(g>0?g:1-pow(1-g,1/(pow(Gamma,4)))):pow(g,1/(pow(Gamma,4)))
  expr2 b<1?(b>0?b:1-pow(1-b,1/(pow(Gamma,4)))):pow(b,1/(pow(Gamma,4)))
  name Expression4
  xpos 509
  ypos -691
  disable {{parent.Contrast==1?1:1-parent.General_Enable}}
 }
 Dot {
  name Dot55
  xpos 543
  ypos -576
 }
set N681ff000 [stack 0]
 Colorspace {
  colorspace_out HSV
  name Colorspace1
  xpos 509
  ypos -558
  disable {{parent.ColorBoost==1?1:1-parent.General_Enable}}
 }
 Grade {
  channels {-rgba.red rgba.green -rgba.blue none}
  gamma {{parent.ColorBoost}}
  black_clamp false
  name Grade4
  xpos 509
  ypos -532
  disable {{parent.Colorspace1.disable}}
 }
set N681fe800 [stack 0]
 Dot {
  name Dot9
  xpos 424
  ypos -528
 }
push $N681bec00
 Dot {
  name Dot11
  xpos 428
  ypos -968
 }
push $N681bf800
 Dot {
  name Dot16
  xpos 438
  ypos -1220
 }
 StickyNote {
  inputs 0
  name StickyNote10
  label "<center>Black and White Mix\n"
  xpos 335
  ypos -1233
 }
push $N681ff000
 Dot {
  name Dot56
  xpos 637
  ypos -576
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace13
  xpos 603
  ypos -454
  disable {{parent.ColorBoost==1?1:0}}
 }
push $N681fe800
 Colorspace {
  colorspace_in HSV
  name Colorspace2
  xpos 509
  ypos -506
  disable {{parent.Colorspace1.disable}}
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace14
  xpos 509
  ypos -480
  disable {{parent.Colorspace1.disable}}
 }
 ShuffleCopy {
  inputs 2
  red red
  alpha alpha2
  name ShuffleCopy2
  xpos 509
  ypos -454
  disable {{parent.Colorspace1.disable}}
 }
 Colorspace {
  colorspace_in YCbCr
  name Colorspace15
  xpos 509
  ypos -428
  disable {{parent.Colorspace1.disable}}
 }
 Dot {
  name Dot53
  xpos 543
  ypos -195
 }
set N6825fc00 [stack 0]
 Colorspace {
  colorspace_out sRGB
  name LGGColorspace_in
  xpos 509
  ypos -123
 }
set N6825f800 [stack 0]
 Dot {
  name Dot4
  xpos 772
  ypos -119
 }
 Grade {
  black {{parent.LiftEnabled?parent.Lift.a-1:0}}
  white {{parent.GainEnabled?parent.Gain.a:1}}
  gamma {{parent.GammaEnabled?parent.Gamma.a:1}}
  black_clamp false
  name LuminanceMod
  xpos 738
  ypos -17
 }
 Colorspace {
  colorspace_in {{parent.LGGColorspace_in.colorspace_out}}
  name LGGColorspace_OutL
  xpos 738
  ypos 45
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace5
  xpos 738
  ypos 100
 }
 Shuffle {
  alpha white
  name Shuffle23
  xpos 738
  ypos 164
 }
push $N6825f800
 Grade {
  black {{parent.LiftEnabled?((parent.Lift.r-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} {parent.LiftEnabled?((parent.Lift.g-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} {parent.LiftEnabled?((parent.Lift.b-((parent.Lift.r+parent.Lift.g+parent.Lift.b)/3))*1)+(parent.Lift.a)-1:0} 1}
  white {{parent.GainEnabled?((parent.Gain.r-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {parent.GainEnabled?((parent.Gain.g-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {parent.GainEnabled?((parent.Gain.b-((parent.Gain.r+parent.Gain.g+parent.Gain.b)/3))*1)+(parent.Gain.a):1} {curve}}
  gamma {{parent.GammaEnabled?((parent.Gamma.r-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {parent.GammaEnabled?((parent.Gamma.g-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {parent.GammaEnabled?((parent.Gamma.b-((parent.Gamma.r+parent.Gamma.g+parent.Gamma.b)/3))*1)+(parent.Gamma.a):1} {curve}}
  black_clamp false
  name Grade1
  xpos 510
  ypos -18
 }
 Colorspace {
  colorspace_in {{parent.LGGColorspace_in.colorspace_out}}
  name LGGColorspace_Out
  xpos 510
  ypos 54
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace4
  xpos 510
  ypos 101
  disable {{parent.LumaMix==0?1:0}}
 }
 Merge2 {
  inputs 2
  Achannels {rgba.red -rgba.green -rgba.blue rgba.alpha}
  Bchannels {rgba.red -rgba.green -rgba.blue rgba.alpha}
  output {rgba.red -rgba.green -rgba.blue rgba.alpha}
  mix {{parent.LumaMix}}
  name Merge2
  xpos 510
  ypos 158
 }
 Colorspace {
  colorspace_in YCbCr
  name Colorspace6
  xpos 510
  ypos 216
  disable {{parent.LumaMix==0?1:0}}
 }
push $N6825fc00
 Dot {
  name Dot54
  xpos 481
  ypos -195
 }
 Dot {
  name Dot52
  xpos 481
  ypos 294
 }
 Switch {
  inputs 2
  which {{parent.liftgammagain_Enable}}
  name Switch4
  xpos 509
  ypos 290
 }
 ColorCorrect {
  shadows.gain {{((parent.Shadows.r-((parent.Shadows.r+parent.Shadows.g+parent.Shadows.b)/3))*2)+(parent.Shadows.a)} {((parent.Shadows.g-((parent.Shadows.r+parent.Shadows.g+parent.Shadows.b)/3))*2)+(parent.Shadows.a)} {((parent.Shadows.b-((parent.Shadows.r+parent.Shadows.g+parent.Shadows.b)/3))*2)+(parent.Shadows.a)} 1}
  midtones.gain {{((parent.Midtones.r-((parent.Midtones.r+parent.Midtones.g+parent.Midtones.b)/3))*1)+(parent.Midtones.a)} {((parent.Midtones.g-((parent.Midtones.r+parent.Midtones.g+parent.Midtones.b)/3))*1)+(parent.Midtones.a)} {((parent.Midtones.b-((parent.Midtones.r+parent.Midtones.g+parent.Midtones.b)/3))*1)+(parent.Midtones.a)} 1}
  highlights.gain {{((parent.Highlights.r-((parent.Highlights.r+parent.Highlights.g+parent.Highlights.b)/3))*2)+(parent.Highlights.a)} {((parent.Highlights.g-((parent.Highlights.r+parent.Highlights.g+parent.Highlights.b)/3))*2)+(parent.Highlights.a)} {((parent.Highlights.b-((parent.Highlights.r+parent.Highlights.g+parent.Highlights.b)/3))*2)+(parent.Highlights.a)} 1}
  lookup {shadow {curve 1 s0 x0.5 0 s0}
    midtone {1-shadow-highlight}
    highlight {}}
  name BaseColorCorrect
  knobChanged RunNodeC()
  xpos 509
  ypos 434
  disable {{1-parent.SMH_Enable}}
  addUserKnob {20 User}
  addUserKnob {22 RunThis T "def RunNodeC():\n\tif nuke.thisKnob().Class() == \"Array_Knob\":\n\t\t\tthisNode = nuke.thisNode().fullName().split(\".\")\[-2]\n\t\t\twith nuke.Root():\n\t\t\t\tinputNode = nuke.toNode(thisNode)\n\t\t\t#nuke.message( inputNode)\n\t\t\twith inputNode:\n\t\t\t\tshadowval = nuke.toNode(inputNode.name()+\".BaseColorCorrect\").knob(\"low\").value()\n\t\t\t\thighlightval = nuke.toNode(inputNode.name()+\".BaseColorCorrect\").knob(\"High\").value()\n\t\t\t\tcurve = nuke.toNode(inputNode.name()+\".BaseColorCorrect\").knob(\"lookup\").toScript()\n\t\t\t\tmyCurve = curve.splitlines()\[0]\n\t\t\t\tmyCurve = \"shadow \{curve 1 s0 x0.5 0 s0\}\"\n\t\t\t\tmyCurve = myCurve.replace(myCurve.split(\" \")\[4]\[1:],str(shadowval))\n\t\t\t\tnuke.toNode(inputNode.name()+\".BaseColorCorrect\").knob(\"lookup\").editCurve(\"shadow\",myCurve.replace(\"shadow\",\"curve\")\[7:-1])\n\t\t\t\tmyCurve = curve.splitlines()\[2]\n\t\t\t\tmyCurve = \"highlight \{curve x0.5 0 s0 x1 1 s0\}\"\n\t\t\t\tmyCurve = myCurve.replace(myCurve.split(\" \")\[2]\[1:],str(highlightval))\n\t\t\t\tnuke.toNode(inputNode.name()+\".BaseColorCorrect\").knob(\"lookup\").editCurve(\"highlight\",myCurve.replace(\"highlight\",\"curve\")\[7:-1])\nnuke.toNode(\"BaseColorCorrect\").knob('knobChanged').setValue(\"RunNodeC()\")\n" +STARTLINE}
  addUserKnob {7 low l Low}
  low 0.5
  addUserKnob {7 High}
  High 0.5
 }
 ColorLookup {
  name ColorLookup2
  xpos 509
  ypos 660
  disable true
 }
 Dot {
  name Dot34
  xpos 543
  ypos 857
 }
set N682d5c00 [stack 0]
 Dot {
  name Dot5
  xpos 694
  ypos 857
 }
set N682d5800 [stack 0]
 Colorspace {
  colorspace_out HSL
  name Hue_HSL_To
  xpos 660
  ypos 888
 }
set N682d5400 [stack 0]
 Grade {
  multiply 6
  black_clamp false
  name Grade8
  xpos 1064
  ypos 888
 }
 Dot {
  name Dot39
  xpos 1174
  ypos 892
 }
set N682d4c00 [stack 0]
 Dot {
  name Dot40
  xpos 1284
  ypos 892
 }
 Shuffle {
  red blue
  green blue
  alpha blue
  name Shuffle17
  xpos 1250
  ypos 934
 }
 ColorLookup {
  lut {master {curve L x-1 0.5 0.5 x6 0.5 K x7 0.5}
    red {}
    green {}
    blue {}
    alpha {}}
  name SatVsLum
  xpos 1250
  ypos 960
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle18
  xpos 1250
  ypos 986
 }
 Grade {
  channels rgba
  multiply 2
  black_clamp false
  name Grade9
  xpos 1250
  ypos 1012
 }
 Dot {
  name Dot38
  xpos 1284
  ypos 1164
 }
push $N682d4c00
 Shuffle {
  red green
  blue green
  alpha green
  name Shuffle16
  xpos 1140
  ypos 934
 }
 ColorLookup {
  lut {master {curve L x-1 0.5 0.5 x6 0.5 K x7 0.5}
    red {}
    green {}
    blue {}
    alpha {}}
  name SatVsSat
  xpos 1140
  ypos 960
 }
 Shuffle {
  green red
  blue red
  alpha red
  name Shuffle19
  xpos 1140
  ypos 986
 }
 Grade {
  channels rgba
  multiply 2
  black_clamp false
  name Grade11
  xpos 1140
  ypos 1012
 }
 Dot {
  name Dot41
  xpos 1174
  ypos 1138
 }
push $N682d5800
 Dot {
  name Dot36
  xpos 804
  ypos 857
 }
set N68333c00 [stack 0]
 Dot {
  name Dot42
  xpos 914
  ypos 857
 }
set N68333800 [stack 0]
 Dot {
  name Dot43
  xpos 1024
  ypos 857
 }
 HueKeyer {
  lut {amount {curve i L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0}
    sat_thrsh {curve 0 x6 0 s0}}
  invert false
  name HueVsLum
  xpos 990
  ypos 939
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle20
  xpos 990
  ypos 977
 }
 Grade {
  multiply 2
  black_clamp false
  name Grade12
  xpos 990
  ypos 1003
 }
 Dot {
  name Dot45
  xpos 1024
  ypos 1106
 }
push $N68333800
 HueKeyer {
  lut {amount {curve L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0}
    sat_thrsh {}}
  invert false
  name HueVsSat
  xpos 880
  ypos 939
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle15
  xpos 880
  ypos 977
 }
 Grade {
  multiply 2
  black_clamp false
  name Grade10
  xpos 880
  ypos 1003
 }
 Dot {
  name Dot44
  xpos 914
  ypos 1068
 }
push $N682d5400
push $N68333c00
 HueKeyer {
  lut {amount {curve L 0.5 s0 0.5 s-0 t0 0.5 s0 0.5 s0 0.5 s0 0.5 s0 0.5 s0}
    sat_thrsh {curve 0 x6 0 s0}}
  invert false
  name HueVsHue
  xpos 770
  ypos 913
 }
 Shuffle {
  red alpha
  green alpha
  blue alpha
  name Shuffle14
  xpos 770
  ypos 951
 }
 MergeExpression {
  inputs 2
  expr0 ((B.Red-0.5)*((A.Blue*2)-0.5))+0.5
  name MergeExpression1
  xpos 770
  ypos 977
  disable true
 }
 Grade {
  channels rgba
  add 0.5
  black_clamp false
  name Grade7
  xpos 770
  ypos 1003
 }
 Dot {
  name Dot46
  xpos 804
  ypos 1036
 }
push $N682d5400
 Merge2 {
  inputs 2
  operation plus
  Achannels {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  Bchannels {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  name Merge13
  xpos 660
  ypos 1032
 }
 Merge2 {
  inputs 2
  operation multiply
  Achannels {-rgba.red rgba.green -rgba.blue rgba.alpha}
  Bchannels {-rgba.red rgba.green -rgba.blue rgba.alpha}
  output {-rgba.red rgba.green -rgba.blue rgba.alpha}
  name Merge16
  xpos 660
  ypos 1058
 }
 Merge2 {
  inputs 2
  operation multiply
  Achannels {-rgba.red -rgba.green rgba.blue rgba.alpha}
  Bchannels {-rgba.red -rgba.green rgba.blue rgba.alpha}
  output {-rgba.red -rgba.green rgba.blue rgba.alpha}
  name Merge17
  xpos 660
  ypos 1096
 }
 Merge2 {
  inputs 2
  operation multiply
  Achannels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  Bchannels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  name Merge15
  xpos 660
  ypos 1134
 }
 Merge2 {
  inputs 2
  operation multiply
  Achannels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  Bchannels {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  name Merge14
  xpos 660
  ypos 1160
 }
 Colorspace {
  colorspace_in HSL
  name Hue_HSL_From
  xpos 660
  ypos 1186
 }
 Dot {
  name Dot37
  xpos 694
  ypos 1223
 }
push $N682d5c00
 Switch {
  inputs 2
  which {{parent.HueShift_Enable}}
  name Switch3
  xpos 509
  ypos 1219
 }
 Dot {
  name Dot17
  xpos 543
  ypos 1372
 }
set N6838a000 [stack 0]
 Colorspace {
  colorspace_out HSL
  name Colorspace8
  xpos 709
  ypos 1368
 }
set N683c5c00 [stack 0]
 Dot {
  name Dot18
  xpos 837
  ypos 1459
 }
 Grade {
  white {{1+(parent.Split_Contrast/2)}}
  add {{parent.Split_Offset}}
  gamma {{1-(parent.Split_Contrast/2)}}
  black_clamp false
  name Grade3
  xpos 803
  ypos 1631
 }
 Shuffle {
  name Shuffle9
  xpos 711
  ypos 1631
 }
push $N683c5c00
 Expression {
  expr0 parent.Split_Bright_Hue
  expr1 parent.Split_Bright_Sat
  name Expression5
  xpos 709
  ypos 1434
 }
 Colorspace {
  colorspace_in HSL
  name Colorspace9
  xpos 709
  ypos 1513
 }
 Shuffle {
  alpha white
  name Shuffle1
  xpos 709
  ypos 1539
 }
push $N683c5c00
 Expression {
  expr0 parent.Split_Dark_Hue
  expr1 parent.Split_Dark_Sat
  name Expression6
  xpos 601
  ypos 1435
 }
 Colorspace {
  colorspace_in HSL
  name Colorspace10
  xpos 601
  ypos 1514
 }
 Shuffle {
  alpha white
  name Shuffle5
  xpos 601
  ypos 1540
 }
 Merge2 {
  inputs 2+1
  maskChannelMask rgba.blue
  name Merge5
  xpos 601
  ypos 1631
 }
push $N6838a000
 Merge2 {
  inputs 2
  mix {{parent.Split_Mix}}
  name Merge6
  xpos 509
  ypos 1631
  disable {{1-parent.SplitToning_Enable}}
 }
set N683f9000 [stack 0]
 Dot {
  name Dot19
  xpos 391
  ypos 1635
 }
 StickyNote {
  inputs 0
  name StickyNote11
  label "<center>Split Toning\n"
  xpos 322
  ypos 1621
 }
push $N683f9000
 Dot {
  name Dot20
  xpos 543
  ypos 1900
 }
set N683f8400 [stack 0]
 Dot {
  name Dot58
  xpos 1059
  ypos 1900
 }
set N683f8000 [stack 0]
 Dot {
  name Dot21
  xpos 1177
  ypos 1900
 }
set N6841fc00 [stack 0]
 Dot {
  name Dot57
  xpos 1349
  ypos 1900
 }
set N6841f800 [stack 0]
 Dot {
  name Dot60
  xpos 1588
  ypos 1900
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace16
  xpos 1554
  ypos 1931
 }
 Expression {
  temp_name0 cosThetaB
  temp_expr0 "cos((RotationB+180) * (PI / 180))"
  temp_name1 sinThetaB
  temp_expr1 "sin((RotationB+180) * (PI / 180))"
  temp_name2 cosTheta
  temp_expr2 "cos(Rotation * (PI / 180))"
  temp_name3 sinTheta
  temp_expr3 "sin(Rotation * (PI / 180))"
  expr1 "(cosTheta * (g - 0.5) - sinTheta * (b - 0.5) + 0.5)"
  expr2 "(sinThetaB * (g - 0.5) - cosThetaB * (b - 0.5) + 0.5)"
  name Expression7
  xpos 1554
  ypos 1957
  addUserKnob {20 User}
  addUserKnob {7 Rotation R -180 180}
  Rotation {{180*parent.Prim_HueRed}}
  addUserKnob {7 RotationB R -180 180}
  RotationB {{180*parent.Prim_HueGreen}}
 }
 Colorspace {
  colorspace_in YCbCr
  name Colorspace17
  xpos 1554
  ypos 1983
 }
 Dot {
  name Dot61
  xpos 1588
  ypos 2063
 }
push $N6841f800
 ColorMatrix {
  matrix {
      {{(1+(parent.Prim_HueBlue))+(parent.Prim_HueGreen)} {-parent.Prim_HueGreen} {-parent.Prim_HueBlue}}
      {{parent.Prim_HueRed} {(1+(-parent.Prim_HueBlue))-(parent.Prim_HueRed)} {parent.Prim_HueBlue}}
      {{-parent.Prim_HueRed} {parent.Prim_HueGreen} {(1+(-parent.Prim_HueGreen))+parent.Prim_HueRed}}
    }
  name ShiftMatrix
  label "Custom Recipe \nBy Mads Hagbarth Lund"
  note_font "Verdana Bold"
  note_font_size 9
  xpos 1315
  ypos 1965
 }
 Dot {
  name Dot59
  xpos 1349
  ypos 2025
 }
push $N6841fc00
 Keyer {
  invert true
  operation "luminance key"
  range {0.5795876367 1 1 1}
  name Keyer1
  xpos 1143
  ypos 1971
 }
push $N683f8000
 ColorMatrix {
  inputs 1+1
  matrix {
      {1 {parent.Prim_HueGreen} {-parent.Prim_HueBlue}}
      {{-parent.Prim_HueRed} 1 {parent.Prim_HueBlue}}
      {{parent.Prim_HueRed} {-parent.Prim_HueGreen} 1}
    }
  name ReplaceMatrix
  label "Custom Recipe \nBy Mads Hagbarth Lund"
  note_font "Verdana Bold"
  note_font_size 9
  xpos 1025
  ypos 1964
 }
 Switch {
  inputs 3
  which {{parent.PO_Method}}
  name Switch7
  xpos 722
  ypos 2059
 }
push $N683f8400
 Switch {
  inputs 2
  which {{parent.Primaries_Enable}}
  name Switch6
  xpos 511
  ypos 2059
 }
set N6837cd80 [stack 0]
 Dot {
  name Dot23
  xpos 543
  ypos 2218
 }
set N68449000 [stack 0]
 Dot {
  name Dot24
  xpos 643
  ypos 2218
 }
set N68448c00 [stack 0]
 Shuffle {
  blue green
  alpha white
  name Shuffle6
  xpos 719
  ypos 2214
 }
push $N68448c00
 Shuffle {
  green blue
  alpha white
  name Shuffle7
  xpos 609
  ypos 2256
 }
 Merge2 {
  inputs 2
  mix 0.445
  name Merge7
  xpos 719
  ypos 2256
 }
push $N68448c00
 Merge2 {
  inputs 2
  mix 0.6
  name Merge8
  selected true
  xpos 719
  ypos 2299
 }
push $N68449000
 AddMix {
  inputs 2
  mix {{parent.Split_Mix}}
  name AddMix1
  xpos 509
  ypos 2299
  disable true
 }
set N68477800 [stack 0]
 Dot {
  name Dot25
  xpos 374
  ypos 2303
 }
 StickyNote {
  inputs 0
  name StickyNote13
  label "<center>Two Strip\n"
  xpos 305
  ypos 2289
 }
 StickyNote {
  inputs 0
  name StickyNote9
  label "<center>Converting to CIE-XYZ\nfor control.\nWill disable if values are default"
  xpos 268
  ypos -979
 }
push $N6837cd80
 Dot {
  name Dot22
  xpos 379
  ypos 2063
 }
 StickyNote {
  inputs 0
  name StickyNote12
  label "<center>Prim Offset\nFor post balancing\n"
  xpos 310
  ypos 2049
 }
push $N68171c00
 Dot {
  name Dot49
  xpos 95
  ypos -2059
 }
 Dot {
  name Dot48
  xpos 95
  ypos 3790
 }
 Dot {
  name Dot50
  xpos 453
  ypos 3790
 }
set N68499800 [stack 0]
 Input {
  inputs 0
  name Mask
  xpos 748
  ypos 3786
  number 1
 }
push $N68477800
 Dot {
  name Dot26
  xpos 543
  ypos 2455
 }
set N68499000 [stack 0]
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name Shuffle8
  xpos 742
  ypos 2451
 }
 Dot {
  name Dot27
  xpos 924
  ypos 2455
 }
 Dot {
  name Dot28
  xpos 924
  ypos 2718
 }
set N68498400 [stack 0]
 Dot {
  name Dot29
  xpos 924
  ypos 2915
 }
 Radial {
  invert {{parent.VinO_Invert}}
  area {{((width/2)-(width*parent.VinO_Scale))+(width*((VinO_Offset.x)/1000))} {((height/2)-(height*parent.VinO_Scale))+(height*((VinO_Offset.y)/1000))} {((width/2)+(width*parent.VinO_Scale))+(width*((VinO_Offset.x)/1000))} {((height/2)+(height*parent.VinO_Scale))+(height*((VinO_Offset.y)/1000))}}
  softness {{parent.VinO_Feather}}
  color {{parent.VinO_Tint} {parent.VinO_Tint} {parent.VinO_Tint} {parent.VinO_Tint}}
  name Radial2
  xpos 737
  ypos 2911
 }
push $N68499000
 Dot {
  name Dot30
  xpos 543
  ypos 2596
 }
set N684b1800 [stack 0]
 Keyer {
  invert true
  operation "luminance key"
  range {{parent.Vin_HilightIn} {parent.Vin_HilightOut} 999999 999999}
  name Keyer2
  xpos 636
  ypos 2586
 }
set N684b1400 [stack 0]
 Expression {
  expr3 "( 1- exp( -4 * pow2(a)) ) * 1.018657"
  name Expression1
  xpos 713
  ypos 2634
 }
push $N684b1400
 Expression {
  expr3 "0.5 - 0.5 * cos( a * pi )"
  name Expression2
  xpos 565
  ypos 2629
 }
push $N684b1400
 Switch {
  inputs 3
  which {{parent.Vin_Method}}
  name Switch2
  xpos 636
  ypos 2672
 }
push $N68498400
 Radial {
  invert true
  area {{((width/2)-(width*parent.Vin_Scale))+(width*((Vin_Offset.x)/1000))} {((height/2)-(height*parent.Vin_Scale))+(width*((Vin_Offset.y)/1000))} {((width/2)+(width*parent.Vin_Scale))+(width*((Vin_Offset.x)/1000))} {((height/2)+(height*parent.Vin_Scale))+(width*((Vin_Offset.y)/1000))}}
  softness {{parent.Vin_Feather}}
  name Radial1
  xpos 740
  ypos 2714
 }
 Merge2 {
  inputs 2
  operation multiply
  mix 0.085
  name Merge9
  xpos 636
  ypos 2714
  disable {{1-parent.Vin_HighlightPrio}}
 }
push $N684b1800
 Grade {
  inputs 1+1
  white {{parent.Vin_Gain}}
  black_clamp false
  name Grade5
  xpos 509
  ypos 2714
  disable {{1-parent.Vingette_Enable x1 1}}
 }
 Merge2 {
  inputs 2
  mix {{parent.VinO_Opacity/5}}
  name Merge10
  xpos 509
  ypos 2911
  disable {{1-parent.VingetteO_Enable}}
 }
 Clamp {
  maximum_enable false
  name Clamp1
  xpos 509
  ypos 3049
  disable {{parent.Sharpen1.disable}}
 }
 Colorspace {
  colorspace_out Cineon
  name Colorspace18
  xpos 509
  ypos 3087
  disable {{parent.Sharpen1.disable}}
 }
 Colorspace {
  colorspace_out YCbCr
  name Colorspace11
  xpos 509
  ypos 3113
  disable {{parent.Sharpen1.disable}}
 }
 Sharpen {
  channels {rgba.red -rgba.green -rgba.blue none}
  amount {{parent.Sharpen_1*6}}
  name Sharpen1
  xpos 509
  ypos 3139
  disable {{1-parent.Sharpen_Enable}}
 }
 Colorspace {
  colorspace_in YCbCr
  name Colorspace12
  xpos 509
  ypos 3165
  disable {{parent.Sharpen1.disable}}
 }
 Colorspace {
  colorspace_in Cineon
  name Colorspace19
  xpos 509
  ypos 3191
  disable {{parent.Sharpen1.disable}}
 }
 Dot {
  name Dot35
  xpos 543
  ypos 3257
 }
set N684f2000 [stack 0]
 Keyer {
  operation "luminance key"
  name Keyer3
  xpos 636
  ypos 3247
 }
 Premult {
  name Premult1
  xpos 636
  ypos 3281
  disable {{1-parent.Mist_Premultiplied}}
 }
 Grade {
  channels rgba
  gamma {{parent.Mist_Gamma}}
  black_clamp false
  name Grade6
  xpos 636
  ypos 3307
 }
 Blur {
  size {{(parent.Feather+0.3)*1000}}
  name Blur1
  xpos 636
  ypos 3332
 }
 Expression {
  expr0 a
  expr1 a
  expr2 a
  mix {{1-parent.Mist_ColorMix}}
  name Expression8
  xpos 636
  ypos 3370
 }
push $N684f2000
 Merge2 {
  inputs 2
  Achannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  Bchannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  output {rgba.red rgba.green rgba.blue -rgba.alpha}
  mix {{parent.Mist_Opacity}}
  name Merge12
  xpos 509
  ypos 3370
  disable {{1-parent.Mist_Enable}}
 }
 Group {
  name Grain
  help "Adds synthetic grain. Push \"presets\" to get predefined types of grain, these are the correct size for 2K scans.\n\nYou can also adjust the sliders to match a sample piece of grain. Find a sample with a rather constant background, blur it to remove the grain, and use as input to this. View with a wipe in the viewer so you can make a match. It helps to view and match each of the red, green, blue separately."
  xpos 509
  ypos 3487
  disable {{1-parent.Grain_Enable}}
  addUserKnob {20 "" l User}
  addUserKnob {3 seed t "Change this value to make different instances of this operator produce different noise"}
  seed 134
  addUserKnob {35 presets l "" -STARTLINE M {"presets/Kodak 5248" "knobs this \{red_size 3.30 green_size 2.90 blue_size 2.5 red_i 0.60 green_i 0.60 blue_i 0.60 red_m 0.42 green_m 0.46 blue_m 0.85 black 0.00 label \{Kodak 5248\}\}" "presets/Kodak 5279" "knobs this \{red_size 2.70 green_size 2.60 blue_size 2.40 red_i 1.00 green_i 0.76 blue_i 0.65 red_m 0.37 green_m 0.60 blue_m 1.65 black 0.00 label \{Kodak 5279\}\}" "presets/Kodak FX214" "knobs this \{red_size 1.87 green_size 2.60 blue_size 2.44 red_i 1 green_i 0.76 blue_i 0.79 red_m 0.41 green_m 0.60 blue_m 1.80 black 0.00 label \{Kodak FX214\}\}" "presets/Kodak GT5274" "knobs this \{red_size 0.04 green_size 0.10 blue_size 0.90 red_i 0.90 green_i 0.76 blue_i 0.81 red_m 0.49 green_m 0.50 blue_m 1.55 black 0.00 label \{Kodak GT5274\}\}" "presets/Kodak 5217" "knobs this \{red_size 0.23 green_size 1.20 blue_size 1.40 red_i 0.60 green_i 0.86 blue_i 0.60 red_m 0.48 green_m 0.42 blue_m 0.87 black 0.00 label \{Kodak 5217\}\}" "presets/Kodak 5218" "knobs this \{red_size 0.10 green_size 1.60 blue_size 1.91 red_i 0.60 green_i 0.86 blue_i 0.73 red_m 0.38 green_m 0.17 blue_m 0.87 black 0.00 label \{Kodak 5218\}\}" presets/other "knobs this \{label other\}"}}
  addUserKnob {26 "" l "@b;Size"}
  addUserKnob {14 red_size l red R 0 100}
  red_size {{parent.Grain_Size}}
  addUserKnob {14 green_size l green R 0 100}
  green_size {{parent.Grain_Size}}
  addUserKnob {14 blue_size l blue R 0 100}
  blue_size {{parent.Grain_Size}}
  addUserKnob {26 "" l "@b;Irregularity"}
  addUserKnob {7 red_i l red}
  red_i 0.6
  addUserKnob {7 green_i l green}
  green_i 0.6
  addUserKnob {7 blue_i l blue}
  blue_i 0.6
  addUserKnob {26 "" l "@b;Intensity"}
  addUserKnob {7 red_m l red t "Amount of grain to add to a white pixel"}
  red_m {{parent.Grain_Intensity}}
  addUserKnob {7 green_m l green}
  green_m {{parent.Grain_Intensity}}
  addUserKnob {7 blue_m l blue}
  blue_m {{parent.Grain_Intensity}}
  addUserKnob {18 black t "Amount of grain to add everywhere"}
  black {0 0 0}
  addUserKnob {6 black_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 black_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 black_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 black_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 minimum t "Minimum black level" R 0 0.01}
  minimum {0 0 0}
  addUserKnob {6 minimum_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 minimum_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 minimum_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 minimum_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {26 "" l "@b;Mask"}
  addUserKnob {6 maskgrain l "Apply only through alpha" -STARTLINE}
  addUserKnob {41 maskinvert l "Invert alpha" -STARTLINE T Copy1.invert_mask}
 }
  Input {
   inputs 0
   name Input1
   xpos 0
  }
set N6852a400 [stack 0]
  Noise {
   output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
   cliptype none
   replace true
   size {{parent.red_size.w} {parent.red_size.h}}
   zoffset {{frame+seed+red_i/2}}
   octaves 2
   gamma 1
   xrotate {{red_i*45}}
   yrotate {{red_i*45}}
   name red
   xpos 220
  }
  Noise {
   output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
   cliptype none
   replace true
   size {{parent.green_size.w} {parent.green_size.h}}
   zoffset {{frame+2*seed+green_i/2}}
   octaves 2
   gamma 1
   xrotate {{green_i*45}}
   yrotate {{green_i*45}}
   name green
   xpos 220
   ypos 43
  }
  Noise {
   output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
   cliptype none
   replace true
   size {{parent.blue_size.w} {parent.blue_size.h}}
   zoffset {{frame+3*seed+blue_i/2}}
   octaves 2
   gamma 1
   xrotate {{blue_i*45}}
   yrotate {{blue_i*45}}
   name blue
   xpos 220
   ypos 86
  }
  Saturation {
   saturation 0
   name Saturation1
   xpos 220
   ypos 112
  }
push $N6852a400
  MergeExpression {
   inputs 2
   expr0 max(minimum.r,r+(2*Ar-1)*(r*red_m+black.r))
   expr1 max(minimum.g,g+(2*Ag-1)*(g*green_m+black.g))
   expr2 max(minimum.b,b+(2*Ab-1)*(b*blue_m+black.b))
   name MergeExpression1
   xpos 220
   ypos 208
  }
set N6856b000 [stack 0]
push $N6852a400
  Copy {
   inputs 2
   channels rgb
   maskChannelInput rgba.alpha
   name Copy1
   xpos 0
   ypos 154
  }
push $N6856b000
  Switch {
   inputs 2
   which {{maskgrain}}
   name Switch1
   xpos 0
   ypos 241
  }
  Output {
   name Output1
   xpos 0
   ypos 286
  }
 end_group
 Shuffle {
  alpha white
  name Shuffle22
  xpos 509
  ypos 3714
 }
push $N68499800
 Merge2 {
  inputs 2+1
  name Merge18
  xpos 509
  ypos 3786
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy1
  xpos 509
  ypos 3855
 }
 Dot {
  name Dot31
  xpos 543
  ypos 3969
 }
 Output {
  name Output1
  xpos 509
  ypos 4133
 }
 StickyNote {
  inputs 0
  name StickyNote15
  tile_color 0xff3100ff
  gl_color 0xff0000ff
  label "<center>IS THIS CORRECT?"
  note_font "Verdana Bold"
  note_font_size 20
  xpos 804
  ypos -940
 }
push $N681be000
 Dot {
  name Dot10
  xpos 428
  ypos -765
 }
 StickyNote {
  inputs 0
  name StickyNote8
  label "<center>Base Color Correction\nfor normalizing shot."
  xpos 318
  ypos -776
 }
 NoOp {
  inputs 0
  name NoOp1
  xpos 815
  ypos -1634
  addUserKnob {20 User}
  addUserKnob {6 Green_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  Green_panelDropped true
  addUserKnob {18 RED}
  RED {1 0 0}
  addUserKnob {6 RED_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  RED_panelDropped true
  addUserKnob {6 RED_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 RED_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 RED_panelDropped_1_1_1 l "panel dropped state" +HIDDEN +STARTLINE}
  addUserKnob {18 Green}
  Green {0 1 0}
  addUserKnob {6 Green_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 Green_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 Green_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 Green_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {18 Blue}
  Blue {0 0 1}
  addUserKnob {6 Blue_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  Blue_panelDropped true
  addUserKnob {6 Blue_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 Blue_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 Blue_panelDropped_1_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
 }
 HueKeyer {
  inputs 0
  name HueKeyer2
  knobChanged RunNode()
  xpos 1499
  ypos 1036
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "Temporary, remove later->"
  xpos 330
  ypos 3054
 }
 StickyNote {
  inputs 0
  name StickyNote7
  label "<center>Color Boost\nIntroduce saturation in\nless saturated areas\n(should be reduced)"
  xpos 313
  ypos -540
 }
 StickyNote {
  inputs 0
  name StickyNote16
  tile_color 0xff3100ff
  gl_color 0xff0000ff
  label "<center>REDO THIS"
  note_font "Verdana Bold"
  note_font_size 20
  xpos 771
  ypos 1310
 }
end_group
Viewer {
 frame 1
 frame_range 1-100
 colour_sample_bbox {-0.9343749881 -0.5479166508 -0.9333333373 -0.546875}
 viewerProcess "sRGB (ACES)"
 name Viewer1
 xpos -55
 ypos 3776
}
StickyNote {
 inputs 0
 name StickyNote17
 label "\nThis scene show how you can use the updated PointFractalEvolve to blow\nup a object and have the points collide with the floor.\n"
 note_font_size 40
 xpos -2656
 ypos -1650
}
StickyNote {
 inputs 0
 name StickyNote18
 label "Always remember to have a white constant as your input to your geo!"
 xpos 49
 ypos -1546
}
