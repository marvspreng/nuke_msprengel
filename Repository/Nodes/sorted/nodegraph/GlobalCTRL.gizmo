#! /Applications/Nuke11.0v1/Nuke11.0v1.app/Contents/MacOS/libnuke-11.0.1.dylib -nx
version 11.0 v1
Gizmo {
 inputs 0
 tile_color 0xff
 label "v2.5\n"
 note_font "DejaVu Sans"
 addUserKnob {20 General}
 addUserKnob {22 add_knob l "Add Knob Control" T "thisNODE = nuke.thisNode()\n\np = nuke.Panel('Add Knob')\np.addEnumerationPulldown('select knob type', '\"Check Box\" \"Integer Knob\" \"Floating Point Slider\" \"RGBA Color Knob\" \"Width/Height Knob\" \"2d Position Knob\" \"3d Position Knob\" \"Pull Down Knob\" \"Bounding Box Knob\" \"UV Coordinate Knob\"')\n\np.addSingleLineInput('Knob Name', 'name here')\n\nif p.show() ==1 :\n\n  kNAME = '_'.join(p.value('Knob Name').split(' '))\n\n  checkKnobs = thisNODE.knobs().keys()\n\n  go = 0\n\n  for g in xrange (0, len(checkKnobs), 1) :\n    if kNAME == checkKnobs\[g] :\n      nuke.message('Knob name already exist in this node')\n      go = 1\n\n  if go == 0 :\n\n    mainLABEL = nuke.Text_Knob(kNAME, \"Name : <b>\" +kNAME)\n\n    v_cKnobName = thisNODE\['k_cKnobName'].getValue()\n    if len(v_cKnobName) > 0 :\n      allCK = v_cKnobName.split(',')\n      allCK.append(kNAME)\n      thisNODE\['k_cKnobName'].setValue(','.join(allCK))\n    else :\n      thisNODE\['k_cKnobName'].setValue(kNAME)\n\n    if p.value('select knob type') == 'Floating Point Slider' :\n      k = nuke.Double_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == '2d Position Knob' :\n      k = nuke.XY_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == '3d Position Knob' :\n      k = nuke.XYZ_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'Bounding Box Knob' :\n      k = nuke.BBox_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'UV Coordinate Knob' :\n      k = nuke.UV_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'Integer Knob' :\n      k = nuke.Int_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'Check Box' :\n      k = nuke.Boolean_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'Width/Height Knob' :\n      k = nuke.WH_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'Pull Down Knob' :\n      k = nuke.Enumeration_Knob(kNAME + \"_knob\", kNAME, \['this dropdown menu will updated to the linked knob'])\n    if p.value('select knob type') == 'Channel Knob' :\n      k = nuke.Channel_Knob(kNAME + \"_knob\", kNAME)\n    if p.value('select knob type') == 'RGBA Color Knob' :\n      k = nuke.AColor_Knob(kNAME + \"_knob\", kNAME)\n\n    nodeContainer = nuke.String_Knob(kNAME + \"_nodes\", \"Nodes\")\n    knobContainer = nuke.String_Knob(kNAME + \"_link\", \"Link Knob\")\n\n    selectBTN = nuke.PyScript_Knob(kNAME + '_selectNodes', 'Select Nodes', 'goSTORE = nuke.toNode(\\'store\\')\\ngoSTORE\[\\'select\\'].execute()\\nselectBTN(\\'\{0\}\\')'.format(kNAME))\n\n    updateBTN = nuke.PyScript_Knob(kNAME + '_updateNodes', 'Update Nodes', 'goSTORE = nuke.toNode(\\'store\\')\\ngoSTORE\[\\'update\\'].execute()\\nupdateBTN(\\'\{0\}\\')'.format(kNAME))\n\n    setBTN = nuke.PyScript_Knob(kNAME + '_set', 'Set Link', 'goSTORE = nuke.toNode(\\'store\\')\\ngoSTORE\[\\'set_link\\'].execute()\\nlinkBTN(\\'\{0\}\\')'.format(kNAME))\n\n    rmBTN = nuke.PyScript_Knob(kNAME + '_remove', 'Bake/Remove', 'goSTORE = nuke.toNode(\\'store\\')\\ngoSTORE\[\\'remove\\'].execute()\\nremoveBTN(\\'\{0\}\\')'.format(kNAME))\n\n    thisNODE.addKnob(mainLABEL)\n    thisNODE.addKnob(k)\n    thisNODE.addKnob(nodeContainer)\n    thisNODE.addKnob(selectBTN)\n    thisNODE.addKnob(updateBTN)\n    thisNODE.addKnob(knobContainer)\n    thisNODE.addKnob(setBTN)\n    thisNODE.addKnob(rmBTN)\n    thisNODE\[kNAME].setFlag(nuke.STARTLINE)\n    thisNODE\[kNAME + '_link'].setFlag(nuke.STARTLINE)\n    thisNODE\[kNAME + '_set'].setFlag(nuke.STARTLINE)" +STARTLINE}
 addUserKnob {22 recheck l "Check Connections" -STARTLINE T "root = nuke.root()\n\nthisNODE = nuke.thisNode()\nknobStr = thisNODE\['k_cKnobName'].getValue().split(',')\n\nnodeKnobName = \[]\n\nbrokenNodes = \[]\nbrokenKnobs = \[]\nbrokenExp = \[]\n\nallNodesCheck = \[]\n\nwrongEntries = \[]\n\nfor n in xrange (0, len(knobStr), 1) :\n  record = thisNODE\[str(knobStr\[n])+'_nodes'].getValue().split(',')\n  for count in xrange (0, len(record), 1) :\n    nodeKnobName.append(record\[count])\n\nwith root:\n  for scriptNodes in nuke.allNodes() :\n    nName = scriptNodes\['name'].value()\n    goNode = nuke.toNode(nName)\n    for knob in goNode.allKnobs() :\n      if knob.hasExpression() :\n        for anim in knob.animations() :\n          fullStr = anim.expression()\n          exBreakDown = fullStr.split('.')\n          if exBreakDown\[0] == thisNODE.name() :\n            if nodeKnobName.count(nName) == 0 :\n              brokenNodes.append(nName)\n              brokenKnobs.append(knob.name())\n              brokenExp.append(fullStr.split('.')\[1]\[:-5])\n\n    allNodesCheck.append(scriptNodes.name())\n\n  for compare in xrange (0, len(nodeKnobName), 1) :\n    if allNodesCheck.count(nodeKnobName\[compare]) == 0 :\n      wrongEntries.append(nodeKnobName\[compare])\n\nreport01Format = \[]\nreport02Format = \[]\n\nfor askBroken in xrange (0, len(brokenNodes), 1) :\n  report01Format.append(\"<font color=red>\" + brokenNodes\[askBroken] + \"</font><font color=orange>.\" + brokenKnobs\[askBroken] + \"</font><br>\")\n\nfor askEntries in xrange (0, len(wrongEntries), 1) :\n  report02Format.append(\"<font color=red>\" + wrongEntries\[askEntries] + \"</font><br>\")\n\nprint len(brokenNodes)\nprint len(wrongEntries)\n\nif len(brokenNodes) == 0 and len(wrongEntries) == 0 :\n  nuke.message('no any problems found')\nelse :\n  fullQ = 'Missing entries on following nodes<p>' + ''.join(report01Format) + '<p>The following Entries are not exist in the script:<p>' + ''.join(report02Format) + '<p>Want to fix them?'\n\n  if nuke.ask(fullQ) :\n    for gabage in xrange (0, len(knobStr), 1) :\n      correctEntries = thisNODE\[knobStr\[gabage] + '_nodes'].getValue().split(',')\n      for checkWrong in xrange (0, len(wrongEntries), 1) :\n        if correctEntries.count(wrongEntries\[checkWrong]) != 0 :\n          correctEntries.remove(wrongEntries\[checkWrong])\n          thisNODE\[knobStr\[gabage] + '_nodes'].setValue(','.join(correctEntries))\n\n\n    for update in xrange (0, len(brokenNodes), 1) :\n      if knobStr.count(brokenExp\[update]) != 0 :\n        oldNodesField = thisNODE\[brokenExp\[update]+'_nodes'].getValue().split(',')\n        if oldNodesField.count(brokenNodes\[update]) == 0 :\n          oldNodesField.append(brokenNodes\[update])\n          thisNODE\[brokenExp\[update]+'_nodes'].setValue(str(','.join(oldNodesField)))\n          thisNODE\[brokenExp\[update]+'_set'].execute()\n      else :\n        print 'knob not found'"}
 addUserKnob {1 k_cKnobName l INVISIBLE +INVISIBLE}
 addUserKnob {20 k_remarks l Remarks n 1}
 k_remarks 0
 addUserKnob {26 k_doc l "" +STARTLINE T "<b>Add Knob Control</b> : choose any different knob type in<br>\nthis node to start the main control for the nodes and knobs.<br>\n'Pulldown Knob' will set the options after you linked it.<br>\nChannel_Knob is not support yet.\n<br>\n<p><b>Check Connections</b> : when user copy the node that<br> \nalready linkedin this node. It will not included in the node list.<br>\nThis button helps to re-link all the broken expression and it<br>\ncan help to check the entire scripts with the function of this<br>\n'GlobalCTRL' node.\n<br>\n<p><b>Select Nodes</b> : this button will help you to highlight<br> \nall the nodes in the Nodes list. It useful to help update the list<br>\nwith 'Update Nodes' button.<br>\n<br>\n<p><b>Update Nodes</b> : it will update all the selected node<br>\ninto the list. Keep in mind that it will remove all the nodes on<br>\nthe list and re-write the node list again. So it is better to work<br>\nwith 'Select Nodes' button.\n<br>\n</p><b>Nodes</b> : create the list of nodes to link to this knob.<br> \nUser can use 'Update Nodes' to update the list automatically,<br>\nor type in manually. Use \",\" (no space) to separate the items.<br>\nFor example: Blur1,Grade1,Transform1\n<br>\n<p><b>Link Knob</b> : create the list of knobs to link to this knob.<br>\nIf you are not sure the name of knob, hover cursor on the knob<br>\nto get the name of it. 'Link Knob' list also support multi entires.<br>\nFor example: disable,hide_input,value\n<br>\n<p><b>Set Link</b> : Link the nodes' knobs to this 'GlobalCTRL' knob.\n<br>\n<p><b>Bake/Remove</b> : The function of this button is put back<br>\nthe value of this knob back to the linked knobs, and the knob<br>\nunder 'GlobalCTRL' will be removed. If there has any animation,<br>\nit will copy back to the knob. If any expression, it will keep the<br>\nexpression back to the knob itself, such as '\$gui', 'sin(frame)',<br>\n'random(0, frame)*10'"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 spacer l "" +STARTLINE T <br>}
}
 NoOp {
  inputs 0
  name store
  selected true
  xpos -212
  ypos -87
  hide_input true
  addUserKnob {20 User}
  addUserKnob {22 select T "def selectBTN(UNAME) :\n  thisNODE = nuke.thisGroup()\n  knobNODES = thisNODE\[UNAME + '_nodes'].getValue().split(',')\n  checkNODES = 0\n  checkMSG = \[]\n\n  for i in xrange (0, len(knobNODES), 1) :\n    if nuke.toNode(knobNODES\[i]) != None :\n      selectNODE = nuke.toNode(knobNODES\[i])\n      selectNODE\['selected'].setValue(True)\n    else :\n      checkNODES = 1\n      p = \"<font color=red>\" + knobNODES\[i] + \"</font> node does not exist\"\n      checkMSG.append(p)\n\n  if checkNODES == 1 :\n    nuke.message('<br>'.join(checkMSG))" +STARTLINE}
  addUserKnob {22 update T "def updateBTN(UNAME) :\n  root = nuke.root()\n\n  thisNODE = nuke.thisGroup()\n\n  with root :\n    selectedNODE = nuke.selectedNodes()\n\n    newContainer = \[]\n\n    for nodes in selectedNODE:\n      newContainer.append(nodes\['name'].getValue())\n\n  thisNODE\[UNAME + '_nodes'].setValue(','.join(newContainer))" +STARTLINE}
  addUserKnob {22 set_link T "def linkBTN(UNAME) :\n  thisNODE = nuke.thisGroup()\n\n  getNODES = thisNODE\[UNAME + '_nodes'].getValue().split(',')\n  getLINK = thisNODE\[UNAME + '_link'].getValue().split(',')\n\n  checkNODES = 0\n  checkMSG = \[]\n\n  for i in xrange (0, len(getNODES), 1) :\n    for x in xrange (0, len(getLINK), 1) :\n      if nuke.toNode(getNODES\[i]) != None :\n        if nuke.toNode(getNODES\[i]).knob(getLINK\[x]) != None :\n          if str(thisNODE.knob(UNAME + '_knob')).split(' ')\[0] == '<AColor_Knob' :\n            nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setSingleValue(False)\n            nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setExpression('\{1\}.\{0\}_knob'.format(UNAME, thisNODE.name()))\n          else :\n            if str(thisNODE.knob(UNAME + '_knob')).split(' ')\[0] == '<Enumeration_Knob' :\n              dropdown_list = nuke.toNode(getNODES\[i]).knob(getLINK\[x]).values()\n              thisNODE\[UNAME + '_knob'].setValues(dropdown_list)\n              nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setExpression('\{1\}.\{0\}_knob'.format(UNAME, thisNODE.name()))\n            else :\n              nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setExpression('\{1\}.\{0\}_knob'.format(UNAME, thisNODE.name()))\n        else :\n          checkNODES = 1\n          p = getNODES\[i] + \".\" + \"<font color=orange>\" + getLINK\[x] + \"</font>\" + \" knob does not exist\"\n          checkMSG.append(p)\n      else :\n        checkNODES = 1\n        p = \"<font color=red>\" + getNODES\[i] + \"</font> node does not exist\"\n        checkMSG.append(p)\n\n  if checkNODES == 1 :\n    nuke.message('<br>'.join(checkMSG))" +STARTLINE}
  addUserKnob {22 remove T "def removeBTN(UNAME) :\n  thisNODE = nuke.thisGroup()\n  getNODES = thisNODE\[UNAME + '_nodes'].getValue().split(',')\n  getLINK = thisNODE\[UNAME + '_link'].getValue().split(',')\n\n  checkNODES = 0\n  checkMSG = \[]\n\n  if len(thisNODE\[UNAME + '_nodes'].getValue())!=0 or len(thisNODE\[UNAME + '_link'].getValue())!=0 :\n    root = nuke.root()\n    with root :\n      for i in xrange (0, len(getNODES), 1) :\n        for x in xrange (0, len(getLINK), 1) :\n          if nuke.toNode(getNODES\[i]) != None :\n            if nuke.toNode(getNODES\[i]).knob(getLINK\[x]) != None :\n              if str(thisNODE.knob(UNAME + '_knob')).split(' ')\[0] == '<Channel_Knob' :\n                getChan = thisNODE.knob(UNAME + '_knob').value()\n                nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setExpression('')\n                nuke.toNode(getNODES\[i]).knob(getLINK\[x]).setValue(getChan)\n              else :\n                if thisNODE\[UNAME + '_knob'].isAnimated() == True :\n                  tempHIGHLIGHT = nuke.toNode(getNODES\[i])\n                  tempHIGHLIGHT\[getLINK\[x]].copyAnimations(thisNODE\[UNAME + '_knob'].animations())\n                else :\n                  nuke.toNode(getNODES\[i]).knob(getLINK\[x]).clearAnimated()\n            else :\n              checkNODES = 1\n              p = getNODES\[i] + \".\" + \"<font color=orange>\" + getLINK\[x] + \"</font>\" + \" knob does not exist\"\n              checkMSG.append(p)\n          else :\n            checkNODES = 1\n            p = \"<font color=red>\" + getNODES\[i] + \"</font> node does not exist\"\n            checkMSG.append(p)\n\n  if checkNODES == 1 :\n    nuke.message('<br>'.join(checkMSG))\n\n  def rmKNOB(x) :\n    n = thisNODE.knobs()\n    thisNODE.removeKnob(n\[x])\n\n  rmKNOB(UNAME)\n  rmKNOB(UNAME + '_knob')\n  rmKNOB(UNAME + '_nodes')\n  rmKNOB(UNAME + '_selectNodes')\n  rmKNOB(UNAME + '_updateNodes')\n  rmKNOB(UNAME + '_link')\n  rmKNOB(UNAME + '_set')\n  rmKNOB(UNAME + '_remove')\n\n  rmStr = thisNODE\['k_cKnobName'].getValue().split(',')\n  newStr = \[]\n  for s in xrange (0, len(rmStr), 1) :\n    if rmStr\[s] != UNAME :\n      newStr.append(rmStr\[s])\n  thisNODE\['k_cKnobName'].setValue(','.join(newStr))\n" +STARTLINE}
 }
end_group
